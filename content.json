{"pages":[],"posts":[{"title":"关于生命中最亲的人的离别","text":"什么是离别？离别是离开，不会再相见的意思。人要是真的走了，那么这辈子，就真的不会再见了。有些词，再也没有用武之地，比如，爷爷，奶奶，而如今多了一个外婆。这些词的含义，也到此为止了。 生命又是什么？生命就是从获得它的最开始，到最终的结束。会遇到各种各样的人，有对你好的，有对你亲的，在你的生命旅程中，陪伴着你一起走。 什么又是最亲的人？在你生命中出现的，可能对你最好的人，也许是你妈，你爸，或者爷爷和奶奶，又或者是哥哥，姐姐。。。总是会给你比其他人，更多的关注，更你更多的帮助，给你信任，给你支持。在你困难的时候，最无助的时候，也是第一时间会想起ta们 那么长大又是怎么回事？长大就是不断的从一个地方去到另外一个地方，渐渐的离开你最亲的人，从小时候的一直陪伴，到慢慢寒暑假可以在一起见两次，到最后的，每年春节回去见一次。长大，就是慢慢的见面机会越来越少的意思。不再论时间，而是论次数。 那么为什么要长大？这个问题，就和人为什么会老，我一直都不理解。也不想去理解。 那生命+最亲人+离别会怎么样？我会想起，很小的时候，是从那个有ta的地方长大的，教我穿衣服，拿筷子，很多的第一次都是从那个时候开始的，因此，我忘不了，那时候每年的新衣服都是ta买的，然后，从那个时候我就一直记得我的理想。 稍微长大了一点，哭着离开那个不舍得的地方，不管怎么样，那个时候，每年过寒假，就要回去，熟悉的环境，熟悉的人都在。人总是不把目前的一些东西认为理所当然，可不知，有一天总会失去这种日常生活。 慢慢再大了一点，好像是有了自己的想法了，就渐渐不在有曾经的那种认识了，自以为长大了，什么都懂了，其实回过头来看自己什么也不懂。 忘不了，每年过年，给我压岁钱的时候，总是背着其他的孩子多给我一百，我一直攒着放在一个本子里面没动。 虽然从五台山跟着ta去过很多次了，曾经徒步走过，五个台，忘不了，那种辛苦，所以发誓下次再来的时候，一定要开着坚决不再走了。现在回头看来，已经成为了宝贵的记忆。一起走过南山寺,龙泉寺，佛光寺，钻过佛母洞，一起住寺庙，吃斋饭，上早课，念经文 忘不了，ta曾说过，以后老了能走动的时候，还想去一趟五台山，我也记在了心里。也就是从那个时候养成的生活习惯，一直保留到现在，我也会以后传承下去的。 人总是健忘的，容易忘记过去，忘记曾经的艰辛。 于是，又慢慢长大了一点，要出去读书，上学去了，真正的意义的远离了家乡，从时间变为了次数，一年两次的仅有的回家机会。 忘不了，大学入学那年，是ta买的送给我的第一个手机，虽然那个时候经济已经不如从前了，可是为了我，还是舍得 到后来，毕业了，工作了，慢慢的变为了一年春节的一次。剩给我们的时间真的不多了。 那年，我也是第一次，懂了，生老病死，这简简单单的四个字的含义，是如此的简单，如此的直白。 可能，你从小到现在，都没有感觉自己发生什么变化，可是，真实的是变化，发生在你身边，有些人不经意之间就老了。是如此的快，如此的猝不及防。 人生总是这么无奈，当你没有能力的时候，受别人的照顾，而你奋斗刚有能力的时候，照顾你的人却已经不在你身边了。 忘不了，原来今年夏天的那一面，居然是这辈子的最后一面，那时，还是好好的，可是，如今， 曾经那么坚强的人，为什么突然变得这么脆弱，说走就这么轻易离开了， 你在最后，在想什么，你又想说什么，我都不得而知了。 只是听到，最后说你，一呼一呼的，喘不上气，在等最后的人，也没有等到，我听了，眼泪情不自禁的掉了下来，控制不住自己。 这个根本不是我认识的熟悉的你，你在我从小的印象中从来都不是这样的，你到底是怎么了这两年来？ 请你告诉我，为什么好人就不能长命百岁？ 为了那些不争气的人，你总是替他们操碎了心，这下你好了，就不用管他们了。 对，你是解放了，不用再过问这些俗事了，也该好好休息一下了。 对不起，请你再等等我，从我出生到现在，陪伴了快三十年的时间，我马上回去，明天就回去看你，这点时间我想你是不会介意的吧，你要是介意，请你告诉我。 请你原谅我的不坚强，我向你保证，这是最后一次流泪了。 所以，我想在你面前痛哭，看你今生的最后一眼，送你走完最后一程，我们来生再见。","path":"2017/08/31/person-leave/"},{"title":"如何创建一个简单hello wolrd的amp网页？","text":"今天我们说点什么呢？直接看下面的效果： 这是一个简单的AMP测试页面按照官网搭建的hello world，主要是amp的自己标签应用，明天继续高点事情","path":"2017/08/28/amp-hello/"},{"title":"关于Java中的编程规约","text":"今天要分享的内容是Java中的编程规约，之前看公司的这个java这部分都空中，就看到前端日志的阿里巴巴的开发手册，把我关注的地方总结了一下。 目录 命名规约 常量定义 格式规约 OOP规约 集合处理 并发处理 控制语句 注释规约 异常处理 日志规约 其它规约 命名规约 【强制】所有编程相关命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 反例： _name /__name / $Object / name_ / name$ / Object$ 【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式 也要避免采用。 反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 变量 = 3; 正例： ali / alibaba / taobao / cainiao / aliyun / youku / hangzhou 等国际通用的 名称，可视为英文。 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型 的相关命名）DO / DTO / VO / DAO 等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。 正例： localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT 反例： MAX_COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类命 名以它要测试的类的名称开始，以 Test 结尾。 【强制】中括号是数组类型的一部分， 数组定义如下：String[] args; 反例：请勿使用 String args[]的方式来定义 【强制】POJO 类中的任何布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出 异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例： 应用工具类包名为 com.alibaba.mpp.util、类名为 MessageUtils（此规则参考 spring 的框架结构） 【强制】杜绝完全不规范的缩写，避免望文不知义。 反例：&lt;某业务代码&gt;AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。 正例：public class OrderFactory; public class LoginProxy; public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。 正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = &quot;alibaba&quot;; 反例：接口方法定义：public abstract void f(); 说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默 认实现。 接口和实现类的命名有两套规则： 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部 的实现类用 Impl 的后缀与接口区别。 正例：CacheServiceImpl 实现 CacheService 接口。 【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形 式）。 正例：AbstractTranslator 实现 Translatable。 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。 说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 正例：枚举名字：DealStatusEnum；成员名称：SUCCESS / UNKOWN_REASON。 【参考】各层命名规约： Service/DAO 层方法命名规约获取单个对象的方法用 get 做前缀。 获取多个对象的方法用 list 做前缀。获取统计值的方法用 count 做前缀。 插入的方法用 save（推荐）或 insert 做前缀。删除的方法用 remove（推荐）或 delete 做前缀。 修改的方法用 update 做前缀。 领域模型命名规约数据对象：xxxDO，xxx 即为数据表名。 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。展示对象：xxxVO，xxx 一般为网页名称。 POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 常量定义 【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。 反例： String key=&quot;Id#taobao_&quot;+tradeId； cache.put(key, value); 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。 说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存 相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。 说明：大而全的常量类，非得 ctrl+f 才定位到修改的常量，不利于理解，也不利于维护。 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包 内共享常量、类内共享常量。 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 const 目录下。 应用内共享常量：放置在一方库的 modules 中的 const 目录下。 反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示 “是”的变量： 类 A 中：public static final String YES = &quot;yes&quot;; 类 B 中：public static final String YES = &quot;y&quot;; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致产生线上问题。 子工程内部共享常量：即在当前子工程的 const 目录下。 包内共享常量：即在当前包下单独的 const 目录下。 类内共享常量：直接在类内部 private static final 定义。 【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须 使用 Enum 类，下面正例中的数字就是延伸信息，表示星期几。 正例：public Enum{ MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);} 格式规约 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果 是非空代码块则： 左大括号前不换行。 左大括号后换行。 右大括号前换行。 右大括号后还有 else 等代码则不换行；表示终止右大括号后必须换行。 【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格。 【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。 【强制】任何运算符左右必须加一个空格。 说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。 【强制】代码块缩进 4 个空格，如果使用 tab 缩进，请设置成 1 个 tab 为 4 个空格。 12345678910111213141516171819public static void main(String args[]) &#123;// 缩进 4 个空格 String say = &quot;hello&quot;;// 运算符的左右必须有一个空格 int flag = 0;// 关键词 if 与括号之间必须有一个空格，括号内 f 与左括号，1 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125;// 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println(&quot;world&quot;);// 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(&quot;ok&quot;);// 右大括号做为结束，必须换行 &#125;&#125; 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时，遵循如下原则： 换行时相对上一行缩进 4 个空格。 运算符与下文一起换行。 方法调用的点符号与下文一起换行。 在多个参数超长，逗号后进行换行。 在括号前不要换行，见反例。 正例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 s b.append(&quot;zi&quot;).append(&quot;xin&quot;)… .append(&quot;huang&quot;); 反例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)…append (&quot;huang&quot;); //参数很多的方法调用也超过 120 个字符，逗号后才是换行处 method(args1, args2, args3, ... , argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例：下例中实参的&quot;a&quot;,后边必须要有一个空格。 method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); 【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。 正例： int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer(); 说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的 情况下，是一种累赘的事情。 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不 要使用 windows 格式。 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之 间插入一个空行。相同业务逻辑和语义之间不需要插入空行。 说明：没有必要插入多行空格进行隔开。OOP规约 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。 【强制】所有的覆写方法，必须加@Override 注解。 反例：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编 译报错。 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程） 正例：public User getUsers(String type, Integer... ids); 【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接 口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。 【强制】不能使用过时的类或方法。说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该 使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那 么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例： &quot;test&quot;.equals(object); 反例： object.equals(&quot;test&quot;); 说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之 外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方 法进行判断。 【强制】关于基本数据类型与包装数据类型的使用标准如下： 所有的 POJO 类属性必须使用包装数据类型。 RPC 方法的返回值和参数必须使用包装数据类型。 所有的局部变量推荐使用基本数据类型。说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。 正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。 反例：某业务的交易报表上显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划 线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。 反例：某业务的 DO 的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置 入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】POJO 类必须写 toString 方法。使用工具类 source&gt; generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排 查问题。 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内 容的检查，否则会有抛 IndexOutOfBoundsException 的风险。说明： String str = &quot;a,b,c,,&quot;; String[] ary = str.split(&quot;,&quot;); //预期大于 3，结果是 3 System.out.println(ary.length) 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便 于阅读。 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方 法。 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类 关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一 个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最 后。 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在 getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题难度。 反例： public Integer getData(){ if(true) { return data + 100; } else { return data - 100; } } 【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。 反例： String str = &quot;start&quot;; for(int i=0; i&lt;100; i++){ str = str + &quot;hello&quot;; } 说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 【推荐】final 可提高程序响应效率，声明成 final 的情况： 不需要重新赋值的变量，包括类属性、局部变量。 对象参数前加 final，表示不允许修改引用的指向。 类方法确定不允许被重写。 【推荐】慎用 Object 的 clone 方法来拷贝对象。说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的 拷贝。 【推荐】类成员与方法访问控制从严： 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 工具类不允许有 public 或 default 构造方法。 类非 static 成员变量并且与子类共享，必须是 protected。 类非 static 成员变量并且仅在本类使用，必须是 private。 类 static 成员变量如果仅在本类使用，必须是 private。 若是 static 成员变量，必须考虑是否为 final。 类成员方法只供类内部调用，必须是 private。 类成员方法只对继承类公开，那么限制为 protected。 说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。 思 考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一 个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视 线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。 集合处理 集合处理 【强制】Map/Set 的 key 为自定义对象时，必须重写 hashCode 和 equals。 正例：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作 为 key 来使用。 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ; 说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。 【强制】在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、 删除均产生 ConcurrentModificationException 异常。 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全 一样的数组，大小就是 list.size()。 反例： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它 类型数组将出现 ClassCastException 错误。 正例： List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(&quot;guan&quot;); list.add(&quot;bao&quot;); String[] array = new String[list.size()]; array = list.toArray(array); 说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配 内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组 元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素 个数一致。 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。String[] str = new String[] { “a”, “b” }; List list = Arrays.asList(str);第一种情况：list.add(“c”); 运行时异常。 第二种情况：str[0]= “gujin”; 那么 list.get(0)也会随之修改。 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。 说明：苹果装箱后返回一个&lt;? extends Fruits&gt;对象，此对象就不能往里加任何水果，包括苹 果。 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 反例： List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;); a.add(&quot;2&quot;); for (String temp : a) { if(&quot;1&quot;.equals(temp)){ a.remove(temp); } } 说明：这个例子的执行结果会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结 果吗？ 正例： Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext()){ String temp = it.next(); if(删除元素的条件){ it.remove(); } } 【强制】在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort， Collections.sort 会报 IllegalArgumentException 异常。说明： 自反性：x，y 的比较结果和 y，x 的比较结果相反。 传递性：x&gt;y,y&gt;z,则 x&gt;z。 对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。 反例：下例中没有处理相等的情况，实际使用中可能会出现异常： new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { return o1.getId() &gt; o2.getId() ? 1 : -1; } } 【推荐】集合初始化时，尽量指定集合初始值大小。说明：ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更 高。如果是 JDK8，使用 Map.foreach 方法。 正例：values()返回的是 V 值集合，是一个 list 集合对象； keySet()返回的是 K 值集合，是 一个 Set 集合对象；e ntrySet()返回的是 K-V 值组合集合。 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格： 集合类 Key Value Super 说明 Hashtable 不允许为 null 不允许为 null Dictionary 线程安全 ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 线程局部安全 TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全 HashMap 允许为 null 允许为 null AbstractMap 线程不安全 反例：很多同学认为 ConcurrentHashMap 是可以置入 null 值。在批量翻译场景中，子线程分 发时，出现置入 null 值的情况，但主线程没有捕获到此异常，导致排查困难。 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不 稳定性(unorder)带来的负面影响。 说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则 依次排列的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。 【参考】利用 Set 元素唯一的特性，可以快速对另一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历去重操作。 并发处理 【强制】获取单例对象要线程安全。在单例对象里面做操作也要保证线程安全。 说明：资源驱动类、工具类、单例工厂类都需要注意。 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。 正例：注意线程安全，使用 DateUtils。亦推荐如下处理： private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); } }; 说明：如果是 JDK8 的应用，可以使用 instant 代替 Date，Localdatetime 代替 Calendar， Datetimeformatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序 也必须是 A、B、C，否则可能出现死锁。 【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在 数据库层使用乐观锁，使用 version 作为更新依据。说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获 抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 各个方法的弊端： newFixedThreadPool 和 newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。 newCachedThreadPool 和 newScheduledThreadPool:主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 正例： public class TimerTaskThread extends Thread { public TimerTaskThread(){ super.setName(&quot;TimerTaskThread&quot;); … } 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方 法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。说明：Random 实例包括 java.util.Random 的实例或者 Math.random()实例。 正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个线 程一个实例。 【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化 问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方 案中较为简单一种（适用于 jdk5 及以上版本），将目标属性声明为 volatile 型（比如反例 中修改 helper 的属性声明为 private volatile Helper helper = null;）； 反例： class Foo { private Helper helper = null; public Helper getHelper() { if (helper == null) synchronized(this) { if (helper == null) helper = new Helper(); } return helper; } // other functions and members... } 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。如果想取回 count++数据，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); count++操作如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。 【参考】注意 HashMap 的扩容死链，导致 CPU 飙升的问题。 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。 这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态 变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这 个线程内定义的)都可以操控这个变量。 控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 来终止，要么注释说明程序 将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在 最后，即使它什么代码也没有。 【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，避免使用下 面的形式：if (condition) statements; 【推荐】推荐尽量少用 else， if-else 的方式可以改写成： if(condition){ … return obj; } // 接着写 else 的业务逻辑代码; 说明：如果使用要 if-else if-else 方式表达逻辑，【强制】请勿超过 3 层，超过请使用状态 设计模式。 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行复杂的语句，以提高 可读性。 正例： //伪代码如下 InputStream stream = file.open(fileName, &quot;w&quot;); if (stream != null) { … } 反例： if (file.open(fileName, &quot;w&quot;) != null)) { … } 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、 获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。 【参考】方法中需要进行参数校验的场景： 调用频次低的方法。 执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致 中间执行回退，或者错误，那得不偿失。 需要极高稳定性和可用性的方法。 对外提供的开放接口，不管是 RPC/API/HTTP 接口。 【参考】方法中不需要参数校验的场景： 极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参 数检查。 底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错 误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台 服务器中，所以 DAO 的参数校验，可以省略。 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参 数已经做过检查或者肯定不会有问题，此时可以不校验参数。 注释规约 【强制】类、类属性、类方法的注释必须使用 javadoc 规范，使用/*内容/格式，不得使用//xxx 方式。说明：在 IDE 编辑窗口中，javadoc 方式会提示相关注释，生成 javadoc 可以正确输出相应注 释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高 阅读效率。 【强制】所有的抽象方法（包括接口中的方法）必须要用 javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：如有实现和调用注意事项，请一并说明。 【强制】所有的类都必须添加创建者信息。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使 用/ /注释，注意与代码对齐。 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词、关键字，保 持英文原文即可。 反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。 说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。 【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。 说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看 的，使其能够快速接替自己的工作。 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一 个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。 反例： // put elephant into fridge put(elephant, fridge); 方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么， 语义清晰的代码不需要额外的注释。 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个 javadoc 的标签，目前的javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 javadoc 标签）。 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 异常处理 【强制】不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保 证程序健壮性。 正例：if(obj != null) {...} 反例：try { obj.method() } catch(NullPointerException e){…} 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳 定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分 异常类型，再做对应的异常处理。 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 说明：如果 JDK7，可以使用 try-with-resources 方法。* 【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不 会再执行 try 块中的 return 语句。 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期抛的是绣球，实际接到的是铅球，就会产生意外情况。 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分 说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。 说明：本规约明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用 者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回 null 的情况。 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景： 返回类型为包装数据类型，有可能是 null，返回 int 值时注意判空。 反例： public int f(){ return Integer 对象}，如果为 null，自动解箱抛 NPE。 数据库的查询结果可能为 null。 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 远程调用返回对象，一律要求进行 NPE 判断。 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。 【推荐】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必 须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式， 封装 isSuccess、“错误码”、“错误简短信息”。说明：关于 RPC 方法返回方式使用 Result 方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输 的性能损耗也是问题。 【推荐】定义时区分 unchecked / checked 异常，避免直接使用 RuntimeException 抛出，更 不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过 的自定义异常，如：DaoException / ServiceException 等。 【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副 本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。 正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto){…} 日志规约 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 正例：mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，错误日志和业务日志尽量分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。说明：logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol); 如果 日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会 执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 正例：（条件） if (logger.isDebugEnabled()) { logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol); } 正例：（占位符） logger.debug(&quot;Processing trade with id: {} and symbol : {} &quot;, id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。 正例：&lt;logger name=&quot;com.taobao.ecrm.member.config&quot; additivity=&quot;false&quot;&gt; 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么往上 抛。 正例：logger.error(各类参数或者对象 toString + &quot;_&quot; + e.getMessage(), e); 输出的 POJO 类必须重写 toString 方法，否则只输出此对象的 hashCode 值（地址值），没啥 参考意义。 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常、或者重要的错误信息。如 非必要，请不要在此场景打出 error 级别，避免频繁报警。 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。纪录日志时请 思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 【参考】如果日志用英文描述不清楚，推荐使用中文注释。对于中文 UTF-8 的日志，在 secureCRT 中，set encoding=utf-8；如果中文字符还乱码，请设置：全局&gt;默认的会话设置&gt;外观&gt;字体&gt;选择字符集 gb2312；如果还不行，执行命令：set termencoding=gbk，并且直接使用中文来 进行检索。 其它规约 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则); 【强制】避免用 Apache Beanutils 进行属性的 copy。说明：Apache BeanUtils 性能较差，可以使用其他方案比如 Spring BeanUtils, Cglib BeanCopier。 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按 规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（注意，boolean 命名不需要 加 is 前缀），会自动调用 isXxx()方法。说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。 说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值范围 0≤x&lt;1（能够取 到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取 整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。 【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime(); 说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime。在 JDK8 中，针对统计时 间等场景，推荐使用 Instant 类。 【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻 辑。 【推荐】任何数据结构的使用都应限制大小。 说明：这点很难完全做到，但很多次的故障都是因为数据结构自增长，结果造成内存被吃光。 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性 等要坚决从程序中清理出去，避免造成过多垃圾。清理这类垃圾代码是技术气场，不要有这样 的观念：“不做不错，多做多错”。","path":"2017/07/24/java-format/"},{"title":"关于hive中decode函数，默认转码没有GBK中文字符集的问题","text":"今天要分享的内容是hive的select查询中的decode函数，对url进行转码的查询，看了官方文档，心都凉了，如下stringdecode(binary bin, string charset)Decodes the first argument into a String using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). If either argument is null, the result will also be null. (As of Hive 0.12.0.) 官方文档上面的那句话，就是说，默认的编码类型，只能从中的一个字符类型，其他不在范围内的肯定识别不了 比如说，%cb%d1%b9%b7上面的这个转码以后是，搜狗 前提必须是，用gbk，gb1312，gb18030随便一个字符集就可以了，他们的三个区别，基本就是gb1312&lt;gbk&lt;gb18030,就是说，一个包含的字符集比一个多，也就是更全 如果你用java的utf-8解码，肯定是乱码中文 如果你用js的decodeURI()的这个方法，会报错，因为他不是utf-8的转码 搜狗的utf-8的编码是多少？%e6%90%9c%e7%8b%97 因此，你无论用java的urldecoder的decode方法，或者js中的decodeURI(“%e6%90%9c%e7%8b%97”)方法，都是能得到正确的编码的 那在hive中怎么办？关于怎么办这个地方，真是被坑了好久了 资料少，根本搜不到 你也不会搜，也就是不会提问，当然搜不到 总之，就是找不到答案 答案就是，另外的一个内建函数reflect select reflect(‘java.net.URLDecoder’, ‘decode’,’%cb%d1%b9%b7’ , “GBK”) from tmp_table 光看名字，就会让你想到，java中的反射，果不其然，这次就到了，你熟悉的地方了 因为网上的例子太少了，就连写出上面的查询，都是各种坑啊 最后一个无关的问题，charset.forName(),或者，decode函数，字符集区分大小写吗？不区分，官方文档里面说了 如何做到不区分的？Charset gg = Charset.forName(“gg”);为什么识别是错的？这个本来和hive是无关的，最开始运行的时候报错了，以为是这个地方的问题 最后最终调试了一下代码，总算是知道，为啥可以做到忽略大小写的问题，里面有一个很关键的排序比较器 网上的资源，太少了，根本没有一个讲这个部分的原理，看了半天硬是没有看明白 最终在不限的努力，找到了一个关键类 ASCIICaseInsensitiveComparator 就是他，起到了忽略大小写的关键原因，可以用ide反向最终一下，一看就明白","path":"2017/07/21/hive-decode/"},{"title":"如何展示自己定义的一些html页面？","text":"今天我们说点什么呢？直接看下面的效果： 上面的这三个小黄人，是我自己内部的html文件，采取的方案，就是上篇文章中所说的两种方案结合 1方案的好处在于，他和hexo主题相结合，保持了主题的一致性2方案的好处在于，完全能自定义html文件，包括里面的css和js因此我的思路，就是利用这两种方案的优点结合起来，定义这个markdown模板 只要每次，改一下iframe中的src路径地址，就可以了，剩下的可以随意展示定制自己的网站了。","path":"2017/07/21/originTemplate/"},{"title":"关于hexo中使用自己定义的html页面方法","text":"hexo中实用原生html的两种方法hexo中实用原生html的两种方法方法一你现在看到的这个页面，就是自己原生写的html文件。直接在你的markdown里面的头部，写上一句，layout:false就可以写你的熟悉的html页面了。但是，确定也是很明显的，就是所有的标签页，那些提示都写用不了啦，变成了原生的人肉没有ide自己写页面，当然痛苦，而且样式不可以控制方法二在_config.yml中配置一个，skip_render属性，默认是source根部下面的因此，我这里，提前弄好了一个自定义的小黄人html页面","path":"2017/07/21/originHtml/"},{"title":"关于java中的synchronized的用法","text":"今天要分享的内容是synchronized这个地方也是，说起来知道同步的用法，但是并不是多么的清楚，和上面的那篇mysql的子查询一样，看到代码中很多这样写的。就顺便研究总结一下： 修饰对象有几种(能出现在什么地方) 修饰一个类，其作用的范围是synchronized后面括号括起来的部分， 作用的对象是这个类的所有对象。 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法， 作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法， 作用的对象是这个类的所有对象； 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码， 作用的对象是调用这个代码块的对象； 2个锁上面的4种情况，核心也就是，2个锁 对象锁，修饰一个类的成员方法和代码块，就是这种情况，他强调的是创建对象，调用对象本身，比如，a对象和b对象完全不同 类锁（其实没有，类比概念，好理解），也就是修饰类，和静态的方法，这两种的同步是一样的，他们强调的是类class这个对象的锁，因此a对象和b对象拥有同样的锁，所以是相同的 废话不多说，直接上例子吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/** * @author hankun * @create 2017-07-05 19:52 */public class synchronizedTest &#123; /** * 同步线程,修饰方法块 */ static class SyncMehtodBlock implements Runnable &#123; private static int count; public SyncMehtodBlock() &#123; count = 0; &#125; public void run() &#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtodBlock&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtodBlock&quot;); &#125; &#125; &#125; /** * 同步线程,修饰方法 */ static class SyncMehtod extends Thread &#123; private synchronizedTest syn; public SyncMehtod(synchronizedTest synchronizedTest) &#123; this.syn = synchronizedTest; &#125; public void run() &#123; syn.test(); &#125; &#125; public synchronized void test() &#123; System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtod&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtod&quot;); &#125; /** * 同步线程,修饰静态方法 */ static class SyncStaticMehtod extends Thread &#123; public synchronized static void staticTest() &#123; System.out.println(Thread.currentThread().getName() + &quot;开始..SyncStaticMehtod&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束..SyncStaticMehtod&quot;); &#125; public void run() &#123; staticTest(); &#125; &#125; /** * 同步线程,修饰类 */ static class SyncClass extends Thread &#123; public void classTest() &#123; synchronized (synchronizedTest.class) &#123; System.out.println(Thread.currentThread().getName() + &quot;开始..SyncClass&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束..SyncClass&quot;); &#125; &#125; public void run() &#123; classTest(); &#125; &#125; public static void main(String[] args) &#123; //情况1，修饰方法块 SyncMehtodBlock syncMehtodBlock = new SyncMehtodBlock(); Thread thread1 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock1&quot;); Thread thread2 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock2&quot;); thread1.start(); thread2.start(); //情况2，修饰方法 synchronizedTest syn = new synchronizedTest(); SyncMehtod syncMehtod3 = new SyncMehtod(syn); SyncMehtod syncMehtod4 = new SyncMehtod(syn); syncMehtod3.start(); syncMehtod4.start(); //情况3，修饰静态方法 SyncStaticMehtod a = new SyncStaticMehtod(); SyncStaticMehtod b = new SyncStaticMehtod(); Thread thread5 = new Thread(a, &quot;SyncStaticMehtod1&quot;); Thread thread6 = new Thread(b, &quot;SyncStaticMehtod2&quot;); thread5.start(); thread6.start(); //情况4，修饰类 SyncClass c = new SyncClass(); SyncClass d = new SyncClass(); Thread thread7 = new Thread(c, &quot;SyncClass1&quot;); Thread thread8 = new Thread(d, &quot;SyncClass2&quot;); thread7.start(); thread8.start(); &#125;&#125; 我写了一个，模拟4种情况的例子，报每个类型都包含进去了 请注意观察里面的synchronized的关键位置，出现的情况，以及每个测试例子，是如何新建的，区分不同 所有的例子，都是具有同步的，因为竞争，比如，a先开始，那么a先结束，然后才能轮到b开始，b结束 好好，体会里面的内容 总结 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 我觉得别人说的，这三句话，已经说的很明白不过，我也就不加自己的体会了","path":"2017/07/05/java-synchronized/"},{"title":"关于mysql中select子查询","text":"今天要分享的内容是mysql的select子查询一直记得凯哥，半年前说过的一句话，原来你不知道，子查询啊，其实，我知道是又这么一回事但是，具体又说不上来，大概就是那种，一看就知道，但是你有不完全知道的类型吧现在在写hive语法的时候又碰到了，那么就好好总结一次吧。 子查询定义在一个表表达中可以调用另一个表表达式，这个被调用的表表达式叫做子查询（subquery），那么也称作子选择（subselect）或内嵌选择（inner select）。子查询的结果传递给调用它的表达式继续处理。 说人话就是，一个sql语句，出现了2个以上的select关键词，这个清晰了吧？ 子查询分类11*1 标量子查询：返回的结果集是一个标量集合，一行一列，也就是一个标量值。可以指定一个标量表达式的任何地方，都可以用一个标量子查询。 1*n 行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。 n*1 列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）。 n*n 表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。 就这么四类 从定义上讲， 每个标量子查询也是一个行子查询和一个列子查询，反之则不是； 每个行子查询和列子查询也是一个表子查询，反之也不是。 子查询分类2where型子查询：（把内层查询结果当作外层查询的比较条件） 定义：where型的子查询就是把内层查询的结果当作外层查询的条件。 from型子查询：（把内层的查询结果供外层再次查询） 定义：from子查询就是把子查询的结果(内存里的一张表)当作一张临时表，然后再对它进行处理。 exists型子查询：（把外层查询结果拿到内层，看内层的查询是否成立） 定义：exists子查询就是对外层表进行循环，再对内表进行内层查询。和in ()差不多，但是它们还是有区别的。主要是看两个张表大小差的程度。若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）； 其实，光这么说，很难明白的，因为你都没写过，根本理解不了，尤其是exisit子查询 使用子查询原则1.一个子查询必须放在圆括号中。 2.将子查询放在比较条件的右边以增加可读性。 子查询不包含 ORDER BY 子句。对一个 SELECT 语句只能用一个 ORDER BY 子句，并且如果指定了它就必须放在主 SELECT 语句的最后。 3.在子查询中可以使用两种比较条件：单行运算符(&gt;, =, &gt;=, &lt;, &lt;&gt;, &lt;=) 和多行运算符(IN, ANY, ALL)。 where型子查询select * from a where a.xx = (select xx from b where b.xx=”xx”),这种感觉 from型子查询select from (select from a) as aa,这种感觉 exists型子查询因为上面那两种，子查询，很明了简单，就不谈了，主要说下面的 尽量表达清楚 EXISTS关键字表示存在。使用EXISTS关键字时，内层查询语句不返回查询的记录， 而是返回一个真假值，如果内层查询语句查询到满足条件的记录， 只要子查询中至少返回一个值，则EXISTS语句的值就为True。 就返回true，否则返回false。当返回的值为true时，外层查询语句将进行查询， 否则不进行查询。NOT EXISTS刚好与之相反。exists的用法和in ()差不多， 但是它们还是有区别的。主要是看两个张表大小差的程度。 若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）; 看上面这段话的，解释，保证，你看了，也不知道在说啥，其实说的稍微有点问题 正确的解释，应该是，上面的当然也没错 exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条 件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false 就是循环外层的查询结果，然后带进去，查看条件是否成立，不成立丢弃，成立留下 select * from user where exists (select 1); 这句话，就会输出，user表中全部的人，因为后面的条件，对于每个人都成立 select * from user where userId in (1, 2, 3); 这样的in查询，等价于 select * from user where userId = 1 or userId = 2 or userId = 3; 因此，要求in后面的表是小表，才不至于，很大的表，循环多次 记住一句话，谁的表大就用谁的索引下面来考虑exists和in的性能 考虑如下SQL语句 1: select * from A where exists (select * from B where B.id = A.id); 2: select * from A where A.id in (select id from B); 查询1.可以转化以下伪代码，便于理解 for ($i = 0; $i &lt; count(A); $i++) { $a = get_record(A, $i); #从A表逐条获取记录 if (B.id = $a[id]) #如果子条件成立 $result[] = $a; } return $result; 大概就是这么个意思，其实可以看到,查询1主要是用到了B表的索引，A表如何对查询的效率影响应该不大 也就是说，表B越大就越能利用到索引的优势 而假设B表是小表的所有id为1,2,3,查询2可以转换为 select * from A where A.id = 1 or A.id = 2 or A.id = 3; 这个好理解了，这里主要是用到了A的索引，B表如何对查询影响不大 也就是说，表A越大就越能利用到索引的优势 下面再看not exists 和 not in 1. select * from A where not exists (select * from B where B.id = A.id); 2. select * from A where A.id not in (select id from B); 看查询1，还是和上面一样，用了B的索引 而对于查询2，可以转化成如下语句 select * from A where A.id != 1 and A.id != 2 and A.id != 3; 可以知道not in是个范围查询，这种!=的范围查询无法使用任何索引,等于说A表的每条记录，都要在B表里遍历一次，查看B表里是否存在这条记录 not in 和not exists如果查询语句 使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。 总结先大概说一下，这个子查询吧，其实，mysql还有很多的细节地方要注意，有时间再说说，自己的理解吧 补充一句，昨天和妹子出去吃饭，今天居然就感冒生病了，心疼啊/(ㄒoㄒ)/~~，怪我了","path":"2017/07/03/mysql/"},{"title":"关于linux中的grep用法","text":"今天要分享的内容是grep这个命令之前有一篇写了awk，那么grep的这个命令也就顺便研究一下 grep背景简介 grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。Unix的grep家族包 括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能 更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。 grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到屏幕，不影响原文件内容。 grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。 grep正则表达式元字符集（基本集）1234567891011121314151617181920212223242526272829303132333435363738394041424344^锚定行的开始 如：&apos;^grep&apos;匹配所有以grep开头的行。$锚定行的结束 如：&apos;grep$&apos;匹配所有以grep结尾的行。.匹配一个非换行符的字符 如：&apos;gr.p&apos;匹配gr后接一个任意字符，然后是p。*匹配零个或多个先前字符 如：&apos;*grep&apos;匹配所有一个或多个空格后紧跟grep的行。 .*一起用代表任意字符。[]匹配一个指定范围内的字符，如&apos;[Gg]rep&apos;匹配Grep和grep。[^]匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。\\(..\\)标记匹配字符，如&apos;\\(love\\)&apos;，love被标记为1。\\&lt;锚定单词的开始，如:&apos;\\&lt;grep&apos;匹配包含以grep开头的单词的行。\\&gt;锚定单词的结束，如&apos;grep\\&gt;&apos;匹配包含以grep结尾的单词的行。x\\&#123;m\\&#125;重复字符x，m次，如：&apos;0\\&#123;5\\&#125;&apos;匹配包含5个o的行。x\\&#123;m,\\&#125;重复字符x,至少m次，如：&apos;o\\&#123;5,\\&#125;&apos;匹配至少有5个o的行。x\\&#123;m,n\\&#125;重复字符x，至少m次，不多于n次，如：&apos;o\\&#123;5,10\\&#125;&apos;匹配5--10个o的行。\\w匹配文字和数字字符，也就是[A-Za-z0-9]，如：&apos;G\\w*p&apos;匹配以G后跟零个或多个文字或数字字符，然后是p。\\W\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。\\b单词锁定符，如: &apos;\\bgrep\\b&apos;只匹配grep。 用于egrep和 grep -E的元字符扩展集123456789101112131415161718192021222324252627282930+匹配一个或多个先前的字符。如：&apos;[a-z]+able&apos;，匹配一个或多个小写字母后跟able的串，如loveable,enable,disable等。?匹配零个或多个先前的字符。如：&apos;gr?p&apos;匹配g后跟一个r或没有字符，然后是p的行。a|b|c匹配a或b或c。如：grep|sed匹配grep或sed()分组符号，如：love(able|rs)ov+匹配loveable或lovers，匹配一个或多个ov。 \\(\\)：将一个或多个字符捆绑在一起，当作一个整体进行处理； # grep &quot;\\(xy\\)\\+&quot; grep.txt \\(xy\\)*abNote：分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：\\1,\\2,\\3,..... \\1：从左侧起，第一个左括号以及与之匹配右括号之间的模式所匹配到的字符； \\(ab\\+\\(xy\\)*\\)： \\1：ab\\+\\(xy\\)* \\2：xyx&#123;m&#125;,x&#123;m,&#125;,x&#123;m,n&#125;作用同x\\&#123;m\\&#125;,x\\&#123;m,\\&#125;,x\\&#123;m,n\\&#125; POSIX字符类为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是A-Za-z0-9的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。 123456789101112131415161718192021222324252627282930313233[:alnum:]文字数字字符[:alpha:]文字字符[:digit:]数字字符[:graph:]非空字符（非空格、控制字符）[:lower:]小写字符[:cntrl:]控制字符[:print:]非空字符（包括空格）[:punct:]标点符号[:space:]所有空白字符（新行，空格，制表符）[:upper:]大写字符[:xdigit:]十六进制数字（0-9，a-f，A-F） Grep命令选项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-?同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。-b，--byte-offset打印匹配行前面打印该行所在的偏移。-c,--count只打印匹配的行数，不显示匹配的内容，数量匹配了多少行。-f File，--file=File从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。-h，--no-filename当搜索多个文件时，不显示匹配文件名前缀。-i，--ignore-case忽略大小写差别。-q，--quiet取消显示，只返回退出状态。0则表示找到了匹配的行。-l，--files-with-matches打印匹配模板的文件清单。-L，--files-without-match打印不匹配模板的文件清单。-n，--line-number在匹配的行前面打印行号。-s，--silent不显示关于不存在或者无法读取文件的错误信息。-v，--revert-match反检索，只显示不匹配的行。-w，--word-regexp如果被\\&lt;和\\&gt;引用，就把表达式做为一个单词搜索。-V，--version显示软件版本信息。--color=auto：对匹配到的文本着色显示； -o：仅显示匹配到的字符串 -A #：after，显示匹配的后#行 -B #：before，显示匹配的前#行 -C #：context，前后各#行 -E：使用ERE，支持扩展的正则表达式 -s：不显示不存在或无匹配的错误信息 例子1234567891011121314151617要用好grep这个工具，其实就是要写好正则表达式，所以这里不对grep的所有功能进行实例讲解，只列几个例子，讲解一个正则表达式的写法。$ ls -l | grep &apos;^a&apos;通过管道过滤ls -l输出的内容，只显示以a开头的行。$ grep &apos;test&apos; d*显示所有以d开头的文件中包含test的行。$ grep &apos;test&apos; aa bb cc显示在aa，bb，cc文件中匹配test的行。$ grep &apos;[a-z]\\&#123;5\\&#125;&apos; aa显示所有包含每个字符串至少有5个连续小写字符的字符串的行。$ grep &apos;w\\(es\\)t.*\\1&apos; aa如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.*），这些字符后面紧跟着另外一个es（\\1），找到就显示该行。如果用egrep或grep -E，就不用&quot;\\&quot;号进行转义，直接写成&apos;w(es)t.*\\1&apos;就可以了。 总结grep确实很强大，同时，相对awk还是简单多了，无论是命令还是使用 毕竟只是单纯的去查找，而不做任何的修改内容上 awk函数多，又可以自己编程 多到底，grep还是考验对正则表达式的理解","path":"2017/06/29/linux-grep/"},{"title":"关于linux中的awk用法","text":"今天要分享的内容是awk这个命令因为要看日志，以前公司业务小的时候，能下载到本地用文本工具一个一个去找，但是现在不行了 面对hive大数据，根本行不通，没办法，不得不面对这个命令 先来了解一下awk背景知识awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)，如果没有指定模式，则所有被操作所指定的行都被处理。awk分别代表其作者姓氏的第一个字母。因为它的作者是三个人，分别是Alfred Aho、Brian Kernighan、Peter Weinberger。gawk是awk的GNU版本，它提供了Bell实验室和GNU的一些扩展。下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk。 语法和选项 1.语法 awk [options] &apos;script&apos; var=value file(s) awk [options] -f scriptfile var=value file(s) 命令选项 123456789101112131415161718192021222324252627282930313233343536373839-F fs or --field-separator fs指定输入分隔符，fs是一个字符串或者是一个正则表达式，如-F:。-v var=value or --asign var=value赋值一个用户定义变量。-f scripfile or --file scriptfile从脚本文件中读取awk命令。-mf nnn and -mr nnn对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。-W compact or --compat, -W traditional or --traditional在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。-W copyleft or --copyleft, -W copyright or --copyright打印简短的版权信息。-W help or --help, -W usage or --usage打印全部awk选项和每个选项的简短说明。-W lint or --lint打印不能向传统unix平台移植的结构的警告。-W lint-old or --lint-old打印关于不能向传统unix平台移植的结构的警告。-W posix打开兼容模式。但有以下限制，不识别：\\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。-W re-interval or --re-inerval允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。-W source program-text or --source program-text使用program-text作为源代码，可与-f命令混用。-W version or --version打印bug报告信息的版本。 模式和操作awk脚本是由模式和操作组成的： pattern {action} 如$ awk ‘/root/‘ test，或 $ awk ‘$3 &lt; 100’ test。 两者是可选的，如果没有模式，则action应用到全部记录，如果没有action，则输出匹配全部记录。 模式 模式可以是以下任意一个： /正则表达式/：使用通配符的扩展集。 关系表达式：可以用下面运算符表中的关系运算符进行操作，可以是字符串或数字的比较，如$2&gt;%1选择第二个字段比第一个字段长的行。 模式匹配表达式：用运算符~(匹配)和~!(不匹配)。 pattern语句块，模式：指定一个行的范围。该语法不能包括BEGIN和END模式。 BEGIN：让用户指定在第一条输入记录被处理之前所发生的动作，通常可在这里设置全局变量。 END：让用户在最后一条输入记录被读取之后发生的动作。 操作 操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内。主要有四部份： 变量或数组赋值 输出命令 内置函数 控制流命令 awk脚本基本结构awk &apos;BEGIN{ print &quot;start&quot; } pattern{ commands } END{ print &quot;end&quot; }&apos; file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如： pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 当使用不带参数的print时，它就打印当前行，当print的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用， 例如： echo | awk &apos;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; }&apos; v1 v2 v3 双引号拼接使用： echo | awk &apos;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; }&apos; v1=v2=v3 { }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i=0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。 awk的环境变量123456789101112131415161718192021222324变量 描述$n 当前记录的第n个字段，字段间由FS分隔。$0 完整的输入记录。ARGC 命令行参数的数目。ARGIND 命令行中当前文件的位置(从0开始算)。ARGV 包含命令行参数的数组。CONVFMT 数字转换格式(默认值为%.6g)ENVIRON 环境变量关联数组。ERRNO 最后一个系统错误的描述。FIELDWIDTHS 字段宽度列表(用空格键分隔)。FILENAME 当前文件名。FNR 同NR，但相对于当前文件。FS 字段分隔符(默认是任何空格)。IGNORECASE 如果为真，则进行忽略大小写的匹配。NF 当前记录中的字段数。NR 当前记录数。OFMT 数字的输出格式(默认值是%.6g)。OFS 输出字段分隔符(默认值是一个空格)。ORS 输出记录分隔符(默认值是一个换行符)。RLENGTH 由match函数所匹配的字符串的长度。RS 记录分隔符(默认是一个换行符)。RSTART 由match函数所匹配的字符串的第一个位置。SUBSEP 数组下标分隔符(默认值是\\034)。 awk运算符123456789101112131415运算符 描述= += -= *= /= %= ^= **= 赋值?: C条件表达式|| 逻辑或&amp;&amp; 逻辑与~ ~! 匹配正则表达式和不匹配正则表达式&lt; &lt;= &gt; &gt;= != == 关系运算符空格 连接+ - 加，减* / &amp; 乘，除与求余+ - ! 一元加，减和逻辑非^ *** 求幂++ -- 增加或减少，作为前缀或后缀$ 字段引用in 数组成员 熟悉一组专有名词 记录 awk把每一个以换行符结束的行称为一个记录。记录分隔符：默认的输入和输出的分隔符都是回车，保存在内建变量ORS和RS中。$0变量：它指的是整条记录。如$ awk ‘{print $0}’ test将输出test文件中的所有记录。变量NR：一个计数器，每处理完一条记录，NR的值就增加1。如$ awk ‘{print NR,$0}’ test将输出test文件中所有记录，并在记录前显示记录号。 域 记录中每个单词称做“域”，默认情况下以空格或tab分隔。awk可跟踪域的个数，并在内建变量NF中保存该值。如$ awk ‘{print $1,$3}’ test将打印test文件中第一和第三个以空格分开的列(域)。 域分隔符 内建变量FS保存输入域分隔符的值，默认是空格或tab。我们可以通过-F命令行选项修改FS的值。如$ awk -F: ‘{print $1,$5}’ test将打印以冒号为分隔符的第一，第五列的内容。可以同时使用多个域分隔符，这时应该把分隔符写成放到方括号中，如$awk -F’[:\\t]’ ‘{print $1,$3}’ test，表示以空格、冒号和tab作为分隔符。输出域的分隔符默认是一个空格，保存在OFS中。如$ awk -F: ‘{print $1,$5}’ test，$1和$5间的逗号就是OFS的值。 gawk专用正则表达式元字符123456789101112131415\\Y 匹配一个单词开头或者末尾的空字符串。\\B 匹配单词内的空字符串。\\&lt; 匹配一个单词的开头的空字符串，锚定开始。\\&gt;匹配一个单词的末尾的空字符串，锚定末尾。\\w匹配一个字母数字组成的单词。\\W匹配一个非字母数字组成的单词。\\‘匹配字符串开头的一个空字符串。\\&apos;匹配字符串末尾的一个空字符串。 匹配操作符(~) 用来在记录或者域内匹配正则表达式。如$ awk ‘$1 ~/^root/‘ test将显示test文件第一列中以root开头的行。 一组例子$ awk &apos;/^(no|so)/&apos; test-----打印所有以模式no或so开头的行。 $ awk &apos;/^[ns]/{print $1}&apos; test-----如果记录以n或s开头，就打印这个记录。 $ awk &apos;$1 ~/[0-9][0-9]$/(print $1}&apos; test-----如果第一个域以两个数字结束就打印这个记录。 $ awk &apos;$1 == 100 || $2 &lt; 50&apos; test-----如果第一个或等于100或者第二个域小于50，则打印该行。 $ awk &apos;$1 != 10&apos; test-----如果第一个域不等于10就打印该行。 $ awk &apos;/test/{print $1 + 10}&apos; test-----如果记录包含正则表达式test，则第一个域加10并打印出来。 $ awk &apos;{print ($1 &gt; 5 ? &quot;ok &quot;$1: &quot;error&quot;$1)}&apos; test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。 $ awk &apos;/^root/,/^mysql/&apos; test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。 数学函数函数名称 返回值 atan2(x,y) y,x范围内的余切 cos(x) 余弦函数 exp(x) 求幂 int(x) 取整 log(x) 自然对数 rand() 随机数 sin(x) 正弦 sqrt(x) 平方根 srand(x) x是rand()函数的种子 int(x) 取整，过程没有舍入 rand() 产生一个大于等于0而小于1的随机数 时间函数 函数名 说明 mktime( YYYY MM dd HH MM ss[ DST]) 生成时间格式 strftime([format [, timestamp]]) 格式化时间输出，将时间戳转为时间字符串 具体格式，见下表. systime() 得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 格式 描述 %a 星期几的缩写(Sun) %A 星期几的完整写法(Sunday) %b 月名的缩写(Oct) %B 月名的完整写法(October) %c 本地日期和时间 %d 十进制日期 %D 日期 08/20/99 %e 日期，如果只有一位会补上一个空格 %H 用十进制表示24小时格式的小时 %I 用十进制表示12小时格式的小时 %j 从1月1日起一年中的第几天 %m 十进制表示的月份 %M 十进制表示的分钟 %p 12小时表示法(AM/PM) %S 十进制表示的秒 %U 十进制表示的一年中的第几个星期(星期天作为一个星期的开始) %w 十进制表示的星期几(星期天是0) %W 十进制表示的一年中的第几个星期(星期一作为一个星期的开始) %x 重新设置本地日期(08/20/99) %X 重新设置本地时间(12：00：00) %y 两位数字表示的年(99) %Y 当前月份 %Z 时区(PDT) %% 百分号(%) $ awk &apos;{ now=strftime( &quot;%D&quot;, systime() ); print now }&apos; $ awk &apos;{ now=strftime(&quot;%m/%d/%y&quot;); print now }&apos; 字符串函数gsub( Ere, Repl, [ In ] ) 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 sub( Ere, Repl, [ In ] ) 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 index( String1, String2 ) 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 length [(String)] 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 blength [(String)] 返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 substr( String, M, [ N ] ) 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 match( String, Ere ) 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 split( String, A, [Ere] ) 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 tolower( String ) 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 toupper( String ) 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 sprintf(Format, Expr, Expr, . . . ) 如何把一行竖排的数据转换成横排？实用awk ‘{printf(“%s,”,$1)}’ filename 跟grep的区别是？ grep用于在文件中查找特定的内容 awk可以用来加工特定的信息，用于扩展和报表 sed是流shi的文本编辑处理，可以替换，增加，删除等操作 因此，awk和sed不仅可以用于查找，有自己的函数，可以完成，复杂的信息提取","path":"2017/06/29/linux-awk/"},{"title":"nginx入门系列二","text":"今天要分享的内容是还是nginx相关 Nginx 重写规则指南既然你看到这里，我想，不用问，你也肯定知道，nginx是运维要玩的东西，开发不直接管，那么 记住一句话：不懂程序的运维，不是好运维；不懂运维的开发，不是 好开发。 对于重写规则 说到底就是正则匹配，同时，如果想把 apache 转换成 nginx，重写规则也是要改的咯。 rewrite 模块介绍 nginx 的重写模块是一个简单的正则表达式匹配与一个虚拟堆叠机结合。依赖于 PCRE 库，因此需要安装 pcre。根 据相关变量重定向和选择不同的配置，从一个 location 跳转到另一个 location，不过这样的循环最多可以执行 10 次，超过后 nginx 将返回 500 错误。同时，重写模块包含 set 指令，来创建新的变量并设其值，这在有些情景 下非常有用的，如记录条件标识、传递参数到其他 location、记录做了什么等等。 rewrite 模块指令 break 语法：break 默认值：none 使用字段：server, location, if 完成当前设置的重写规则，停止执行其他的重写规则。 if 语法：if (condition) { … } 默认值：none 使用字段：server, location 注意：尽量考虑使用 trp_files 代替。 判断的条件可以有以下值： 1. 一个变量的名称：空字符传”“或者一些“0”开始的字符串为 false。 2. 字符串比较：使用=或!=运算符 3. 正则表达式匹配：使用~(区分大小写)和~*(不区分大小写)，取反运算!~和!~*。 4. 文件是否存在：使用-f 和!-f 操作符 5. 目录是否存在：使用-d 和!-d 操作符 7. 文件、目录、符号链接是否存在：使用-e 和!-e 操作符 8. 文件是否可执行：使用-x 和!-x 操作符 return 语法：return code 默认值：none 使用字段：server, location, if 停止处理并为客户端返回状态码。非标准的 444 状态码将关闭连接，不发送任何响应头。】 可以使用的状态码有： 204，400，402-406，408，410, 411, 413, 416 与 500-504。如果状态码附带文字段落，该文本将被放置在响应 主体。相反，如果状态码后面是一个 URL，该 URL 将成为 location 头补值。没有状态码的 URL 将被视为一个 302 状态码。 rewrite 语法：rewrite regex replacement flag 默认值：none 使用字段：server, location, if 按照相关的正则表达式与字符串修改 URI，指令按照在配置文件中出现的顺序执行。可以在重写指令后面添加标记。 注意：如果替换的字符串以 http://开头，请求将被重定向，并且不再执行多余的 rewrite 指令。 尾部的标记(flag)可以是以下的值： last – 停止处理重写模块指令，之后搜索 location 与更改后的 URI 匹配。 break – 完成重写指令。 redirect – 返回 302 临时重定向，如果替换字段用 http://开头则被使用。 permanent – 返回 301 永久重定向。 rewrite_log 语法：rewrite_log on | off 默认值：rewrite_log off 使用字段：server, location, if 变量：无 启用时将在 error log 中记录 notice 级别的重写日志。 set 语法：set variable value 默认值：none 使用字段：server, location, if 为给定的变量设置一个特定值。 uninitialized_variable_warn 语法：uninitialized_variable_warn on|off 默认值：uninitialized_variable_warn on 使用字段：http, server, location, if 控制是否记录未初始化变量的警告信息。 重写规则组成部分 任何重写规则的第一部分都是一个正则表达式 可以使用括号来捕获，后续可以根据位置来将其引用，位置变量值取决于捕获正则表达式中的顺序，$1 引用第一 个括号中的值，$2 引用第二个括号中的值，以此类推。如： ^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\\.(png|jpg|gif)$ $1 是两个小写字母组成的字符串，$2 是由小写字母和 0 到 9 的数字组成的 5 个字符的字符串，$3 将是个文件名，$4 是 png、jpg、gif 中的其中一个。 重写规则的第二部分是 URI请求被改写。该 URI 可能包含正则表达式中的捕获的位置参数或这个级别下的 nginx 任何配置变量。如：/data?file=$3.$4如果这个 URI 不匹配 nginx 配置的任何 location，那么将给客户端返回 301(永久重定向)或 302(临时重定向)的状 态码来表示重定向类型。该状态码可以通过第三个参数来明确指定。 重写规则的第三部分第三部分也就是尾部的标记(flag)。 last 标记将导致重写后的 URI 搜索匹配 nginx 的其他 location，最多可循 环 10 次。如： rewrite &apos;^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\\.(png|jpg|gif)$&apos; /data?file=$3.$4 last; break 指令可以当做自身指令。如： if ($bwhog) { limit_rate 300k; break; } 另一个停止重写模块处理指令是 return， 来控制主 HTTP 模块处理请求。 这意味着，nginx 直接返回信息给客户 端，与 error_page 结合为客户端呈现格式化的 HTML 页面或激活不同的模块来完成请求。如果状态码附带文字段 落，该文本将被放置在响应主体。相反，如果状态码后面是一个 URL，该 URL 将成为 location 头补值。没有状态 码的 URL 将被视为一个 302 状态码。如： location = /image404.html { return 404 &quot;image not found\\n&quot;; } 例子 12345678910111213141516171819202122232425262728293031323334http &#123;# 定义 image 日志格式log_format imagelog &apos;[$time_local] &apos; $image_file &apos; &apos; $image_type &apos; &apos; $body_bytes_sent &apos; &apos; $status;# 开启重写日志rewrite_log on;server &#123;root /home/www;location / &#123;# 重写规则信息error_log logs/rewrite.log notice;# 注意这里要用‘’单引号引起来，避免&#123;&#125;rewrite &apos;^/images/([a-z]&#123;2&#125;)/([a-z0-9]&#123;5&#125;)/(.*)\\.(png|jpg|gif)$&apos; /data?file=$3.$4;# 注意不能在上面这条规则后面加上“last”参数，否则下面的 set 指令不会执行set $image_file $3; set $image_type $4;&#125;location /data &#123;# 指定针对图片的日志格式，来分析图片类型和大小access_log logs/images.log mian; root /data/images;# 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最 后一个 url 里&#125; try_files /$arg_file /image404.html; location = /image404.html &#123;# 图片不存在返回特定的信息return 404 &quot;image not found\\n&quot;;&#125;&#125; nginx 逻辑运算nginx 的配置中不支持 if 条件的逻辑与&amp;&amp; 逻辑或|| 运算 ，而且不支持 if 的嵌套语法，否则会报下面的错误： nginx: [emerg] invalid condition。我们可以用变量的方式来间接实现。 要实现的语句： if ($arg_unitid = 42012 &amp;&amp; $uri ~/thumb/){ echo &quot;www.ttlsa.com&quot;; } 如果按照这样来配置，就会报 nginx: [emerg] invalid condition 错误。 可以这么来实现，如下所示： set $flag 0; if ($uri ~ ^/thumb/[0-9]+_160.jpg$){ set $flag &quot;${flag}1&quot;; } if ($arg_unitid = 42012){ set $flag &quot;${flag}1&quot;; } if ($flag = &quot;011&quot;){ echo &quot;www.ttlsa.com&quot;; } 隐藏 Nginx 版本号的安全性与方法 # vim nginx.conf 在 http {—}里加上 server_tokens off; 如： nginx 正向代理 我们平时用的最多的最常见的是反向代理。那么 nginx 的正向代理是如何配置的呢？ server { listen 8090; location / { resolver 218.85.157.99 218.85.152.99; resolver_timeout 30s; proxy_pass http://$host$request_uri; } access_log /data/httplogs/proxy-$host-aceess.log; } 就这么简单哈。 resolver 指令语法: resolver address … [valid=time]; 默认值: none配置段: http, server, location配置 DNS 服务器 IP 地址。可以指定多个，以轮询方式请求。nginx 会缓存解析的结果。默认情况下，缓存时间是名字解析响应中的 TTL 字段的值，可以通过 valid 参数更改。 resolver_timeout 指令语法: resolver_timeout time; 默认值: resolver_timeout 30s;配置段: http, server, location 解析超时时间。 nginx的最大好处，例子解释 由于公司内网有多台服务器的 http 服务要映射到公司外网静态 IP，如果用路由的端口映射来做，就只能一台内网 服务器的 80 端口映射到外网 80 端口，其他服务器的 80 端口只能映射到外网的非 80 端口。非 80 端口的映射在访问的时候要域名加上端口，比较麻烦。并且公司入口路由最多只能做 20 个端口映射。肯定以后不够用。然后 k 兄就提议可以在内网搭建个 nginx 反向代理服务器，将 nginx 反向代理服务器的 80 映射到外网 IP 的 80， 这样指向到公司外网 IP 的域名的 HTTP 请求就会发送到 nginx 反向代理服务器，利用 nginx 反向代理将不同域名 的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器 的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。 最后关于一些，高级的概念，还有第三方模块，这些内容就不属于入门级别的了 这两篇的意义，在于，你能初步，能看懂nginx的配置文件，每个配置的含义，以及初步的开发跳转，基本足够了 等后续，碰到这些高级的概念或者应用的时候，在去看 不是为了单纯的学习而学习。","path":"2017/06/29/nginx2/"},{"title":"nginx入门系列一","text":"今天要分享的内容是nginx的基本知识 先看一下conf文件解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# vi nginx.confuser nobody nobody; # 运行 nginx 的所属组和所有者worker_processes 2; # 开启两个 nginx 工作进程,一般几个 CPU 核心就写几 error_log logs/error.log notice; # 错误日志路径pid logs/nginx.pid; # pid 路径 events &#123; worker_connections 1024; # 一个进程能同时处理 1024 个请求 &#125;http &#123;include mime.types; default_type application/octet-stream;log_format main ‘$remote_addr – $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘‘”$http_user_agent” “$http_x_forwarded_for”‘; access_log logs/access.log main; # 默认访问日志路径 sendfile on;keepalive_timeout 65; # keepalive 超时时间# 开始配置一个域名,一个 server 配置段一般对应一个域名 server &#123; listen 80; # 在本机所有 ip 上监听 80,也可以写为 192.168.1.202:80,这样的话,就只监听 192.168.1.202 上的 80 口 server_name www.heytool.com; # 域名root /www/html/www.heytool.com; # 站点根目录（程序目录）index index.html index.htm; # 索引文件location / &#123; # 可以有多个 location root /www/html/www.heytool.com; # 站点根目录（程序目录） &#125; error_page 500 502 503 504 /50x.html;# 定义错误页面,如果是 500 错误,则把站点根目录下的 50x.html 返回给用户 location = /50x.html &#123; root /www/html/www.heytool.com; &#125;&#125;# 开始配置站点 bbs.heytool.com server &#123; listen 80; server_name bbs.heytool.com; root /www/html/bbs.heytool.com; index index.html index.htm; # 索引文件 location / &#123; root /www/html/bbs.heytool.com; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /www/html/bbs.heytool.com; &#125; &#125;&#125; nginx 启动，测试，关闭，重启# /usr/local/nginx-1.0.6/sbin/nginx //启动 nginx # /usr/local/nginx-1.0.6/sbin/nginx –t //测试 nginx 配置文件的准确性 # /usr/local/nginx-1.0.6/sbin/nginx –s reload //重载 nginx # /usr/local/nginx-1.0.6/sbin/nginx –s stop //关闭 nginx nginx 配置虚拟主机也就是我们通常说的配置域名. server_name：虚拟主机的域名，可以写多个域名，类似于别名，比如说你可以配置成 server_name b.ttlsa.com c.ttlsa.com d.ttlsa.com，这样的话，访问任何一个域名，内容都是一样的 listen 80，监听 ip 和端口，这边仅仅只有端口，表示当前服务器所有 ip 的 80 端口，如果只想监听 127.0.0.1 的 80，写法如下： listen 127.0.0.1:80 root /data/site/b.ttlsa.com：站点根目录，你网站文件存放的地方。注：站点目录和域名尽量一样，养成一个 好习惯 access_log /data/logs/nginx/b.ttlsa.com-access.log main：访问日志 location /{} nginx location 配置语法规则： location [=|~|~*|^~] /uri/ { … } = 表示精确匹配,这个优先级也是最高的 ^~ 表示 uri 以某个常规字符串开头，理解为匹配 url 路径即可。nginx 不对 url 做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa 匹配到（注意是空格）。 ~ 表示区分大小写的正则匹配 ~* 表示不区分大小写的正则匹配(和上面的唯一区别就是大小写) !~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则 / 通用匹配，任何请求都会匹配到，默认匹配. 多个 location 配置的情况下匹配顺序为： 首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止 匹配，按当前匹配规则处理请求。12345678910111213141516171819202122例子，有如下匹配规则： location / &#123; echo &quot;/&quot;; //需要安装 echo 模块才行,这边大家可以改成各自的规则 &#125;location = / &#123; echo &quot;=/&quot;; &#125;location = /nginx &#123; echo &quot;=/nginx&quot;; &#125;location ~ \\.(gif|jpg|png|js|css)$ &#123; echo &quot;small-gif/jpg/png&quot;; &#125;location ~* \\.png$ &#123; echo &quot;all-png&quot;; &#125;location ^~ /static/ &#123; echo &quot;static&quot;; &#125; 那么 http://a.ttlsa.com/，完全匹配=/ http://a.ttlsa.com/nginx,完全匹配了”=/nginx” http://a.ttlsa.com/xxx/1111.PNG （注意,这是大写），最后匹配到了~* .png$ http://a.ttlsa.com/static/1111.png,虽然 static 放在最后面,但是因为有^的缘故,他是最匹配的. nginx root&amp;alias 文件路径配置nginx 指定文件路径有两种方式 root 和 alias，root 与 alias 主要区别在于 nginx 如何解释 location 后面的 uri，这会使两者分别以不同的方式将请求映射到 服务器文件上。123456789101112131415161718192021例子一：location ~ ^/weblogs/ &#123;root /data/weblogs/www.ttlsa.com; autoindex on;auth_basic &quot;Restricted&quot;; auth_basic_user_file passwd/weblogs;&#125;如果一个请求的 URI 是/weblogs/httplogs/www.ttlsa.com-access.log 时，web 服务器将会返回服务器上的/data/weblogs/www.ttlsa.com/weblogs/httplogs/www.ttlsa.com-access.log 的文件。 [info]root 会根据完整的 URI 请求来映射，也就是/path/uri。[/info] 因此，前面的请求映射为 path/weblogs/httplogs/www.ttlsa.com-access.log。例子二：location ^~ /binapp/ &#123;limit_conn limit 4; limit_rate 200k; internal;alias /data/statics/bin/apps/;&#125;alias 会把 location 后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。如果一个请求的 URI 是/binapp/a.ttlsa.com/favicon 时，web 服务器将会返回服务器上的/data/statics/bin/apps/a.ttlsa.com/favicon.jgp 的文件。 [warning]1. 使用 alias 时，目录名后面一定要加”/”。2. alias 可以指定任何名称。3. alias 在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。4. alias 只能位于 location 块中。[/warning] 总结一下，就是，root相当于是根，特别之处根是在什么地方， 而alias是别号，也就是映射的那个路径，还可以是其他的别的地方，因此本身要去掉 nginx变量ngx_http_core_module 模块提供了大量的变量 参数名称 注释 $arg_PARAMETER HTTP 请求中某个参数的值，如/index.php?site=www.ttlsa.com，可以用$arg_site 取 得 www.ttlsa.com 这个值. $args HTTP 请求中的完整参数。例如，在请求/index.php?width=400&amp;height=200 中，$args 表示 字符串 width=400&amp;height=200. $binary_remote_addr 二进制格式的客户端地址。例如：\\x0A\\xE0B\\x0E $body_bytes_sent 表示在向客户端发送的 http 响应中，包体部分的字节数 $content_length 表示客户端请求头部中的 Content-Length 字段 $content_type 表示客户端请求头部中的 Content-Type 字段 $cookie_COOKIE 表示在客户端请求头部中的 cookie 字段 $document_root 表示当前请求所使用的 root 配置项的值 $uri 表示当前请求的 URI，不带任何参数 $document_uri 与$uri 含义相同 $request_uri 表示客户端发来的原始请求 URI，带完整的参数。$uri 和$document_uri 未必是用户的 原始请求，在内部重定向后可能是重定向后的 URI，而$request_uri 永远不会改变，始终是客户端的原始 URI. $host 表示客户端请求头部中的 Host 字段。如果 Host 字段不存在，则以实际处理的 server （虚拟主机）名称代替。如果 Host 字段中带有端口，如 IP:PORT，那么$host 是去掉端口的，它的值为 IP。$host 是全小写的。这些特性与 http_HEADER 中的 http_host 不同，http_host 只取出 Host 头部对应的值。 $hostname 表示 Nginx 所在机器的名称，与 gethostbyname 调用返回的值相同 $http_HEADER 表示当前 HTTP 请求中相应头部的值。HEADER 名称全小写。例如，示请求中 Host 头部 对应的值 用 $http_host 表 $sent_http_HEADER 表示返回客户端的 HTTP 响应中相应头部的值。HEADER 名称全小写。例如，用 $sent_ http_content_type 表示响应中 Content-Type 头部对应的值 $is_args 表示请求中的 URI 是否带参数，如果带参数，$is_args 值为 ?，如果不带参数，则是 空字符串 $limit_rate 表示当前连接的限速是多少，0 表示无限速 $nginx_version 表示当前 Nginx 的版本号 $query_string 请求 URI 中的参数，与 $args 相同，然而 $query_string 是只读的不会改变 $remote_addr 表示客户端的地址 $remote_port 表示客户端连接使用的端口 $remote_user 表示使用 Auth Basic Module 时定义的用户名 $request_filename 表示用户请求中的 URI 经过 root 或 alias 转换后的文件路径 $request_body 表示 HTTP 请求中的包体，该参数只在 proxy_pass 或 fastcgi_pass 中有意义 $request_body_file 表示 HTTP 请求中的包体存储的临时文件名 $request_completion 当请求已经全部完成时，其值为 “ok”。若没有完成，就要返回客户端，则其值为空字 符串；或者在断点续传等情况下使用 HTTP range 访问的并不是文件的最后一块，那么其值也是空字符串。 $request_method 表示 HTTP 请求的方法名，如 GET、PUT、POST 等 $scheme 表示 HTTP scheme，如在请求 https://nginx.com/中表示 https $server_addr 表示服务器地址 $server_name 表示服务器名称 $server_port 表示服务器端口 $server_protocol 表示服务器向客户端发送响应的协议，如 HTTP/1.1 或 HTTP/1.0 nginx 日志配置日志对于统计排错来说非常有利的。 日志格式通过 log_format 命令来定义。ngx_http_log_module 是用来定义请求日志格式的。 access_log语法: access_log path [format [buffer=size [flush=time]]];默认值: access_log logs/access.log combined; log_format 指令语法: log_format name string …;默认值: log_format combined “…”有一个默认的无需设置的 combined 日志格式，相当于 apache 的 combined 日志格式，如下所示： log_format combined &apos;$remote_addr - $remote_user [$time_local] &apos; &apos; &quot;$request&quot; $status $body_bytes_sent &apos; &apos; &quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;; log_format proxy &apos;$http_x_forwarded_for - $remote_user [$time_local] &apos; &apos; &quot;$request&quot; $status $body_bytes_sent &apos; &apos; &quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;; 日志格式变量 $remote_addr, $http_x_forwarded_for 记录客户端 IP 地址 $remote_user 记录客户端用户名称 $request 记录请求的 URL 和 HTTP 协议 $status 记录请求状态 $body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与 Apache 模块 mod_log_config 里的 “%B”参数兼容。 $bytes_sent 发送给客户端的总字节数。 $connection 连接的序列号。 $connection_requests 当前通过一个连接获得的请求数量。 $msec 日志写入时间。单位为秒，精度是毫秒。 $pipe 如果请求是通过 HTTP 流水线(pipelined)发送，pipe 值为“p”，否则为“.”。 $http_referer 记录从哪个页面链接访问过来的 $http_user_agent 记录客户端浏览器相关信息 $request_length 请求的长度（包括请求行，请求头和请求正文）。 $request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送 给客户端后进行日志写入为止。 $time_iso8601 ISO8601 标准格式下的本地时间。 $time_local 通用日志格式下的本地时间。 open_log_file_cache 指令 语法: open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time]; open_log_file_cache off;默认值: open_log_file_cache off;配置段: http, server, location对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用 open_log_file_cache 来设置日志 文件缓存(默认是 off)，格式如下：参数注释如下：max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用 LRU 算法将描述符关闭。 inactive:设置存活时间，默认是 10smin_uses:设置在 inactive 时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是 1 次 valid:设置检查频率，默认 60soff：禁用缓存 实例如下： open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2; log_not_found 指令 语法: log_not_found on | off; 默认值: log_not_found on; 配置段: http, server, location 是否在 error_log 中记录不存在的错误。默认是。 log_subrequest 指令 语法: log_subrequest on | off;默认值: log_subrequest off;配置段: http, server, location是否在 access_log 中记录子请求的访问日志。默认不记录。 rewrite_log 指令 由 ngx_http_rewrite_module 模块提供的。用来记录重写日志的。对于调试重写规则建议开启。 Nginx 重写规则 指南语法: rewrite_log on | off; 默认值: rewrite_log off;配置段: http, server, location, if启用时将在 error log 中记录 notice 级别的重写日志。 error_log 指令 语法: error_log file | stderr | syslog:server=address[,parameter=value] [debug | info | notice | warn | error | crit | alert | emerg];默认值: error_log logs/error.log error;配置段: main, http, server,location 配置错误日志。","path":"2017/06/28/nginx/"},{"title":"java中string的不可不知的编码知识","text":"今天要分享的内容是java的string的字符串编码 首先记住一句话，字符串在 java 内存中总是按 unicode 编码存储的先看一个测试用例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author hankun * @create 2017-06-27 14:24 */public class unicode &#123; /** * 字符串转换unicode */ public static String string2Unicode(String string) &#123; StringBuffer unicode = new StringBuffer(); for (int i = 0; i &lt; string.length(); i++) &#123; // 取出每一个字符 char c = string.charAt(i); // 转换为unicode unicode.append(&quot;\\\\u&quot; + Integer.toHexString(c)); &#125; return unicode.toString(); &#125; /** * unicode 转字符串 */ public static String unicode2String(String unicode) &#123; StringBuffer string = new StringBuffer(); String[] hex = unicode.split(&quot;\\\\\\\\u&quot;); for (int i = 1; i &lt; hex.length; i++) &#123; // 转换出每一个代码点 int data = Integer.parseInt(hex[i], 16); // 追加成string string.append((char) data); &#125; return string.toString(); &#125; /** * 测试字符串长度 */ public static void stringLength(String string) &#123; System.out.println(&quot;String is = &quot; + string+&quot; ,default length = &quot;+ string.length()); System.out.println(&quot;String is = &quot; + string+&quot; ,getBytes length = &quot;+ string.getBytes().length); System.out.println(&quot;String 中包含 &quot; + (string.getBytes().length-string.length())+&quot; 个中文&quot;); &#125; public static void main(String[] args) &#123; String test = &quot;中文ab&quot;; String unicode = string2Unicode(test); String string = unicode2String(unicode) ; System.out.println(unicode); System.out.println(string); String test1 = &quot;中文&quot;; String test2 = &quot;ab&quot;; stringLength(test); stringLength(test1); stringLength(test2); &#125;&#125; 上面这个例子里面，还提供了一个，快速判断，字符串中，包含的中文个数方法 解释首先，Java中的一个char是2个字节。java采用unicode，2个字节来表示一个字符，这点与C语言中不同，c语言中采用ASCII，在大多数系统中，一个char通常占1个字节，但是在0~127整数之间的字符映射，unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节，但如果采用其他编码方式，一个字符占用的字节数则各不相同。 在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。 我的系统的默认编码方式为GBK，因此对于字符串 “中文ab”， 如果调用length（）方法返回其长度，得到的结果将为：4。该方法返回的是字符串的字符数，无论是中文字符还是英文字符，都被看做是一个字符。 如果将其转换为byte数组，而后返回byte数组的长度，得到的结果将为：6。因为在GBK编码中，中文占2个字节，而英文字符占1个字节。 科普 字符：人们使用的记号，抽象意义上的一个符号。比如：‘1’,‘中’,‘a’ 字节：计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间 字符集：使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。 编码：规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码” 平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。 iso8859－1属于单字节编码，最多能表示的字符范围是 0-255，应用于英文系列。比如，字母 ‘a’ 的编码为0x61=97。 很明显，iso8859-1 编码表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用 iso8859-1 编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在 iso8859-1 编码，以 gb2312 编码为例，应该是”d6d0 cec4” 两个字符，使用 iso8859-1 编码的时候则将它拆开为 4 个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是 UTF 编码，则是 6 个字节 “e4 b8 ad e6 96 87”。很明显，这种表示方法还需要以另一种编码为基础。（unicode） GB2312/GBK这是汉字的国标码，专门用来表示汉字，是双字节编码，而英文字母和 iso8859-1 一致（兼容iso8859-1 编码）。其中 gbk 编码能够用来同时表示繁体字和简体字，而 gb2312 只能表示简体字，gbk是兼容gb2312 编码的。 Unicode这是最统一的编码，可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容 iso8859-1 编码的，也不兼容任何编码。不过，相对于iso8859-1 编码来说，unicode 编码只是在前面增加了一个 0 字节，比如字母 ‘a’ 为 “00 61”。 需要说明的是，定长编码便于计算机处理（注意 GB2312/GBK 不是定长编码），而 unicode 又可以用来表示所有字符，所以在很多软件内部是使用 unicode 编码来处理的，比如 java。 UTF考虑到 unicode 编码不兼容 iso8859-1 编码，而且容易占用更多的空间：因为对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便于传输和存储。因此而产生了 utf 编码，utf 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符，不过，utf 编码是不定长编码，每一个字符的长度从1-6个字节不等。另外，utf 编码自带简单的校验功能。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节。注意，虽然说utf是为了使用更少的空间而使用的，但那只是相对于 unicode编码来说，如果已经知道是汉字，则使用 GB2312/GBK 无疑是最节省的。不过另一方面，值得说明的是，虽然 utf 编码对汉字使用3个字节，但即使对于汉字网页，utf 编码也会比 unicode 编码节省，因为网页中包含了很多的英文字符。 getBytes(charset)这是 java 字符串处理的一个标准函数，其作用是将字符串所表示的字符按照 charset 编码，并以字节方式表示。 注意字符串在 java 内存中总是按 unicode 编码存储的。 当Java程序从输入流、文件或字符文字量等途径获得字符串时，均会做字符编码的转换，例如InputStreamReader 的构造函数中就需要指定编码方式，而对于从文件和字符文字量中获得字符串时，均采用系统默认的编码方式对字符数据进行解码。 考虑下面一段代码： String str=”中”; ① byte[] bytes = str.getBytes(); ② bytes = str.getBytes(“ISO-8859-1”); 语句①：将一个只含有一个字符“中”的字符串文字量赋给 String 类的一个对象 str，字符文字量“中”是按照操作系统默认编码方式进行编码，在中文 windows 系统中通常是“GBK”，“中”在GBK编码中是0xD6D0，在将该字符赋给str时，Java会对该字符串进行编码转换，即将GBK编码方式的“中”转换成Unicode编码方式的“中”，Unicode编码方式“中”的编码是0x4E2D，所以str在程序运行期间在内存中的二进制表示成16进制就是0x4E2D。 语句②：获得str字符串的二进制形式。getBytes(String encoding)方法需要指定编码方式，表示获得该字符串在何种编码方式中的二进制形式。此语句中没有设置参数，表示采用操作系统默认的编码方式，即此处获得的bytes是“中”在GBK编码中的二进制形式，即bytes[0]=0xD6, bytes[1]=0xD0。 语句③：该语句与语句②的区别就是指定了编码方式，此处指定的是ISO-8859-1，即通常所说的Latin-1，该编码采用8bit对字符编码，所以编码空间中只有256个字符。该编码中只包含了基本的ASCII码和一些扩展的其它西欧字符，所以该字符集中不可能包含中文的“中”字，也就是说Java虚拟机无法在ISO-8859-1编码集中找到“中”字对应的编码，针对这种情况，就只返回一个问号(?,0x3f)字符，所以此时bytes.length只有1，且bytes[0]=0x3f。 new String(byte[] bytes, String encoding)getBytes()方法从字符串获得二进制的字节数组。如果要从二进制的字节数组获得字符串，则就需要使用new String(byte[] bytes, String encoding)方法，该方法按照encoding编码方法对字节数组bytes中的二进制数组进行解析，生成一个新的字符串对象。 byte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31}; ① String str = new String(bytes); ② str = new String(bytes,”ISO-8859-1”); 语句①：定义一个字节数组。 语句②：将该字节数组中的二进制数据按照默认的编码方式（GBK）编码成字符串，我们知道GBK中0xD6 0xD0表示“中”，0x31表示字符“1”（GBK兼容ASCII，但不兼容ISO-8859-1除ASCII之外的部分），所以str得到的值是“中1”。 语句③：该句用ISO-8859-1编码方式对该字节数据进行编码，由于在ISO-8859-1编码方式中一个字节会被解析成一个字符，所以该字节数组会被解释成包含三个字符的字符串，但由于在ISO-8859-1编码方式中没有对应0xD6和0xD0的字符，所以前两个字符会产生两个问号，由于0x31在ISO-8859-1编码中对应字符“1”（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。 最后我相信看了，上面这么些背景知识，是不是以前，不清楚的东西，都有写明白了？多看几次，就更能理解了","path":"2017/06/27/java-encode/"},{"title":"java中String的getBytes的用法","text":"今天要分享的内容是java的string方法getBytes 先看一个测试用例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.UnsupportedEncodingException;/** * @author hankun * @create 2017-06-26 20:28 */public class testGetBytes &#123; /** * * 1、Unicode是一种编码规范，是为解决全球字符通用编码而设计的，而rUTF-8,UTF-16等是这种规范的一种实现。 2、java内部采用Unicode编码规范，也就是支持多语言的，具体采用的UTF-16编码方式。 3、不管程序过程中用到了gbk,iso8859-1等格式，在存储与传递的过程中实际传递的都是Unicode编码的数据，要想接收到的值不出现乱码，就要保证传过去的时候用的是A编码，接收的时候也用A编码来转换接收。 4、如果双方的file.encoding确保都相同，那就省事了，都默认转了，但往往在不同项目交互时很多时候是不一致的，这个时候是必须要进行编码转换的。 5、无论如论转换，java程序的数据都是要先和Unicode做转换，这样也就是能处理多语言字符集的原因了。底层保持了一致，只要在传值和接值的时候也一致就肯定不会出现乱码了。 * */ public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = &quot;中文字符&quot;; System.out.println(&quot;original string---&quot; + str);// 会正常输出原始串 /** * * str.getBytes(); 如果括号中不写charset，则采用的是Sytem.getProperty(&quot;file.encoding&quot;),即当前文件的编码方式， * * 很多人写的是系统的默认编码，通过代码测试并非如此，实际得到的是文件的编码方式* * * str.getBytes(&quot;charset&quot;);//指定charset，即将底层存储的Unicode码解析为charset编码格式的字节数组方式 * * String new_str=new String(str.getBytes(&quot;utf-8&quot;),&quot;gbk&quot;)); * * //将已经解析出来的字节数据转化为gbk编码格式的字符串，在内存中即为gbk格式的字节数组转为Unicode去交互传递 */ String new_str = new String(str.getBytes(&quot;utf-8&quot;), &quot;gbk&quot;); /** * * 此时的输出是乱码，在UTF-8的file.encoding下输出gbk格式的数据肯定是乱码,但是new_str的确是gbk编码式的 * * 此时的乱码源于encoding不符，但gbk格式的new_str本身数据并没有问题,通过下面的转换也可以看得出来 */ System.out.println(&quot;new string----&quot; + new_str); String final_str = new String(new_str.getBytes(&quot;gbk&quot;), &quot;utf-8&quot;);// 此处的含意与最上边的注释是一致的参数含意 /** * *输出是正常的，此时将gbk编码格式的new_str字符串，用gbk这个charset去解析它，然后用utf-8再转码一次， * * 因为new_str确实是gbk格式的，才能经过utf-8编码得到正常的数据显示。 */ System.out.println(&quot;final string---&quot; + final_str); &#125;&#125;&#125; 正常说明，要干什么，再加一个链接按钮 xxx. 简单总结1. 首先，你要明白，什么是uinicode，她和utf-8，以及utf-16，是什么关系 2. 其实，你要知道，java中是用了，utf-16 3. 再深入一点，就是，你也必须知道byte这个类型，就是所谓的字节数组了 4. 他和int的区别，怎么转换 5. byte数组里面存储的内容，怎么转换成对应的中文字符的？什么编码映射关系，转过去的？ 6. 还有就是，你会经常看到0xff，这种，还有&amp;，按位于的这种操作，具体是什么含义 7. 大小端的问题，是什么意思？在网络里面如何区分？ 这个地方，之前其实就一直看过，每次看完一遍，以为真的懂了，但是，过后，还是不知道，啥原理 这次，写过了，可能过一段时间又忘记了，但是，如果真正的理解了原理的话，就难忘记了 这个地方，不管前后端，都必须掌握 去看ruan大神的，那片，unicode文章，绝对有收获。","path":"2017/06/26/java-getBytes/"},{"title":"关于Java中的ThreadLocal用法","text":"今天要分享的内容是java中的ThreadLocal并发编程中，一个重要的内容是数据共享。当你创建了实现Runnable接口的线程，然后开启使用相同Runnable实例的各种Thread对象，所有 的线程便共享定义在Runnable对象中的属性。也就是说，当你在一个线程中改变任意属性时，所有的线程都会因此受到影响，同时会看到第一个线程修改后的值。有时我们希望如此，比如：多个线程增大或减小同一个计数器变量；但是，有时我们希望确保每个线程，只能工作在它自己的线程实例的拷贝上，同时不会影 响其他线程的数据。 ThreadLocal是什么 ThreadLocal是一个关于创建线程局部变量的类。 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。 Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。 在当前线程中，任何一个点都可以访问到ThreadLocal的值。 该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。 如何创建ThreadLocal变量private ThreadLocal myThreadLocal = new ThreadLocal(); 通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。 用法简介 创建，支持泛型 ThreadLocal mStringThreadLocal = new ThreadLocal&lt;&gt;(); set方法 mStringThreadLocal.set(“hank”); get方法 mStringThreadLocal.get(); initialValue()：返回当前线程赋予局部线程变量的初始值。具体用例 1234567891011121314151617181920212223242526272829/** * @author hankun * @create 2017-06-20 20:33 */public class threadlocal &#123; public static class MyRunnable implements Runnable &#123; private ThreadLocal threadLocal = new ThreadLocal(); @Override public void run() &#123; threadLocal.set((int) (Math.random() * 100D)); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(Thread.currentThread().getName() + &quot; == &quot; + threadLocal.get()); &#125; &#125; public static void main(String[] args) &#123; MyRunnable my = new MyRunnable(); Thread thread1 = new Thread(my); Thread thread2 = new Thread(my); thread1.start(); thread2.start(); &#125;&#125; 关于InheritableThreadLocalInheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。 【注：所有子线程都会继承父线程保存的ThreadLocal值】 总结局部线程通常使用在这样的情况下，当你有一些对象并不满足线程安全，但是你想避免在使用synchronized关键字、块时产生的同步访问，那么，让每个线程拥有它自己的对象实例。 注意：局部变量是同步或局部线程的一个好的替代，它总是能够保证线程安全。唯一可能限制你这样做的是你的应用设计约束。 这个地方，是因为看到项目中有些地方都有用到，所以自己也研究一下 单从用法而言，还是比较简单的，没啥难度，要是研究原理的问题的话，可以考虑深入看一下源代码 还有就是 思考一下这种方式，变量对象，是放在堆里面吗？还是堆里面？ 答案是堆。","path":"2017/06/20/java-threadlocal/"},{"title":"关于requirejs的用法","text":"今天要分享的内容是requirejs AMD 简介 前端开发在近一两年发展的非常快，JavaScript 作为主流的开发语言得到了前所未有的热捧。大量的前端框架出现了，这些框架都在尝试着解决一些前端开发中的共性问题，但是实现又不尽相同。在这个背景下，CommonJS 社区诞生了，为了让前端框架发展的更加成熟，CommonJS 鼓励开发人员一起在社区里为一些完成特定功能的框架制定规范。AMD（Asynchronous Module Definition）就是其中的一个规范。 RequireJS 简介 RequireJS 是一个非常小巧的 JavaScript 模块载入框架，是 AMD 规范最好的实现者之一。最新版本的 RequireJS 压缩后只有 14K，堪称非常轻量。它还同时可以和其他的框架协同工作，使用 RequireJS 必将使您的前端代码质量得以提升。 目前最新版本的 RequireJS 1.0.8 在 IE 6+、Firefox 2+、Safari 3.2+、Chrome 3+、Opera 10+ 上都工作的很好。 案例一： 加载 JavaScript 文件&lt;script src=&quot;./js/require.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;./js/a.js&quot;, &quot;./js/b.js&quot;], function() { myFunctionA(); myFunctionB(); }); &lt;/script&gt; 这种方式，用来加载以前的js文件，就像本地引用一样，但是没有解决全局变量的问题 案例二： 页面加载后执行 JavaScript require([“domReady!”, “./js/a.js”, “./js/b.js”], function() { myFunctionA(); myFunctionB(); }); 这个例子domReady!，解决了，有需要保证页面加载以后执行脚本时，RequireJS 提供了一个独立的 domReady 模块，需要去 RequireJS 官方网站下载这个模块 AMD模块的写法 require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。 具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写： // math.js define(function (){ var add = function (x,y){ return x+y; }; return { add: add }; }); 加载方法如下： // main.js require([&apos;math&apos;], function (math){ alert(math.add(1,1)); }); 加载非规范的模块 理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？ 回答是可以的。 这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。 举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。 require.config({ shim: { &apos;underscore&apos;:{ exports: &apos;_&apos; }, &apos;backbone&apos;: { deps: [&apos;underscore&apos;, &apos;jquery&apos;], exports: &apos;Backbone&apos; } } }); require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。 比如，jQuery的插件可以这样定义： shim: { &apos;jquery.scroll&apos;: { deps: [&apos;jquery&apos;], exports: &apos;jQuery.fn.scroll&apos; } } require.js插件 require.js还提供一系列插件，实现一些特定的功能。 domready插件，可以让回调函数在页面DOM结构加载完成后再运行。 require([‘domready!’], function (doc){ // called once the DOM is ready }); text和image插件，则是允许require.js加载文本和图片文件。 define([ ‘text!review.txt’, ‘image!cat.jpg’ ], function(review,cat){ console.log(review); document.body.appendChild(cat); } ); 类似的插件还有json和mdown，用于加载json文件和markdown文件。 在html中引入requirejs 在HTML中，添加这样的 &lt; script&gt; 标签： &lt;script src=&quot;/path/to/require.js&quot; data-main=&quot;/path/to/app/config.js&quot;&gt;&lt;/script&gt; 通常使用requirejs的话，我们只需要导入requirejs即可，不需要显式导入其它的js库，因为这个工作会交给requirejs来做。 属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块。 依赖一个不使用requirejs方式的库 前面的代码是理想的情况，即依赖的js文件，里面用了 define(…) 这样的方式来组织代码的。如果没用这种方式，会出现什么情况？ 比如这个 hello.js : function hello() { alert(&quot;hello, world~&quot;); } 它就按最普通的方式定义了一个函数，我们能在requirejs里使用它吗？ 先看下面不能正确工作的代码： requirejs.config({ baseUrl: &apos;/public/js&apos;, paths: { hello: &apos;hello&apos; } }); requirejs([&apos;hello&apos;], function(hello) { hello(); }); 这段代码会报错，提示： Uncaught TypeError: undefined is not a function 原因是最后调用 hello() 的时候，这个 hello 是个 undefined . 这说明，虽然我们依赖了一个js库（它会被载入），但requirejs无法从中拿到代表它的对象注入进来供我们使用。 在这种情况下，我们要使用 shim ，将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。 requirejs.config({ baseUrl: &apos;/public/js&apos;, paths: { hello: &apos;hello&apos; }, shim: { hello: { exports: &apos;hello&apos; } } }); requirejs([&apos;hello&apos;], function(hello) { hello(); }); 再运行就正常了。 上面代码 exports: ‘hello’ 中的 hello ，是我们在 hello.js 中定义的 hello 函数。当我们使用 function hello() {} 的方式定义一个函数的时候，它就是全局可用的。如果我们选择了把它 export 给requirejs，那当我们的代码依赖于 hello 模块的时候，就可以拿到这个 hello 函数的引用了。 所以： exports 可以把某个非requirejs方式的代码中的某一个全局变量暴露出去，当作该模块以引用。 无主的与有主的模块 我遇到了一个折腾我不少时间的问题：为什么我只能使用 jquery 来依赖jquery, 而不能用其它的名字？ 比如下面这段代码： requirejs.config({ baseUrl: &apos;/public/js&apos;, paths: { myjquery: &apos;lib/jquery/jquery&apos; } }); requirejs([&apos;myjquery&apos;], function(jq) { alert(jq); }); 它会提示我： jq is undefined 但我仅仅改个名字： requirejs.config({ baseUrl: &apos;/public/js&apos;, paths: { jquery: &apos;lib/jquery/jquery&apos; } }); requirejs([&apos;jquery&apos;], function(jq) { alert(jq); }); 就一切正常了，能打印出 jq 相应的对象了。 为什么？我始终没搞清楚问题在哪儿。 有主的模块 经常研究，发现原来在jquery中已经定义了： define(&apos;jquery&apos;, [], function() { ... }); 它这里的 define 跟我们前面看到的 app.js 不同，在于它多了第一个参数 ‘jquery’ ，表示给当前这个模块起了名字 jquery ，它已经是有主的了，只能属于 jquery . 所以当我们使用另一个名字： myjquery: ‘lib/jquery/jquery’ 去引用这个库的时候，它会发现，在 jquery.js 里声明的模块名 jquery 与我自己使用的模块名 myjquery 冲突，便不会把它赋给 myjquery ，所以 myjquery 的值是 undefined 。 所以我们在使用一个第三方的时候，一定要注意它是否声明了一个确定的模块名。 无主的模块 如果我们不指明模块名，就像这样： define([...], function() { ... }); 那么它就是无主的模块。我们可以在 requirejs.config 里，使用任意一个模块名来引用它。这样的话，就让我们的命名非常自由，大部分的模块就是无主的。 为什么有的有主，有的无主 可以看到，无主的模块使用起来非常自由，为什么某些库（jquery, underscore）要把自己声明为有主的呢？ 按某些说法，这么做是出于性能的考虑。因为像 jquery , underscore 这样的基础库，经常被其它的库依赖。如果声明为无主的，那么其它的库很可能起不同的模块名，这样当我们使用它们时，就可能会多次载入jquery/underscore。 而把它们声明为有主的，那么所有的模块只能使用同一个名字引用它们，这样系统就只会载入它们一次。 强行该名称的方法 对于有主的模块，我们还有一种方式可以挖墙角：不把它们当作满足requirejs规范的模块，而当作普通js库，然后在 shim 中导出它们定义的全局变量。 requirejs.config({ baseUrl: &apos;/public/js&apos;, paths: { myjquery: &apos;lib/jquery/jquery&apos; }, shim: { myjquery: { exports: &apos;jQuery&apos; } } }); requirejs([&apos;myjquery&apos;], function(jq) { alert(jq); }); 这样通过暴露 jQuery 这个全局变量给 myjquery ，我们就能正常的使用它了。 不过我们完全没有必要这么挖墙角，因为对于我们来说，似乎没有任何好处。 总结 关于这块部分，我是看项目里有用到这个前端的组件，而自己没有实际开发过，因此 对这个部分，理解不深刻，也就是现在能看懂的阶段了，主要是参考了好几篇关于 requirejs的文章总结的 还有就是，这个部分其实一直就有了解，因此也不是完全不懂的去学 反正是先入手学一下是很有必要的， 哎，最近发现那个requirejs的中文网，不知道怎么滴就访问不了，好像只能去看英文文档了","path":"2017/06/19/requirejs/"},{"title":"gitbook的自己定制的写书模板","text":"今天要分享的内容是gitbook的使用今天本来在看js的commonJs，amd，cmd，umd这些模块内容 看着，看着，突然看到了gitbook的内容 发现很多人，都用这个，写一个类似，api或者一些列的书籍用 所以下午花时间，开始弄这个 开始也是啥不懂，慢慢总算摸清门路了 其实还是不会用 本来去掉了让人讨厌的，最下面的那个published with gitbook那个连接 结果和github同步了一次代码，全部丢失了 后来实在，是不想弄了，就留着吧，懒得弄啦 最后的解决方案就是 用gitbook的那个编辑器，直接写文章将来 或者像这个博客一样，全部用markdown的语法，自己写 显得的高大上 去我的github上面，可以找一下，gitbook的写作模板 顺便把首页的测试页链接，改为自己的书籍，将来补充一下，争取写成一个书单，或者笔记之类的东西吧 美少女で 閲覧数を取れなきゃ 幼女を出せ by ぎぇうす on pixiv","path":"2017/06/15/gitbook/"},{"title":"汤姆大叔的深入理解JavaScript读后感四（完结篇）","text":"今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇花了三天的时间，终于把大叔的博客，JavaScript系列看了一遍 收获颇丰啊，不愧是经典，一下子很多零散的东西就串联了起来 先简单说一下背景吧大概是13年左右的时候，就有人推荐大叔的博客，那时第一个原因是水平不够，第二个没时间，总之就是没看过，但是听说过了 后来，陆续又自己完完整整的学了一遍JavaScript，就是大叔最后一篇文章里面推荐的，初级书籍，那边三圣经之一，看完了总觉得学会了，其实看完就忘记了，不过有个大概印象了 再后来，毕业工作了，去做java后端了，因为有时候需要写简单的前端页面，就开始到了真正的实际应用，开始写的过程，才慢慢对一些概念，有了自己的认识但是，还是停留在最初级的阶段，写个function函数，那种，变量都是全局的，简单的子自行，this分不清的水平 慢慢的，有个机会让我去定制前端组件，那个时候，自己开始模仿的写一些组件，但是都是初级的，不过正是因为这个原因，才有了一次写js的锻炼，有了这种训练以前很多的概念开始，慢慢用上了 大概自认为，初级JavaScript之上，又达不到中级的水平吧， 大叔的系列，看完一遍，对我来说的收获 弄清了function函数这个概念，实在太多了，比如，命名，申明，函数语句，匿名，自执行，等等 弄清了括号的用法和含义，（），这个东西，看着简单，不懂的话，还是不理解 弄清了闭包这个概念，这个概念每次问，都知道有那么回事，但是又具体说不上来，那种一直认为懂，其实还是不懂的概念，这篇文章终于弄清楚了 弄清了prototype这个玩意，就是所谓的原型的概念，只有函数才有 弄清了对象创建的方法，比如，function的，还有new，含有构造函数，等等 弄清了执行上下文，也就是作用域的概念，这个东西，没有比大叔写的更清楚的了 还有就是，有了上面的概念之后的，this指针，老生常谈了，网上的其他文章，只能写一些为啥，例子分析之类的，开始写不错，大叔这种原理分析，各个场景的用法，这次就不怕分不清this了 当然了，还有，call，apply这些的用法 当然了，又温故知新了一遍设计模式，主要是理解了代码为啥有时候那么写的思路 有了上面总总的概念之后，看起完整的代码，才不会卡主分析里面任何一个细节因为基础知识已经具备了，看起来，才能理解了 说了这么多，其实呢，这个东西，不实践还是没有用的，如果没有当初自己一个人开始写js的那段实践，我估计也不会有今天看博客那么大的收获 不敢说，都看懂了大叔所写，但是我心中的疑惑对js的，那些模糊的概念突然清晰了起来 书不是读一遍，就完事的，等以后有时间，再返回头看看，可能有更多的收获 上图 まとめ by 郁 on pixiv","path":"2017/06/14/tomdashu4/"},{"title":"汤姆大叔的深入理解JavaScript读后感三（设计模式篇）","text":"今天要分享的内容是tom大叔的JavaScript系列的读书观后感3挑选大叔里面，个人自己喜欢的设计模式实现 第二十五部分，设计模式之单例模式在传统开发工程师眼里，单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。 123456789101112131415161718192021function Universe() &#123; // 缓存的实例 var instance = this; // 其它内容 this.start_time = 0; this.bang = &quot;Big&quot;; // 重写构造函数 Universe = function () &#123; return instance; &#125;;&#125;// 测试var uni = new Universe();var uni2 = new Universe();uni.bang = &quot;123&quot;;console.log(uni === uni2); // trueconsole.log(uni2.bang); // 123 这个设计模式，简单明了，通过this进行缓存，剩下了去判断不存在的麻烦 第二十六部分，设计模式之构造函数模式构造函数用于创建特定类型的对象——不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。12345678910111213141516171819function Car(model, year, miles) &#123; this.model = model; this.year = year; this.miles = miles;&#125;/*注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype主要是用来避免重写定义原型prototype对象*/Car.prototype.output= function () &#123; return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;&#125;;var tom = new Car(&quot;大叔&quot;, 2009, 20000);var dudu = new Car(&quot;Dudu&quot;, 2010, 5000);console.log(tom.output());console.log(dudu.output()); 第二十七部分，设计模式之建造者模式建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。1234567891011121314151617function getBeerById(id, callback) &#123; // 使用ID来请求数据，然后返回数据. asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function (resp) &#123; // callback调用 response callback(resp.responseText); &#125;);&#125;var el = document.querySelector(&apos;#test&apos;);el.addEventListener(&apos;click&apos;, getBeerByIdBridge, false);function getBeerByIdBridge(e) &#123; getBeerById(this.id, function (beer) &#123; console.log(&apos;Requested Beer: &apos; + beer); &#125;);&#125; 建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。也就是说，上面的函数中，getBeerById函数是稳定的，写了一个构建过程，而具体的构建细节由另外一个回调函数决定 其实，我觉得，这个部分，不属于java里面的建造者模式，更是一种模板模式，可能个人理解不同吧，反正大叔的意思，就是这种样子 第二十八部分，设计模式之工厂模式什么时候使用工厂模式 以下几种情景下工厂模式特别有用： 对象的构建十分复杂 需要依赖具体环境创建不同实例 处理大量具有相同属性的小对象 123456789101112131415var productManager = &#123;&#125;;productManager.createProductA = function () &#123; console.log(&apos;ProductA&apos;);&#125;productManager.createProductB = function () &#123; console.log(&apos;ProductB&apos;);&#125; productManager.factory = function (typeType) &#123; return new productManager[typeType];&#125;productManager.factory(&quot;createProductA&quot;); 一句话，就是根据不同的类型，调用不同的子类，进行实例化一个对象 第二十九部分，设计模式之装饰者模式装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。 123456789101112131415161718192021222324252627282930313233343536373839var tree = &#123;&#125;;tree.decorate = function () &#123; console.log(&apos;Make sure the tree won\\&apos;t fall&apos;);&#125;;tree.getDecorator = function (deco) &#123; tree[deco].prototype = this; return new tree[deco];&#125;;tree.RedBalls = function () &#123; this.decorate = function () &#123; this.RedBalls.prototype.decorate(); // 第7步：先执行原型（这时候是Angel了）的decorate方法 console.log(&apos;Put on some red balls&apos;); // 第8步 再输出 red // 将这2步作为RedBalls的decorate方法 &#125;&#125;;tree.BlueBalls = function () &#123; this.decorate = function () &#123; this.BlueBalls.prototype.decorate(); // 第1步：先执行原型的decorate方法，也就是tree.decorate() console.log(&apos;Add blue balls&apos;); // 第2步 再输出blue // 将这2步作为BlueBalls的decorate方法 &#125;&#125;;tree.Angel = function () &#123; this.decorate = function () &#123; this.Angel.prototype.decorate(); // 第4步：先执行原型（这时候是BlueBalls了）的decorate方法 console.log(&apos;An angel on the top&apos;); // 第5步 再输出angel // 将这2步作为Angel的decorate方法 &#125;&#125;;tree = tree.getDecorator(&apos;BlueBalls&apos;); // 第3步：将BlueBalls对象赋给tree，这时候父原型里的getDecorator依然可用tree = tree.getDecorator(&apos;Angel&apos;); // 第6步：将Angel对象赋给tree，这时候父原型的父原型里的getDecorator依然可用tree = tree.getDecorator(&apos;RedBalls&apos;); // 第9步：将RedBalls对象赋给treetree.decorate(); // 第10步：执行RedBalls对象的decorate方法 这段代码，主要是在于， tree.getDecorator 这段函数设计精妙 他让tree接受一个新的函数，而每次都用这个新函数去替代之前的函数，并且同时让原型指向前一个，实现了一个 继承关系，比如A-》B-》C，最开始tree是A，然后，放入一个，就变成B，之后为C 第三十部分，设计模式之外观模式外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。 外观模式经常被用于JavaScript类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。 外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点 外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。 123456789101112131415161718var addMyEvent = function (el, ev, fn) &#123; if (el.addEventListener) &#123; el.addEventListener(ev, fn, false); &#125; else if (el.attachEvent) &#123; el.attachEvent(&apos;on&apos; + ev, fn); &#125; else &#123; el[&apos;on&apos; + ev] = fn; &#125;&#125;; 再来一个简单的例子，说白了就是用一个接口封装其它的接口：var mobileEvent = &#123; // ... stop: function (e) &#123; e.preventDefault(); e.stopPropagation(); &#125; // ...&#125;; 第三十一部分，设计模式之代理模式代理，顾名思义就是帮助别人做事12345678910111213141516171819202122// 先声明美女对象var girl = function (name) &#123; this.name = name;&#125;;// 这是duduvar dudu = function (girl) &#123; this.girl = girl; this.sendGift = function (gift) &#123; alert(&quot;Hi &quot; + girl.name + &quot;, dudu送你一个礼物：&quot; + gift); &#125;&#125;;// 大叔是代理var proxyTom = function (girl) &#123; this.girl = girl; this.sendGift = function (gift) &#123; (new dudu(girl)).sendGift(gift); // 替dudu送花咯 &#125;&#125;;说的简单一点，就是代理新类，必须包括被代理的对象，也就是可以主动new 第三十二部分，设计模式之观察者模式观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。 123456789101112131415161718192021jQuery版本根据jQuery1.7版新增的on/off功能，我们也可以定义jQuery版的观察者：(function ($) &#123; var o = $(&#123;&#125;); $.subscribe = function () &#123; o.on.apply(o, arguments); &#125;; $.unsubscribe = function () &#123; o.off.apply(o, arguments); &#125;; $.publish = function () &#123; o.trigger.apply(o, arguments); &#125;;&#125; (jQuery)); 第三十三部分，设计模式之策略模式策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108正常的模式，缺点就是，下次继续增加case进行判断 validator = &#123; validate: function (value, type) &#123; switch (type) &#123; case &apos;isNonEmpty &apos;: &#123; return true; // NonEmpty 验证结果 &#125; case &apos;isNumber &apos;: &#123; return true; // Number 验证结果 break; &#125; case &apos;isAlphaNum &apos;: &#123; return true; // AlphaNum 验证结果 &#125; default: &#123; return true; &#125; &#125; &#125; &#125;; // 测试 alert(validator.validate(&quot;123&quot;, &quot;isNonEmpty&quot;));策略模式var validator = &#123; // 所有可以的验证规则处理类存放的地方，后面会单独定义 types: &#123;&#125;, // 验证类型所对应的错误消息 messages: [], // 当然需要使用的验证类型 config: &#123;&#125;, // 暴露的公开验证方法 // 传入的参数是 key =&gt; value对 validate: function (data) &#123; var i, msg, type, checker, result_ok; // 清空所有的错误信息 this.messages = []; for (i in data) &#123; if (data.hasOwnProperty(i)) &#123; type = this.config[i]; // 根据key查询是否有存在的验证规则 checker = this.types[type]; // 获取验证规则的验证类 if (!type) &#123; continue; // 如果验证规则不存在，则不处理 &#125; if (!checker) &#123; // 如果验证规则类不存在，抛出异常 throw &#123; name: &quot;ValidationError&quot;, message: &quot;No handler to validate type &quot; + type &#125;; &#125; result_ok = checker.validate(data[i]); // 使用查到到的单个验证类进行验证 if (!result_ok) &#123; msg = &quot;Invalid value for *&quot; + i + &quot;*, &quot; + checker.instructions; this.messages.push(msg); &#125; &#125; &#125; return this.hasErrors(); &#125;, // helper hasErrors: function () &#123; return this.messages.length !== 0; &#125;&#125;;然后剩下的工作，就是定义types里存放的各种验证类了，我们这里只举几个例子：// 验证给定的值是否不为空validator.types.isNonEmpty = &#123; validate: function (value) &#123; return value !== &quot;&quot;; &#125;, instructions: &quot;传入的值不能为空&quot;&#125;;// 验证给定的值是否是数字validator.types.isNumber = &#123; validate: function (value) &#123; return !isNaN(value); &#125;, instructions: &quot;传入的值只能是合法的数字，例如：1, 3.14 or 2010&quot;&#125;;// 验证给定的值是否只是字母或数字validator.types.isAlphaNum = &#123; validate: function (value) &#123; return !/[^a-z0-9]/i.test(value); &#125;, instructions: &quot;传入的值只能保护字母和数字，不能包含特殊字符&quot;&#125;;以配置替代之前的写死的那种方式，可以理解为开闭原则，不修改之前的代码 第三十四部分，设计模式之命令模式命令模式(Command)的定义是：用于将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理。此外，可以通过调用实现具体函数的对象来解耦命令对象与接收对象。 123456789101112131415161718192021222324252627282930313233$(function () &#123; var CarManager = &#123; // 请求信息 requestInfo: function (model, id) &#123; return &apos;The information for &apos; + model + &apos; with ID &apos; + id + &apos; is foobar&apos;; &#125;, // 购买汽车 buyVehicle: function (model, id) &#123; return &apos;You have successfully purchased Item &apos; + id + &apos;, a &apos; + model; &#125;, // 组织view arrangeViewing: function (model, id) &#123; return &apos;You have successfully booked a viewing of &apos; + model + &apos; ( &apos; + id + &apos; ) &apos;; &#125; &#125;;&#125;)();CarManager.execute = function (command) &#123; return CarManager[command.request](command.model, command.carID);&#125;;CarManager.execute(&#123; request: &quot;arrangeViewing&quot;, model: &apos;Ferrari&apos;, carID: &apos;145523&apos; &#125;);之前可能没明白命令模式，现在看这个例子，就很简单了，就是，我不具体的调用函数，而是改成一个命令，通过一个弄命令函数，传入不同的指令，实现方法的调用大叔的意思是说，不推荐使用，可以直接调用，就不用这么麻烦，前天是系统不复杂的时候 第三十五部分，设计模式之迭代器模式迭代器模式(Iterator)：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。 迭代器的几个特点是： 访问一个聚合对象的内容而无需暴露它的内部表示。为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。 123456789jQuery里一个非常有名的迭代器就是$.each方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：$.each([&apos;dudu&apos;, &apos;dudu&apos;, &apos;酸奶小妹&apos;, &apos;那个MM&apos;], function (index, value) &#123; console.log(index + &apos;: &apos; + value);&#125;);//或者$(&apos;li&apos;).each(function (index) &#123; console.log(index + &apos;: &apos; + $(this).text());&#125;); 第三十六部分，设计模式之中介者模式软件开发中，中介者是一个行为设计模式，通过提供一个统一的接口让系统的不同部分进行通信。一般，如果系统有很多子模块需要直接沟通，都要创建一个中央控制点让其各模块通过该中央控制点进行交互。中介者模式可以让这些子模块不需要直接沟通，而达到进行解耦的目的。 打个比方，平时常见的机场交通控制系统，塔台就是中介者，它控制着飞机（子模块）的起飞和降落，因为所有的沟通都是从飞机向塔台汇报来完成的，而不是飞机之前相互沟通。中央控制系统就是该系统的关键，也就是软件设计中扮演的中介者角色。 1234567891011121314151617181920212223// 如下代码是伪代码，请不要过分在意代码// 这里app命名空间就相当于扮演中介者的角色var app = app || &#123;&#125;; // 通过app中介者来进行Ajax请求app.sendRequest = function ( options ) &#123; return $.ajax($.extend(&#123;&#125;, options);&#125; // 请求URL以后，展示Viewapp.populateView = function( url, view )&#123; $.when(app.sendRequest(&#123;url: url, method: &apos;GET&apos;&#125;) .then(function()&#123; //显示内容 &#125;);&#125; // 清空内容app.resetView = function( view )&#123; view.html(&apos;&apos;);&#125;之前没有分清，中介和代理，其实区别是明显，中介，里面参与的是多个人，他共同维护这些人，而且还都彼此认识switch 而代理，只是简单的处理一个人而已，参与者一 另外，由于中介者模式把交互复杂性变成了中介者本身的复杂性，所以说中介者对象会比其它任何对象都复杂。 第三十七部分，设计模式之享元模式Flyweight中有两个重要概念–内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，而外部信息可以在通过外部删除或者保存。 说白点,就是先捏一个的原始模型，然后随着不同场合和环境,再产生各具特征的具体模型，很显然,在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式， 1234567891011121314151617181920212223242526272829303132333435363738394041424344var Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability )&#123; this.id = id; this.title = title; this.author = author; this.genre = genre; this.pageCount = pageCount; this.publisherID = publisherID; this.ISBN = ISBN; this.checkoutDate = checkoutDate; this.checkoutMember = checkoutMember; this.dueReturnDate = dueReturnDate; this.availability = availability;&#125;;Book.prototype = &#123; getTitle:function()&#123; return this.title; &#125;, getAuthor: function()&#123; return this.author; &#125;, getISBN: function()&#123; return this.ISBN; &#125;,/*其它get方法在这里就不显示了*/上面这种函数，最大的问题，就是后面的那4个参数，就算是同一本书，时间不一样，都算成是不一样的其实，你是想知道，书这个东西，而不是书*变量个，这样内存中有很多没用的例子$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123; console.log(&apos;You clicked: &apos; + $(this).attr(&apos;id&apos;));&#125;);// 上面的代码，要避免使用，避免再次对DOM元素进行生成jQuery对象，因为这里可以直接使用DOM元素自身了。$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123; console.log(&apos;You clicked: &apos; + this.id);&#125;);其实，很简单，就是一个排列组合的问题比如，创建文件夹来举例吧，你是创建book1到book10,10个文件夹，还是，创建book文件夹，里面放1-10个子文件夹，一个11个文件夹第一种方案字符串是，5*9+6=51第二种方案是4+9+2=15这节省空间是明显的，别问啥意思 第三十八部分，设计模式之职责链模式职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。 也就是说，请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。提交请求的对象并不明确知道哪一个对象将会处理它——也就是该请求有一个隐式的接受者（implicit receiver）。根据运行时刻，任一候选者都可以响应相应的请求，候选者的数目是任意的，你可以在运行时刻决定哪些候选者参与到链中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var NO_TOPIC = -1;var Topic;function Handler(s, t) &#123; this.successor = s || null; this.topic = t || 0;&#125;Handler.prototype = &#123; handle: function () &#123; if (this.successor) &#123; this.successor.handle() &#125; &#125;, has: function () &#123; return this.topic != NO_TOPIC; &#125;&#125;;var app = new Handler(&#123; handle: function () &#123; console.log(&apos;app handle&apos;); &#125;&#125;, 3);var dialog = new Handler(app, 1);dialog.handle = function () &#123; console.log(&apos;dialog before ...&apos;) // 这里做具体的处理操作 Handler.prototype.handle.call(this); //继续往上走 console.log(&apos;dialog after ...&apos;)&#125;;var button = new Handler(dialog, 2);button.handle = function () &#123; console.log(&apos;button before ...&apos;) // 这里做具体的处理操作 Handler.prototype.handle.call(this); console.log(&apos;button after ...&apos;)&#125;;button.handle();通过代码的运行结果我们可以看出，如果想先自身处理，然后再调用继任者处理的话，就在末尾执行Handler.prototype.handle.call(this);代码，如果想先处理继任者的代码，就在开头执行Handler.prototype.handle.call(this);代码。prototype用的好，就得理解this和prototype 第三十九部分，设计模式之适配器模式适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//鸭子var Duck = function()&#123;&#125;;Duck.prototype.fly = function()&#123;throw new Error(&quot;该方法必须被重写!&quot;);&#125;;Duck.prototype.quack = function()&#123;throw new Error(&quot;该方法必须被重写!&quot;);&#125;//火鸡var Turkey = function()&#123;&#125;;Turkey.prototype.fly = function()&#123; throw new Error(&quot; 该方法必须被重写 !&quot;);&#125;;Turkey.prototype.gobble = function()&#123; throw new Error(&quot; 该方法必须被重写 !&quot;);&#125;;//鸭子var MallardDuck = function () &#123; Duck.apply(this);&#125;;MallardDuck.prototype = new Duck(); //原型是DuckMallardDuck.prototype.fly = function () &#123; console.log(&quot;可以飞翔很长的距离!&quot;);&#125;;MallardDuck.prototype.quack = function () &#123; console.log(&quot;嘎嘎！嘎嘎！&quot;);&#125;;//火鸡var WildTurkey = function () &#123; Turkey.apply(this);&#125;;WildTurkey.prototype = new Turkey(); //原型是TurkeyWildTurkey.prototype.fly = function () &#123; console.log(&quot;飞翔的距离貌似有点短!&quot;);&#125;;WildTurkey.prototype.gobble = function () &#123; console.log(&quot;咯咯！咯咯！&quot;);&#125;; 那合适使用适配器模式好呢？如果有以下情况出现时，建议使用： 使用一个已经存在的对象，但其方法或属性接口不符合你的要求； 你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作； 想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性。 另外，适配器模式和其它几个模式可能容易让人迷惑，这里说一下大概的区别： 适配器和桥接模式虽然类似，但桥接的出发点不同，桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口。 装饰者模式增强了其它对象的功能而同时又不改变它的接口，因此它对应程序的透明性比适配器要好，其结果是装饰者支持递归组合，而纯粹使用适配器则是不可能的。 代理模式在不改变它的接口的条件下，为另外一个对象定义了一个代理。 第四十部分，设计模式之组合模式组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 常见的场景有asp.net里的控件机制（即control里可以包含子control，可以递归操作、添加、删除子control），类似的还有DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135var MenuComponent = function () &#123;&#125;;MenuComponent.prototype.getName = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;MenuComponent.prototype.getDescription = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;MenuComponent.prototype.getPrice = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;MenuComponent.prototype.isVegetarian = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;MenuComponent.prototype.print = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;MenuComponent.prototype.add = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;MenuComponent.prototype.remove = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;MenuComponent.prototype.getChild = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;var MenuItem = function (sName, sDescription, bVegetarian, nPrice) &#123; MenuComponent.apply(this); this.sName = sName; this.sDescription = sDescription; this.bVegetarian = bVegetarian; this.nPrice = nPrice;&#125;;MenuItem.prototype = new MenuComponent();MenuItem.prototype.getName = function () &#123; return this.sName;&#125;;MenuItem.prototype.getDescription = function () &#123; return this.sDescription;&#125;;MenuItem.prototype.getPrice = function () &#123; return this.nPrice;&#125;;MenuItem.prototype.isVegetarian = function () &#123; return this.bVegetarian;&#125;;MenuItem.prototype.print = function () &#123; console.log(this.getName() + &quot;: &quot; + this.getDescription() + &quot;, &quot; + this.getPrice() + &quot;euros&quot;);&#125;;var Menu = function (sName, sDescription) &#123; MenuComponent.apply(this); this.aMenuComponents = []; this.sName = sName; this.sDescription = sDescription; this.createIterator = function () &#123; throw new Error(&quot;This method must be overwritten!&quot;); &#125;;&#125;;Menu.prototype = new MenuComponent();Menu.prototype.add = function (oMenuComponent) &#123; // 添加子菜品 this.aMenuComponents.push(oMenuComponent);&#125;;Menu.prototype.remove = function (oMenuComponent) &#123; // 删除子菜品 var aMenuItems = []; var nMenuItem = 0; var nLenMenuItems = this.aMenuComponents.length; var oItem = null; for (; nMenuItem &lt; nLenMenuItems; ) &#123; oItem = this.aMenuComponents[nMenuItem]; if (oItem !== oMenuComponent) &#123; aMenuItems.push(oItem); &#125; nMenuItem = nMenuItem + 1; &#125; this.aMenuComponents = aMenuItems;&#125;;Menu.prototype.getChild = function (nIndex) &#123; //获取指定的子菜品 return this.aMenuComponents[nIndex];&#125;;Menu.prototype.getName = function () &#123; return this.sName;&#125;;Menu.prototype.getDescription = function () &#123; return this.sDescription;&#125;;Menu.prototype.print = function () &#123; // 打印当前菜品以及所有的子菜品 console.log(this.getName() + &quot;: &quot; + this.getDescription()); console.log(&quot;--------------------------------------------&quot;); var nMenuComponent = 0; var nLenMenuComponents = this.aMenuComponents.length; var oMenuComponent = null; for (; nMenuComponent &lt; nLenMenuComponents; ) &#123; oMenuComponent = this.aMenuComponents[nMenuComponent]; oMenuComponent.print(); nMenuComponent = nMenuComponent + 1; &#125;&#125;;var DinnerMenu = function () &#123; Menu.apply(this);&#125;;DinnerMenu.prototype = new Menu();var CafeMenu = function () &#123; Menu.apply(this);&#125;;CafeMenu.prototype = new Menu();var PancakeHouseMenu = function () &#123; Menu.apply(this);&#125;;PancakeHouseMenu.prototype = new Menu();var Mattress = function (aMenus) &#123; this.aMenus = aMenus;&#125;;Mattress.prototype.printMenu = function () &#123; this.aMenus.print();&#125;;组合模式，特点就是抽象一个父子公用的类，比如，add，remove这些getChild之类的，必须提供 第四十一部分，设计模式之模板方法模板方法（TemplateMethod）定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法是一种代码复用的基本技术，在类库中尤为重要，因为他们提取了类库中的公共行为。模板方法导致一种反向的控制结构，这种结构就是传说中的“好莱坞法则”，即“别找找我们，我们找你 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var CaffeineBeverage = function () &#123;&#125;;CaffeineBeverage.prototype.prepareRecipe = function () &#123; this.boilWater(); this.brew(); this.pourOnCup(); if (this.customerWantsCondiments()) &#123; // 如果可以想加小料，就加上 this.addCondiments(); &#125;&#125;;CaffeineBeverage.prototype.boilWater = function () &#123; console.log(&quot;将水烧开!&quot;);&#125;;CaffeineBeverage.prototype.pourOnCup = function () &#123; console.log(&quot;将饮料到再杯子里!&quot;);&#125;;CaffeineBeverage.prototype.brew = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;CaffeineBeverage.prototype.addCondiments = function () &#123; throw new Error(&quot;该方法必须重写!&quot;);&#125;;// 默认加上小料CaffeineBeverage.prototype.customerWantsCondiments = function () &#123; return true;&#125;;// 冲咖啡var Coffee = function () &#123; CaffeineBeverage.apply(this);&#125;;Coffee.prototype = new CaffeineBeverage();Coffee.prototype.brew = function () &#123; console.log(&quot;从咖啡机想咖啡倒进去!&quot;);&#125;;Coffee.prototype.addCondiments = function () &#123; console.log(&quot;添加糖和牛奶&quot;);&#125;;Coffee.prototype.customerWantsCondiments = function () &#123; return confirm(&quot;你想添加糖和牛奶吗？&quot;);&#125;;//冲茶叶var Tea = function () &#123; CaffeineBeverage.apply(this);&#125;;Tea.prototype = new CaffeineBeverage();Tea.prototype.brew = function () &#123; console.log(&quot;泡茶叶!&quot;);&#125;;Tea.prototype.addCondiments = function () &#123; console.log(&quot;添加柠檬!&quot;);&#125;;Tea.prototype.customerWantsCondiments = function () &#123; return confirm(&quot;你想添加柠檬嘛？&quot;);&#125;; 模板方法应用于下列情况： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现各子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复，不同之处分离为新的操作，最后，用一个钓鱼这些新操作的模板方法来替换这些不同的代码控制子类扩展，模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展 第四十二部分，设计模式之原型模式原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。 12345678910111213141516171819var vehicle = &#123; getModel: function () &#123; console.log(&apos;车辆的模具是：&apos; + this.model); &#125;&#125;;var car = Object.create(vehicle, &#123; &apos;id&apos;: &#123; value: MY_GLOBAL.nextId(), enumerable: true // 默认writable:false, configurable:false &#125;, &apos;model&apos;: &#123; value: &apos;福特&apos;, enumerable: true &#125;&#125;);说的简单一点，其实就是特指，JavaScript里面的原型模式 第四十三部分，设计模式之状态模式状态模式（State）允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类。这个地方内容代码太长了我自己理解，总结一下 比如有A，B，C三种状态 那么每种状态必须对应了一组动作，比如开和关，那么3*2=6种状态 三种状态，有种转换关系，状态的改变，同样的开，代表的意思不一样 比如顺序，A-》B-》C-》A，那么同样的，动作，开随着状态的改变，意义发生变化第四十四部分，设计模式之桥接模式 桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。 12345678910111213141516function getBeerById(id, callback) &#123;// 通过ID发送请求，然后返回数据asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;// callback responsecallback(resp.responseText);&#125;);&#125;桥接，看大叔的例子，还真是没懂，回去看了我之前写过的设计模式，才慢慢理解switch 桥接=代理+策略为什么这么说？1. jdbc是桥接，怎么用，是不是每次主动输入一个mysql.jdbc这么个字符串？2. 代理模式很明白的只代理一个类，内部写死了3. 而策略模式，是有一组策略，客户端不需要具体使用了什么策略4. 那么桥接，就是你要明确的告诉这个代理，要用哪种策略5. 因此，你需要清楚，你是要给谁桥？6. 因此上面这个例子，callback，就是你自己传递尽量的，按个策略 第四十五部分，代码复用模式（避免篇）写了6篇，应该让我们避免的模式，那么不要去话时间记忆不要用的，重点在下篇 第四十六部分，代码复用模式（推荐篇）只需记住，大叔推荐，让我们记住的模式，就可以了 模式1：原型继承 原型继承是让父对象作为子对象的原型，从而达到继承的目的： function object(o) { function F() { } F.prototype = o; return new F(); } // 要继承的父对象 var parent = { name: &quot;Papa&quot; }; // 新对象 var child = object(parent); // 测试 console.log(child.name); // &quot;Papa&quot; // 父构造函数 function Person() { // an &quot;own&quot; property this.name = &quot;Adam&quot;; } // 给原型添加新属性 Person.prototype.getName = function () { return this.name; }; // 创建新person var papa = new Person(); // 继承 var kid = object(papa); console.log(kid.getName()); // &quot;Adam&quot; // 父构造函数 function Person() { // an &quot;own&quot; property this.name = &quot;Adam&quot;; } // 给原型添加新属性 Person.prototype.getName = function () { return this.name; }; // 继承 var kid = object(Person.prototype); console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的 console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型 记住一句话，prototype是一个对象 function object(o) { function F() { } F.prototype = o; return new F(); } // 要继承的父对象 var parent = { name: &quot;Papa&quot; }; // 新对象 var child = object(parent); // 测试 console.log(child.name); // &quot;Papa&quot; // 父构造函数 function Person() { // an &quot;own&quot; property this.name = &quot;Adam&quot;; } // 给原型添加新属性 Person.prototype.getName = function () { return this.name; }; // 创建新person var papa = new Person(); // 继承 var kid = object(papa); console.log(kid.getName()); // &quot;Adam&quot; // 父构造函数 function Person() { // an &quot;own&quot; property this.name = &quot;Adam&quot;; } // 给原型添加新属性 Person.prototype.getName = function () { return this.name; }; // 继承 var kid = object(Person.prototype); console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的 console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型 模式2：复制所有属性进行继承 这种方式的继承就是将父对象里所有的属性都复制到子对象上，一般子对象可以使用父对象的数据。 先来看一个浅拷贝的例子： /* 浅拷贝 */ function extend(parent, child) { var i; child = child || {}; for (i in parent) { if (parent.hasOwnProperty(i)) { child[i] = parent[i]; } } return child; } var dad = { name: &quot;Adam&quot; }; var kid = extend(dad); console.log(kid.name); // &quot;Adam&quot; var dad = { counts: [1, 2, 3], reads: { paper: true } }; var kid = extend(dad); kid.counts.push(4); console.log(dad.counts.toString()); // &quot;1,2,3,4&quot; console.log(dad.reads === kid.reads); // true 代码的最后一行，你可以发现dad和kid的reads是一样的，也就是他们使用的是同一个引用，这也就是浅拷贝带来的问题。 /* 深拷贝 */ function extendDeep(parent, child) { var i, toStr = Object.prototype.toString, astr = &quot;[object Array]&quot;; child = child || {}; for (i in parent) { if (parent.hasOwnProperty(i)) { if (typeof parent[i] === &apos;object&apos;) { child[i] = (toStr.call(parent[i]) === astr) ? [] : {}; extendDeep(parent[i], child[i]); } else { child[i] = parent[i]; } } } return child; } var dad = { counts: [1, 2, 3], reads: { paper: true } }; var kid = extendDeep(dad); kid.counts.push(4); console.log(kid.counts.toString()); // &quot;1,2,3,4&quot; console.log(dad.counts.toString()); // &quot;1,2,3&quot; console.log(dad.reads === kid.reads); // false kid.reads.paper = false; 这个地方就是厉害在，上面的递归那部分，当包含复合部分就会重新递归调用一次 模式3：混合（mix-in） 混入就是将一个对象的一个或多个（或全部）属性（或方法）复制到另外一个对象，我们举一个例子： function mix() { var arg, prop, child = {}; for (arg = 0; arg &lt; arguments.length; arg += 1) { for (prop in arguments[arg]) { if (arguments[arg].hasOwnProperty(prop)) { child[prop] = arguments[arg][prop]; } } } return child; } var cake = mix( { eggs: 2, large: true }, { butter: 1, salted: true }, { flour: &apos;3 cups&apos; }, { sugar: &apos;sure!&apos; } ); console.dir(cake); 模式4：借用方法 一个对象借用另外一个对象的一个或两个方法，而这两个对象之间不会有什么直接联系。不用多解释，直接用代码解释吧： var one = { name: &apos;object&apos;, say: function (greet) { return greet + &apos;, &apos; + this.name; } }; // 测试 console.log(one.say(&apos;hi&apos;)); // &quot;hi, object&quot; var two = { name: &apos;another object&apos; }; console.log(one.say.apply(two, [&apos;hello&apos;])); // &quot;hello, another object&quot; // 将say赋值给一个变量，this将指向到全局变量 var say = one.say; console.log(say(&apos;hoho&apos;)); // &quot;hoho, undefined&quot; // 传入一个回调函数callback var yetanother = { name: &apos;Yet another object&apos;, method: function (callback) { return callback(&apos;Hola&apos;); } }; console.log(yetanother.method(one.say)); // &quot;Holla, undefined&quot; function bind(o, m) { return function () { return m.apply(o, [].slice.call(arguments)); }; } var twosay = bind(two, one.say); console.log(twosay(&apos;yo&apos;)); // &quot;yo, another object&quot; // ECMAScript 5给Function.prototype添加了一个bind()方法，以便很容易使用apply()和call()。 if (typeof Function.prototype.bind === &apos;undefined&apos;) { Function.prototype.bind = function (thisArg) { var fn = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function () { return fn.apply(thisArg, args.concat(slice.call(arguments))); }; }; } var twosay2 = one.say.bind(two); console.log(twosay2(&apos;Bonjour&apos;)); // &quot;Bonjour, another object&quot; var twosay3 = one.say.bind(two, &apos;Enchanté&apos;); console.log(twosay3()); // &quot;Enchanté, another object&quot; 第四十七部分，对象创建模式（上篇）模式1：命名空间（namespace） 命名空间可以减少全局命名所需的数量，避免命名冲突或过度。一般我们在进行对象层级定义的时候，经常是这样的： var app = app || {}; app.moduleA = app.moduleA || {}; // 更简洁的方式 var MYAPP = MYAPP || {}; 模式2：定义依赖 有时候你的一个模块或者函数可能要引用第三方的一些模块或者工具，这时候最好将这些依赖模块在刚开始的时候就定义好，以便以后可以很方便地替换掉。 var myFunction = function () { // 依赖模块 var event = YAHOO.util.Event, dom = YAHOO.util.dom; // 其它函数后面的代码里使用局部变量event和dom }; }; 模式3：私有属性和私有方法 JavaScript本书不提供特定的语法来支持私有属性和私有方法，但是我们可以通过闭包来实现，代码如下： function Gadget() { // 私有对象 var name = &apos;iPod&apos;; // 公有函数 this.getName = function () { return name; }; } 模式4：Revelation模式 也是关于隐藏私有方法的模式，和《深入理解JavaScript系列（3）：全面解析Module模式》里的Module模式有点类似，但是不是return的方式，而是在外部先声明一个变量，然后在内部给变量赋值公有方法。代码如下： var myarray; (function () { var astr = &quot;[object Array]&quot;, toString = Object.prototype.toString; function isArray(a) { return toString.call(a) === astr; } function indexOf(haystack, needle) { var i = 0, max = haystack.length; for (; i &lt; max; i += 1) { if (haystack[i] === needle) { return i; } } return -1; } //通过赋值的方式，将上面所有的细节都隐藏了 myarray = { isArray: isArray, indexOf: indexOf, inArray: indexOf }; } ()); 模式5：链模式 链模式可以你连续可以调用一个对象的方法，比如obj.add(1).remove(2).delete(4).add(2)这样的形式，其实现思路非常简单，就是将this原样返回。代码如下： var obj = { value: 1, increment: function () { this.value += 1; return this; }, add: function (v) { this.value += v; return this; }, shout: function () { console.log(this.value); } }; 第四十八部分，对象创建模式（下篇）模式6：函数语法糖 函数语法糖是为一个对象快速添加方法（函数）的扩展，这个主要是利用prototype的特性，代码比较简单，我们先来看一下实现代码： if (typeof Function.prototype.method !== &quot;function&quot;) { Function.prototype.method = function (name, implementation) { this.prototype[name] = implementation; return this; }; } 模式7：对象常量 对象常量是在一个对象提供set,get,ifDefined各种方法的体现，而且对于set的方法只会保留最先设置的对象，后期再设置都是无效的，已达到别人无法重载的目的。实现代码如下： var constant = (function () { var constants = {}, ownProp = Object.prototype.hasOwnProperty, // 只允许设置这三种类型的值 allowed = { string: 1, number: 1, boolean: 1 }, 模式8：沙盒模式 沙盒（Sandbox）模式即时为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个Sandbox里有3个方法event,dom,ajax，在调用其中2个组成一个环境的话，和调用三个组成的环境完全没有干扰。 模式9：静态成员 静态成员（Static Members）只是一个函数或对象提供的静态属性，可分为私有的和公有的，就像C#或Java里的public static和private static一样。 我们先来看一下公有成员，公有成员非常简单，我们平时声明的方法，函数都是公有的，比如： // 构造函数 var Gadget = function () { }; // 公有静态方法 Gadget.isShiny = function () { return &quot;you bet&quot;; }; // 原型上添加的正常方法 Gadget.prototype.setPrice = function (price) { this.price = price; }; // 调用静态方法 console.log(Gadget.isShiny()); // &quot;you bet&quot; // 创建实例，然后调用方法 var iphone = new Gadget(); iphone.setPrice(500); 而私有静态成员，我们可以利用其闭包特性去实现，以下是两种实现方式。 第一种实现方式： var Gadget = (function () { // 静态变量/属性 var counter = 0; // 闭包返回构造函数的新实现 return function () { console.log(counter += 1); }; } ()); // 立即执行 var g1 = new Gadget(); // logs 1 var g2 = new Gadget(); // logs 2 var g3 = new Gadget(); // logs 3 第四十九部分，Function模式（上篇）回调函数 在JavaScript中，当一个函数A作为另外一个函数B的其中一个参数时，则函数A称为回调函数，即A可以在函数B的周期内执行（开始、中间、结束时均可）。 配置对象 如果一个函数（或方法）的参数只有一个参数，并且参数为对象字面量，我们则称这种模式为配置对象模式。例如，如下代码： var conf = { username:&quot;shichuan&quot;, first:&quot;Chuan&quot;, last:&quot;Shi&quot; }; 返回函数 返回函数，则是指在一个函数的返回值为另外一个函数，或者根据特定的条件灵活创建的新函数，示例代码如下： var setup = function () { console.log(1); return function () { console.log(2); }; }; // 调用setup 函数 var my = setup(); // 输出 1 my(); // 输出 2 // 或者直接调用也可 setup()(); 强调一句，这种形式的this，认为是ao，激活对象，也可以认为是null，因此是global 偏应用 忽略 Currying Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。 忽略 第五十部分，Function模式（下篇）立即执行的对象初始化 该模式的意思是指在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作，通常该模式可以用在一次性执行的代码上。 ({ // 这里你可以定义常量，设置其它值 maxwidth: 600, maxheight: 400, // 当然也可以定义utility方法 gimmeMax: function () { return this.maxwidth + &quot;x&quot; + this.maxheight; }, // 初始化 init: function () { console.log(this.gimmeMax()); // 更多代码... } }).init(); // 这样就开始初始化咯 分支初始化 分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。之前我们在做事件处理的时候，通常使用类似下面的代码： var utils = { addListener: function (el, type, fn) { if (typeof window.addEventListener === &apos;function&apos;) { el.addEventListener(type, fn, false); } else if (typeof document.attachEvent !== &apos;undefined&apos;) { el.attachEvent(&apos;on&apos; + type, fn); } else { el[&apos;on&apos; + type] = fn; } }, removeListener: function (el, type, fn) { } }; 内存优化 该模式主要是利用函数的属性特性来避免大量的重复计算。通常代码形式如下： var myFunc = function (param) { if (!myFunc.cache[param]) { var result = {}; // ... 复杂操作 ... myFunc.cache[param] = result; } return myFunc.cache[param]; }; // cache 存储 myFunc.cache = {};","path":"2017/06/13/tomdashu3/"},{"title":"汤姆大叔的深入理解JavaScript读后感二（17——24节）","text":"今天要分享的内容是tom大叔的JavaScript系列的读书观后感2 第十七部分，面向对象编程之概论我们有必要掌握一些OOP基本的特征，并澄清概论中的主要概念。主要讨论封装，继承，多态，接口，那些传统的面向对象概念，可以忽略不看，不影响 第十八部分，面向对象编程之ECMAScript实现（推荐）总结如下： 1. 原始值类型 回头来看6中用于ECMAScript程序的数据类型，前5种是原始值类型，包括Undefined、Null、Boolean、String、Number、Object。 2. 有必要需要注意的是规范还区分了这内置对象、元素对象和宿主对象。 所有ECMAScript实现的对象都是原生对象（其中一些是内置对象、一些在程序执行的时候创建，例如用户自定义对象）。内置对象是原生对象的一个子集、是在程序开始之前内置到ECMAScript里的（例如，parseInt, Match等）。所有的宿主对象是由宿主环境提供的，通常是浏览器，并可能包括如window、alert等。 也有对象是由特殊的内置构造函数创建： Function（函数对象构造器）、Array（数组构造器） RegExp（正则表达式构造器）、Math（数学模块）、 Date（日期的构造器）等等，这些对象也是Object对象类型的值 3. 字面量Literal 对于三个对象的值：对象（object）,数组（array）和正则表达式（regular expression） 4. 然而，如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性： function A() {} A.prototype = { x: 10 }; var a = new A(); alert(a.x); // 10 alert(a.constructor === A); // false! 因此，对函数的原型引用需要手工恢复： function A() {} A.prototype = { constructor: A, x: 10 }; var a = new A(); alert(a.x); // 10 alert(a.constructor === A); // true 5. a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype 此外， 实例的[[Prototype]]值确实是在构造函数的prototype属性上获取的。 然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。 对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。 这个地方，原型链，特别难理解，详细的看第一篇，观后感的，原型链的，链接，那个是非常详细的说明 6. 有误解： if (foo instanceof Foo) { ... } 这不是用来检测对象foo是否是用Foo构造函数创建的， 所有instanceof运算符只需要一个对象属性——foo.[[Prototype]]，在原型链中从Foo.prototype开始检查其是否存在。 7. alert(1..toString()); // &quot;1&quot;，不是语法错误 大部分程序里使用原型是用来存储对象的方法、默认状态和共享对象的属性。 第十九部分，求值策略(Evaluation strategy)很多程序员都确信在JavaScript中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参 1. 按值传递 按值传递，很多开发人员都很了解了，参数的值是调用者传递的对象值的拷贝(copy of value），函数内部改变参数的值不会影响到外面的对象（该参数在外面的值），一般来说，是重新分配了新内存(我们不关注分配内存是怎么实现的——也是是栈也许是动态内存分配），该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。 2. 按引用传递 另外一个众所周知的按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。 3. 按共享传递（Call by sharing） 最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象（例如外部的该对象不是想按值传递一样完全的拷贝),改变该参数对象的属性值将会影响到外部的对象。 4. 现在我们知道了ECMAScript中将对象作为参数传递的策略了——按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象 传递的是引用的拷贝（地址副本） 再强调一下，这里所说对象的值是地址（address），而不是对象结构本身，将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。 第二十部分，《你真懂JavaScript吗？》答案详解总结如下： 1. 题目1 if (!(&quot;a&quot; in window)) { var a = 1; } alert(a); 答案是undefined 2. var a = 1, b = function a(x) { x &amp;&amp; a(--x); }; alert(a); 答案1 3. function a(x) { return x * 2; } var a; alert(a); 答案 a函数 4. function b(x, y, a) { arguments[2] = 10; alert(a); } b(1, 2, 3); 答案是10 5. function a() { alert(this); } a.call(null); 答案是window 第二十一部分，S.O.L.I.D五大原则之接口隔离原则ISP没看懂，基本不用看 第二十二部分，S.O.L.I.D五大原则之依赖倒置原则DIP]稍微看懂了，估计是因为java看多了，ioc，基本不用看 第二十三部分，JavaScript与DOM（上）——也适用于新手最重要的是Element, Text, Document。 Element节点在页面里展示的是一个元素，所以如果你有段落元素(&lt;p&gt;)，你可以通过这个DOM节点来访问。 Text节点在页面里展示的所有文本相关的元素，所以如果你的段落有文本在里面的话，你可以直接通过DOM的Text节点来访问这个文本 Document节点代表是整个文档，它是DOM的根节点。 nodeType类型，1是元素，2是属性，3是text节点，详细的type类型可以通过此地址： Node.ELEMENT_NODE == 1 Node.ATTRIBUTE_NODE == 2 Node.TEXT_NODE == 3 Node.CDATA_SECTION_NODE == 4 Node.ENTITY_REFERENCE_NODE == 5 Node.ENTITY_NODE == 6 Node.PROCESSING_INSTRUCTION_NODE == 7 Node.COMMENT_NODE == 8 Node.DOCUMENT_NODE == 9 Node.DOCUMENT_TYPE_NODE == 10 Node.DOCUMENT_FRAGMENT_NODE == 11 Node.NOTATION_NODE == 12 第二十四部分，JavaScript与DOM（下）node节点的2种类型，一种是元素节点，一种是text节点，上一章节已经列出了所有的节点类型，这两种需要我们现在特别注意。创建元素可以通过createElement方法，而创建text节点可以使用createTextNode，相应代码如下： 正如我们上章所说的，DOM和JavaScript语言是2个单独的东西，浏览器事件是DOM API的一部分，而不是JavaScript的一部分。 ‘mouseover’ – 鼠标移动到某元素上的时候触发mouseover事件。 ‘mouseout’ – 鼠标从某元素离开的时候触发mouseout事件。 ‘mousemove’ – 鼠标在某元素上移动但未离开的时候触发mousemove事件。 ‘change’ – 控件失去input焦点的时候触发该事件（或者值被改变的时候）。 ‘load’ – 页面加载完毕（包括内容、图片、frame、object）的时候触发该事件。 ‘resize’ – 页面大小改变的时候触发该事件（例如浏览器缩放）。 ‘scroll’ – 页面滚动的时候触发该事件。 ‘unload’ – 从页面或frame删除所有内容的时候触发该事件（例如离开一个页面）。 严格来说，有2中不同的模型：W3C模型和微软模型，除IE之外W3C模型支持所有的现代浏览器，而微软模型只支持IE 使用W3C模型的代码如下： // 格式：target.addEventListener( type, function, useCapture ); // 例子: var myIntro = document.getElementById(&apos;intro&apos;); myIntro.addEventListener(&apos;click&apos;, introClick, false); 使用IE模型的代码如下： // 格式: target.attachEvent ( &apos;on&apos; + type, function ); // 例子: var myIntro = document.getElementById(&apos;intro&apos;); myIntro.attachEvent(&apos;onclick&apos;, introClick); 一个非常重要的内容是Event对象，当事件发生的时候出发某个函数，该Event对象将自动在函数内可用，该对象包含了很多事件触发时候的信息，但IE却没有这么实现，而是自己实现的，IE浏览器是通过全局对象window下的event属性来包含这些信息 例如当你想取消默认的行为的时候你可以使用Event对象里的preventDefault()方法，但IE里不得不使用对象的returnValue属性值来控制 事件冒泡，就是事件触发的时候通过DOM向上冒泡，首先要知道不是所有的事件都有冒泡。事件在一个目标元素上触发的时候，该事件将触发一一触发祖先节点元素，直到最顶层的元素： 如图所示，如果a连接被点击，触发触发连接的click事件，然后触发p的click事件，以此再触发div和body的click事件。顺序不变，而且不一定是在同时触发的。 举例来说，如果你有一个很多行的大表格，在每个&lt;tr&gt;上绑定点击事件是个非常危险的想法，因为性能是个大问题。流行的做法是使用事件委托。事件委托描述的是将事件绑定在容器元素上，然后通过判断点击的target子元素的类型来触发相应的事件。 事件委托依赖于事件冒泡，如果事件冒泡到table之前被禁用的话，那上面的代码就无法工作了。 经典的事件处理模型，微软的冒泡，以及网景的捕获模型，w3c的两者兼容，网上例子很多，去看解释","path":"2017/06/13/tomdashu2/"},{"title":"汤姆大叔的深入理解JavaScript读后感一（1——16节）","text":"今天要分享的内容是tom大叔的JavaScript系列的读书观后感第一部分，编写高质量JavaScript代码的基本要点内容不多，但是作为从头规范开始，值得遵循，现在看来，才更能明白里面的道理。总结一下： 1. 避免全局变量，为啥？自己去看，以及隐式全局变量的副作用，那怎么办？命名空间 2. 推荐单一的单var形式，如 var a = 1,b = 2,myobject = {};形式 3. for循环，预存缓存变量，for-in遍历对象用hasOwnProperty，去掉原型链的属性 4. 避免使用eval，记住该咒语“eval()是魔鬼”，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免 5. 编码规范，缩进，空格，花括号，分号 6. 命名函数，啥时候大写，啥时候小写，推荐驼峰命名 7. 关于注解，通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。 第二部分，揭秘命名函数表达式总结如下： 1. 什么是申明函数？ 2. 什么是表达式函数？ 3. 什么是函数语句？ 4. 什么是命名函数？ 5. 主要是区别的地方，很细微，然后又很多浏览器的怪异行为，坑比较多 6. 还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式 7. 后面的部分，如果第一次看，肯定看不懂，是啥意思，建议先忽略掉 第三部分，全面解析Module模式总结如下： 1. 正常的module模式，缺点就是，每次都必须new，每个实例都是单独的 12345678910111213var Calculator = function (eq) &#123; //这里可以声明私有成员 var eqCtl = document.getElementById(eq); return &#123; // 暴露公开的成员 add: function (x, y) &#123; var val = x + y; eqCtl.innerHTML = val; &#125; &#125;; &#125;; 2. 改进过后的，利用函数自执行，可以直接使用 1234567891011121314var blogModule = (function () &#123; var my = &#123;&#125;, privateName = &quot;博客园&quot;; function privateAddTopic(data) &#123; // 这里是内部处理代码 &#125; my.Name = privateName; my.AddTopic = function (data) &#123; privateAddTopic(data); &#125;; return my;&#125; ()); 3. 改進松耦合 123456var blogModule = (function (my) &#123; // 添加一些功能 return my;&#125; (blogModule || &#123;&#125;)); 4. 克隆 12345678910111213141516 var blogModule = (function (old) &#123; var my = &#123;&#125;, key; for (key in old) &#123; if (old.hasOwnProperty(key)) &#123; my[key] = old[key]; &#125; &#125; var oldAddPhotoMethod = old.AddPhoto; my.AddPhoto = function () &#123; // 克隆以后，进行了重写，当然也可以继续调用oldAddPhotoMethod &#125;; return my;&#125; (blogModule)); 5. 子模块 123456blogModule.CommentSubModule = (function () &#123; var my = &#123;&#125;; // ... return my;&#125; ()); 第四部分，立即调用的函数表达式1. 自動執行 (function () { /* code */ } ()); // 推荐使用这个 2. (function () { /* code */ })(); // 但是这个也是可以用的，括號 3.在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。 4. 闭包的经典例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 错误的： var elems = document.getElementsByTagName(&apos;a&apos;); for (var i = 0; i &lt; elems.length; i++) &#123; elems[i].addEventListener(&apos;click&apos;, function (e) &#123; e.preventDefault(); alert(&apos;I am link #&apos; + i); &#125;, &apos;false&apos;); &#125;正确的：会锁住对应的index的值，虽然i最后为10，但是之前的值，已经记录好了var elems = document.getElementsByTagName(&apos;a&apos;);for (var i = 0; i &lt; elems.length; i++) &#123; (function (lockedInIndex) &#123; elems[i].addEventListener(&apos;click&apos;, function (e) &#123; e.preventDefault(); alert(&apos;I am link #&apos; + lockedInIndex); &#125;, &apos;false&apos;); &#125;)(i);&#125; ``` 5. 不管什么是自执行，还是立即调用，不用分那么清楚，只需知道立即执行一次匿名函数就够了 # 第五部分，强大的原型和原型链 1. 原型关键词，prototype 2. 说白了，原型就是一个对象 3. 通过hasOwnProperty，区分属性从哪里来的 4. 默认还有一个原型的链条，一直到Object.prototype为止 5. 所有的对象都有&quot;[[prototype]]&quot;属性（通过__proto__访问），该属性对应对象的原型 6. 所有的函数对象都有&quot;prototype&quot;属性，该属性的值会被赋值给该函数创建的对象的&quot;__proto__&quot;属性 7. 所有的原型对象都有&quot;constructor&quot;属性，该属性对应创建所有指向该原型的实例的构造函数 8. 函数对象和原型对象通过&quot;prototype&quot;和&quot;constructor&quot;属性进行相互关联 9. 最简单易懂的看下边 [原型链介绍](https://www.talkingcoder.com/article/6360227501704156372)# 第六七八部分，S.O.L.I.D五大原则之单一职责SRP（忽略） The Single Responsibility Principle（单一职责SRP） The Open/Closed Principle（开闭原则OCP） The Liskov Substitution Principle（里氏替换原则LSP） The Interface Segregation Principle（接口分离原则ISP） The Dependency Inversion Principle（依赖反转原则DIP）# 第九部分，根本没有“JSON对象”这回事！ 简单的说 1. // 这是JSON字符串 var foo = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;; 2. // 这是对象字面量 var bar = &#123; &quot;prop&quot;: &quot;val&quot; &#125;; 3. // 将字符串反序列化成json对象 var my_obj = JSON.parse( foo ); 4. json对象，和字面量对象，明显的区别，前者必须有引号，后者去掉引号可以 var bar = &#123; prop: &quot;val&quot; &#125;;合法的 # 第十部分，JavaScript核心（晋级高手必读篇） 1. 执行上下文栈(Execution Context Stack)，有三种类型：global, function和eval。 2. 执行上下文(Execution Context)，变量对象(variable object)，this指针(this value)，作用域链(scope chain) 函数表达式[function expression]（而不是函数声明[function declarations，区别请参考本系列第2章]）是不包含在VO[variable object]里面的 3. 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 4. 当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了 5. 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。 6. 这表示，在我们去搜寻__parent__之前，首先会去__proto__的链接中。 7. 闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。 8. 在ECMAScript中，是不可以给this赋值的，因为，还是那句话，this不是变量。 9. this是执行上下文环境的一个属性，而不是某个变量对象的属性# 第十一部分，执行上下文（Execution Contexts）可以把调用上下文作为第二个参数传递给eval。那么，如果这个上下文存在，就有可能影响“私有”(有人喜欢这样叫它)变量。# 第十二部分，变量对象（Variable Object）```angularjs if (true) &#123; var a = 1; &#125; else &#123; var b = 2; &#125; alert(a); // 1 alert(b); // undefined,不是b没有声明，而是b的值是undefined 变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。12345678910111213a = 10;alert(window.a); // 10 alert(delete a); // true alert(window.a); // undefined var b = 20;alert(window.b); // 20 alert(delete b); // false alert(window.b); // still 20 但是这个规则在有个上下文里不起走样，那就是eval上下文，变量没有{DontDelete}特性。 第十三部分，This? Yes,this!1，一个函数上下文中确定this值的通用规则如下： 2. 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。 3. 我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的this值，答案在于引用类型（type Reference）不同的中间值。 4. 标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名 5. (function () { alert(this); // null =&gt; global })(); 6. 函数调用中手动设置this，apply,call 7. 作为构造器调用的函数中的this,都将this的值设置为新创建的对象。 8. 引用类型和this为null,默认为golbal 第十四部分，作用域链(Scope Chain)1. 函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。 2. 注意这重要的一点－－[[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁 3. 闭包理解 var x = 10; function foo() { alert(x); } (function () { var x = 20; foo(); // 10, but not 20 })(); [[Scope]]包括在函数内创建的词法作用域（父变量对象）。当函数进一步激活时，在变量对象的这个词法链（静态的存储于创建时）中，来自较高作用域的变量将被搜寻。 此外，这个例子也清晰的表明，一个函数（这个例子中为从函数“foo”返回的匿名函数）的[[scope]]持续存在，即使是在函数创建的作用域已经完成之后。 4. 通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象 5. 源于ECMAScript 的原型特性。如果一个属性在对象中没有直接找到，查询将在原型链中继续。即常说的二维链查找。（1）作用域链环节；（2）每个作用域链－－深入到原型链环节 6. 全局和eval上下文中的作用域链,全局上下文的作用域链仅包含全局对象 7. 在代码执行阶段有两个声明能修改作用域链。这就是with声明和catch语句。它们添加到作用域链的最前端，对象须在这些声明中出现的标识符中查找。 第十五部分，函数（Functions）1。 只有这2个位置可以声明函数，也就是说:不可能在表达式位置或一个代码块中定义它。 2. // 函数可以在如下地方声明： // 1) 直接在全局上下文中 function globalFD() { // 2) 或者在一个函数的函数体内 function innerFD() {} } 3. 相当一部分问题出现了，我们为什么需要函数表达式？答案很明显——在表达式中使用它们，”不会污染”变量对象。最简单的例子是将一个函数作为参数传递给其它函数。 4. 这种模式中，初始化的FE的名称通常被忽略： (function () { // 初始化作用域 })(); 5. ”为何在函数创建后的立即调用中必须用圆括号来包围它？”，答案就是：表达式句子的限制就是这样的。 6. function () { ... }(); // 即便有名称 function foo() { ... }(); 如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。 第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。 第十六部分，闭包（Closures）var z = 10; function foo() { alert(z); } foo(); // 10 – 使用静态和动态作用域的时候 (function () { var z = 20; foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域 })(); // 将foo作为参数的时候是一样的 (function (funArg) { var z = 30; funArg(); // 10 – 静态作用域, 30 – 动态作用域 })(foo); 上述描述的就是两类funarg问题 —— 取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。 为了解决上述问题，就引入了 闭包的概念。 这里说明一下，开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，甚至理解成只有匿名函数才能是闭包。 再说一下，因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。 ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）： 闭包还有另外一个非常重要的应用 —— 延迟调用： var a = 10; setTimeout(function () { alert(a); // 10, after one second }, 1000); 还可以创建封装的作用域来隐藏辅助对象： var foo = {}; // 初始化 (function (object) { var x = 10; object.getX = function _getX() { return x; }; })(foo); alert(foo.getX()); // 获得闭包 &quot;x&quot; – 10","path":"2017/06/12/tomdashu/"},{"title":"adSense试试看","text":"今天要分享的内容是adSense 最近老大让弄广告既然自己都在做这个东西，何不在自己的网站里面引进一下，试试看，效果如何 后续再加统计Output Colorizer暂时留个坑 高考终于结束了，老弟也解放了，(｡･∀･)ﾉﾞ嗨的和同学聚会去了晚上又能回家了，离得近，就是这点方便为天下的学子庆祝一下，一图胜前言 恭喜表哥要订婚了","path":"2017/06/09/adSense/"},{"title":"写在高考前，对弟弟的祝福","text":"随便写点记得十年前，这个时候，已经进入了考场，转眼，十年都过去了 有首歌叫十年确实，十年之前，你不认识我，我不认识你 每个人都需要经历这个坎谁都替代不了，可能有些人比较顺利的迈过去了，而有些人很难 这个事情，说重要，它确认重要，足以改变人的一生命运 不重要，也不过是一场考试而已，在人生的旅途中，只是一个章节而已 我只想说，认真对待，在正确的年龄做正确的事情，就足矣了 不过结果如何，你老爸老妈，都在等你回家吃饭 老哥，也祝福你，十年寒窗，加油，上图吧 米娜桑~高考加油！ (ﾟ▽ﾟ) by KoinKoni on pixiv","path":"2017/06/06/before-gaokao/"},{"title":"关于log4j的使用说明","text":"今天要分享的内容是log4j的使用。每个系统都有日志记录，而多数都是用的log4j，以为会配置了，懂了，发现还是有些细节的问题，要问，说不上来 先来直接看配置吧和测试用例吧jar包的依赖123456&lt;!-- log4j support --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; log4j.properties文件如下，放在你的web的resource下面，推荐maven标准工程来123456789101112131415161718192021222324252627### 设置###log4j.rootLogger = DEBUG,stdout,D,Elog4j.logger.A=DEBUG, stdoutlog4j.logger.A.B=INFO, stdout ### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=D://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = D://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUGlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=D://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =D://logs/error.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = ERRORlog4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 测试用例123456789101112131415161718192021222324252627282930import org.apache.log4j.Logger;/** * @author hankun * @create 2017-06-06 18:32 */public class log4jTtest &#123; private static Logger logger = Logger.getLogger(log4jTtest.class); private static Logger loggerA = Logger.getLogger(&quot;A&quot;); private static Logger loggerA_B = Logger.getLogger(&quot;A.B&quot;); /** * @param args */ public static void main(String[] args) &#123; // 记录debug级别的信息 logger.debug(&quot;This is debug message.&quot;); // 记录info级别的信息 logger.info(&quot;This is info message.&quot;); // 记录error级别的信息 logger.error(&quot;This is error message.&quot;); loggerA_B.info(&quot;repeat three times in console&quot;); loggerA.info(&quot;repeat two times in console&quot;); logger.info(&quot;repeat one times in console&quot;); &#125;&#125; 注意上面的输出结果，你知道输出啥内容，则，就真正理解了123456789101112131415161718[DEBUG] 2017-06-06 19:05:03,477 method:log4jTtest.main(log4jTtest.java:18)This is debug message.[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:20)This is info message.[ERROR] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:22)This is error message.[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)repeat three times in console[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)repeat three times in console[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)repeat three times in console[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:25)repeat two times in console[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:25)repeat two times in console[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:26)repeat one times in console 问题如下 前面的三个输出，不用解释，都明白为啥 为啥那个loggerA_B，输出了三次，而loggerA输出了二次，logger输出了一次？ log4j几个重要的概念 logger组件 简单的说，它就是决定了应用程序中，哪些代码哪些地方，有可能输出日志 这也就是为什么，每个类里面上来，就是，logger的初始化，它决定了这个类有资格输出日志 首先Log4J中总是存在一个rootLogger，即使没有显示配置也是存在的，并且默认输出级别为DEBUG。 Log4J中的层次是用’.’来分隔的，如log4j.logger.com.example.test，这里并不是说log4j.logger后面一定是具体的包名乃至类名， appender组件 输出地，也就是你的日志想输出到哪里，把上面的logger里面的日志 再简单点，就是输出到控制台和文件里面，也就是上面的配置stdout和D和E 这个需要和下面的这个概念配合 输出控制的概念 Log4j默认把日志信息分为五个等级 all&lt;debug &lt; info &lt; warn &lt; error &lt; fatal&lt;off 只有大于设置的级别，才会打印日志，低于则忽略 log4j.appender.threshold=ERROR，这种配置用于控制，一个appender的输出级别 继承的概念 log4j.rootLogger=DEBUG, Console log4j.logger.A=DEBUG, Console log4j.logger.A.B=INFO, Console A.B继承A，再继承最顶级的root Log4j是根据Log的名字来判断继承关系的 来解释一下，上面的输出结果 首先是，debug，info和error前三个日志输出，它们的logger是log4jTtest.class初始化的，继承根logger，因此就是debug级别，同时因为还有D和E的两个appender，所以你在d盘可以看到，有一个info的文件还有一个error的文件，这个日志输出没问题 然后就是解释那重复的三个，因为loggerA_B，它是根据A.B这个参数初始化的，是有继承的，满足A.B的info级别的日志输出，必然满足A的logger的日志输出，当然还有默认的根输出，因此三次 而那个两次的，它的logger是loggerA，继承于根，因此，info的时候，它本身输出一次，根也输出一次，就是两次了。 最后一个，用的是默认的根，当然，只能输出一次了 问题来了，怎么避免重复，因为继承父的logger？log4j.additivity.A.B=false logger A.B的日志仅会输出到自己Console中，不会继承任何父logger的appender。 就加上面的这句，就解决了问题 总结之前反反复复看了很多次，关于日志log4j的配置，每次看完以为会了，但是到了项目里面，总是不知道，自己有时候打印的日志到底跑哪里去了，或者去哪里看？总结其原因就是，对于细节没有掌握理解到位，比如就是这个logger的概念，如果你真正的明白了，就知道了 谁能产生日志？logger 日志放哪里？appender 什么级别的日志才会输出？日志级别 他们是相互独立的组件，单独配置，又是相互配合，一起使用的，n*m的这种概念 因此上面的配置文件，一个logger可以对应多个appender，而appender之间又是彼此独立的。","path":"2017/06/06/log4j/"},{"title":"六一儿童节快乐（补）","text":"昨天这么重要的节日忘记了今天专程来补图，喵帕斯~祝天下所有的大小朋友，儿童节快乐~","path":"2017/06/02/liuyi/"},{"title":"java中的pattern和matcher的用法","text":"今天要分享的内容是java语言中的pattern和matcher的用法java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern和Matcher Pattern 一个Pattern是一个正则表达式经编译后的表现模式。Matcher 一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。 先理解捕获组的概念12345678捕获组可以通过从左到右计算其开括号来编号，编号是从1 开始的。例如，在表达式 ((A)(B(C)))中，存在四个这样的组：1 ((A)(B(C)))2 (A)3 (B(C))4 (C)组0始终代表整个表达式。 详解Pattern类Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, Java代码示例: Pattern p=Pattern.compile(&quot;\\\\w+&quot;); p.pattern();//返回 \\w+ 详解Matcher类说了这么多,终于轮到Matcher类登场了,Pattern.matcher(CharSequence input)返回一个Matcher对象. Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例. Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持. Java代码示例: Pattern p=Pattern.compile(&quot;\\\\d+&quot;); Matcher m=p.matcher(&quot;22bb23&quot;); m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 注意看下面这个例子，pattern方法返回的值12345678910111213import java.util.regex.Matcher;import java.util.regex.Pattern;public class StringPattern &#123; public static void main(String[] args) &#123; Pattern p = Pattern.compile(&quot;\\\\d+&quot;); Matcher m = p.matcher(&quot;22bb23&quot;); Pattern pattern = m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 String pattern1 = pattern.pattern(); System.out.println(pattern1);//\\d+ &#125;&#125; Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()区别 Matcher类提供三个匹配操作方法,三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回falsematches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true find()对字符串进行匹配,匹配到的字符串可以在任何位置. Mathcer.start()/ Matcher.end()/ Matcher.group() 当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息. start()返回匹配到的子字符串在字符串中的索引位置. end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. group()返回匹配到的子字符串 12345678910111213141516171819import java.util.regex.Matcher;import java.util.regex.Pattern;public class StringPattern &#123; public static void main(String[] args) &#123; Pattern p=Pattern.compile(&quot;([a-z]+)(\\\\d+)&quot;); Matcher m=p.matcher(&quot;aaa2223bb&quot;); System.out.println(m.find()); //匹配aaa2223 System.out.println(m.groupCount()); //返回2,因为有2组 System.out.println(m.start(1)); //返回0 返回第一组匹配到的子字符串在字符串中的索引号 System.out.println(m.start(2)); //返回3 System.out.println(m.end(1)); //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. System.out.println(m.end(2)); //返回7 System.out.println(m.group(1)); //返回aaa,返回第一组匹配到的子字符串 System.out.println(m.group(2));; //返回2223,返回第二组匹配到的子字符串 &#125;&#125; find比较特殊，特此说明find public boolean find()尝试查找与该模式匹配的输入序列的下一个子序列。此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。 返回：当且仅当输入序列的子序列匹配此匹配器的模式时才返回 true。 因此有下面这种，循环find的用法12345678910111213import java.util.regex.Matcher;import java.util.regex.Pattern;public class StringPattern &#123; public static void main(String[] args) &#123; Pattern p=Pattern.compile(&quot;\\\\d+&quot;); Matcher m=p.matcher(&quot;我的QQ是:123 我的电话是:456 我的邮箱是:789@aaa.com&quot;); while(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 最后强调现在大家应该知道,每次执行匹配操作后start(),end(),group()三个方法的值都会改变,改变成匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息.注意:只有当匹配操作成功,才可以使用start(),end(),group()三个方法,否则会抛出java.lang.IllegalStateException,也就是当matches(),lookingAt(),find()其中任意一个方法返回true时,才可以使用.","path":"2017/06/02/java-match/"},{"title":"java中的replace和replaceAll的区别","text":"今天要分享的内容是java语言中的replace的用法 测试用例如下123456789101112131415public class StringReplaceTest &#123; public static void main(String[] args) &#123; String src = new String(\"aabbccdd333ee\"); System.out.println(src.replace(\"3\", \"f\")); System.out.println(src.replace('3', 'f')); System.out.println(src.replaceAll(\"\\\\d\", \"ff\")); System.out.println(src.replaceAll(\"a\", \"f\")); System.out.println(src.replaceFirst(\"\\\\d\", \"ff\")); System.out.println(src.replaceFirst(\"4\", \"ff\")); System.out.println(\"\\\\\"); System.out.println(\"\\\\\\\\\"); &#125;&#125; 输出结果 aabbccddfffee aabbccddffffffee ffbbccdd333ee aabbccddff33ee aabbccdd333ee \\ \\\\ 解释如下 replace的参数是char和CharSequence,即可以支持字符的替换,也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串); replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\\d”, “*”)把一个字符串所有的数字字符都换成星号; 相同点是都是全部替换,即把源字符串中的某一字符或字符串全部换成指定的字符或字符串,如果只想替换第一次出现的,可以使用 replaceFirst(),这个方法也是基于规则表达式的替换,但与replaceAll()不同的是,只替换第一次出现的字符串;另外,如果replaceAll()和replaceFirst()所用的参数据不是基于规则表达式的,则与replace()替换字符串的效果是一样的,即这两者也支持字符串的操作;还有一点注意:执行了替换操作后,源字符串的内容是没有发生改变的 最后讲一个关于斜杠的问题&apos;\\&apos;在java中是一个转义字符，所以需要用两个代表一个。例如System.out.println( &quot;\\\\&quot; ) ;只打印出一个&quot;\\&quot;。但是&apos;\\&apos;也是正则表达式中的转义字符（replaceAll 的参数就是正则表达式），需要用两个代表一个。所以：\\\\\\\\被java转换成\\\\,\\\\又被正则表达式转换成\\。 CODE: \\\\\\\\ Java: \\\\ Regex: \\","path":"2017/06/02/java-replace/"},{"title":"redis学习系列之——介绍篇","text":"今天要分享的内容是redis背景介绍 Redis 背景介绍 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。Redis 数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 String（字符串）string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。 注意：一个键最大能存储512MB。 Hash（哈希）Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 每个 hash 可以存储 232 - 1 键值对（40多亿）。 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 Set（集合）Redis的Set是string类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。","path":"2017/06/02/redis-jieshao/"},{"title":"redis学习系列之——安装篇","text":"今天要分享的内容是redis的使用安装篇这里主要分享，Windows下的安装使用，其他的系统，自己找 Window 下安装下载地址：https://github.com/MSOpenTech/redis/releases。Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。 安装步骤二，启动服务器打开一个 cmd 窗口 使用cd命令切换目录到 C:\\redis 运行 redis-server.exe redis.windows.conf 。如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面： 安装步骤三，启动客户端这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。设置键值对 set myKey abc取出键值对 get myKey 顺便附带一个菜鸟redis教程传送门 最后强调一句，默认的数据是存储在db0里面","path":"2017/06/01/redis-anzhuang/"},{"title":"博客文章模板","text":"这是摘要,外部显示图片 今天要分享的内容是。。。xxxxxxxxxx 第一部分正常说明，要干什么，再加一个链接按钮 xxx. 第二部分 第一点好处 第一点好处 第一点好处 第三部分tab键，直接加底色，正常说明，顺便加一个加黑。 好黑啊 第四部分想要加一张图片 第五部分想要加原生代码1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=\"utf-8\" /&gt; &lt;meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=\"text/css\"&gt; body&#123;font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;&#125; ul&#123;list-style: none;&#125; img&#123;border:none;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=\"text-xxl\"&gt;Hello world!&lt;/h1&gt; &lt;p class=\"text-green\"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 第六部分相要加个高亮执行命令：npm install marked","path":"2017/05/27/article/"},{"title":"图片测试","text":"这里面没内容 只是为了测试一下，图片能否直接展示在首页里面","path":"2017/05/27/picTest/"},{"title":"新博客版本升级","text":"为啥升级博客？ 之前做完了ppt分享后，威哥触动了我，重新维护改造一下，以后记录工作生活点滴，今天庆祝复活了 升级说明 主要有以下的改造 外观改造，去掉了那些无用的评论，统计，因为实际确实没啥人关注 改完了外观清晰，简单的界面，去掉了那些标签功能，只要是方便自己看 另外增加了，关于我的部分，按照个人的喜好进行了改编 对了，明天就要端午节放假啦，提前来张图庆祝一下，请收下 端午節ちまき by 兔姬 on pixiv","path":"2017/05/27/newBlog/"},{"title":"Markdown","text":"目录 (Table of Contents) [TOCM] [TOC] Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6Heading 1 link Heading linkHeading 2 link Heading linkHeading 3 link Heading linkHeading 4 link Heading link Heading link Heading linkHeading 5 link Heading linkHeading 6 link Heading link标题（用底线的形式）Heading (underline)This is an H1This is an H2字符效果和横线等 删除线 删除线（开启识别HTML标签时）斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links普通链接 普通链接带标题 直接链接：https://github.com 锚点链接 mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 123456789101112131415161718192021222324252627282930313233343536function test() &#123; console.log(\"Hello world!\");&#125; (function()&#123; var box = function() &#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log('box.init()'); return this; &#125;, add : function(str) &#123; alert(\"add\", str); return this; &#125;, remove : function(str) &#123; alert(\"remove\", str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add(\"jQuery\").remove(\"jQuery\"); HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=\"utf-8\" /&gt; &lt;meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=\"text/css\"&gt; body&#123;font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;&#125; ul&#123;list-style: none;&#125; img&#123;border:none;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=\"text-xxl\"&gt;Hello world!&lt;/h1&gt; &lt;p class=\"text-green\"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片 ImagesImage: Follow your heart. 图为：厦门白城沙滩 图片加链接 (Image + Link)： 图为：李健首张专辑《似水流年》封面 列表 Lists无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list [x] GFM task list 1 [x] GFM task list 2 [ ] GFM task list 3 [ ] GFM task list 3-1 [ ] GFM task list 3-2 [ ] GFM task list 3-3 [ ] GFM task list 4 [ ] GFM task list 4-1 [ ] GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&ordm;C &quot; &apos; [========] Emoji表情 :smiley: Blockquotes :star: GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: [x] :smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:; [x] list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [x] [ ] :smiley: this is a complete item :smiley:; [ ] []this is an incomplete item test link :fa-star: @pandao; [ ] [ ]this is an incomplete item :fa-star: :fa-gear:; [ ] :smiley: this is an incomplete item test link :fa-star: :fa-gear:; [ ] :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape*literal asterisks* [========] 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x &gt; y$$ $$(\\sqrt{3x-1}+(1+x)^2)$$ $$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$ 多行公式： 12345\\displaystyle\\left( \\sum\\_&#123;k=1&#125;^n a\\_k b\\_k \\right)^2\\leq\\left( \\sum\\_&#123;k=1&#125;^n a\\_k^2 \\right)\\left( \\sum\\_&#123;k=1&#125;^n b\\_k^2 \\right) 123456789\\displaystyle \\frac&#123;1&#125;&#123; \\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123; \\frac25 \\pi&#125;&#125; = 1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123; 1+\\frac&#123;e^&#123;-6\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\cdots&#125; &#125; &#125; &#125; 123f(x) = \\int_&#123;-\\infty&#125;^\\infty \\hat f(\\xi)\\,e^&#123;2 \\pi i \\xi x&#125; \\,d\\xi 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op [========] 绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says Hello Note right of China: China thinks\\nabout it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! End","path":"2017/05/26/markdown/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2017/05/26/hello-world/"}]}