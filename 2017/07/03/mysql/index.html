<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于mysql中select子查询 · 闻道</title><meta name="description" content="关于mysql中select子查询 - 韩坤"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9654808400771776",
    enable_page_level_ads: true
});</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject'] = r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-100775956-1', 'auto');
ga('send', 'pageview');
</script><link rel="search" type="application/opensearchdescription+xml" href="http://ghohankawk.github.io/atom.xml" title="闻道"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">闻道</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives/" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about.html" target="_self" class="li component-nav-item"><p>关于我</p></a><a href="https://ghohankawk.gitbooks.io/book/content/" target="_blank" class="li component-nav-item"><p>个人书籍</p></a><ul class="shortcut-icons"><a href="http://blog.csdn.net/ghohankawk" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">关于mysql中select子查询</h1><div class="post-info">Jul 3, 2017</div><div class="post-content"><h1 id="今天要分享的内容是mysql的select子查询"><a href="#今天要分享的内容是mysql的select子查询" class="headerlink" title="今天要分享的内容是mysql的select子查询"></a>今天要分享的内容是mysql的select子查询</h1><p>一直记得凯哥，半年前说过的一句话，原来你不知道，子查询啊，其实，我知道是又这么一回事<br>但是，具体又说不上来，大概就是那种，一看就知道，但是你有不完全知道的类型吧<br>现在在写hive语法的时候又碰到了，那么就好好总结一次吧。 </p>
<h1 id="子查询定义"><a href="#子查询定义" class="headerlink" title="子查询定义"></a>子查询定义</h1><p>在一个表表达中可以调用另一个表表达式，这个被调用的表表达式叫做子查询（subquery），<br>那么也称作子选择（subselect）或内嵌选择（inner select）。<br>子查询的结果传递给调用它的表达式继续处理。</p>
<p>说人话就是，一个sql语句，出现了2个以上的select关键词，这个清晰了吧？</p>
<h1 id="子查询分类1"><a href="#子查询分类1" class="headerlink" title="子查询分类1"></a>子查询分类1</h1><pre><code>1*1   标量子查询：返回的结果集是一个标量集合，一行一列，也就是一个标量值。可以指定一个标量表达式的任何地方，都可以用一个标量子查询。
1*n   行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。
n*1   列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）。
n*n   表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。
     就这么四类
</code></pre><p>从定义上讲，</p>
<p>每个标量子查询也是一个行子查询和一个列子查询，反之则不是；</p>
<p>每个行子查询和列子查询也是一个表子查询，反之也不是。</p>
<h1 id="子查询分类2"><a href="#子查询分类2" class="headerlink" title="子查询分类2"></a>子查询分类2</h1><pre><code>where型子查询：（把内层查询结果当作外层查询的比较条件）
定义：where型的子查询就是把内层查询的结果当作外层查询的条件。

from型子查询：（把内层的查询结果供外层再次查询）
定义：from子查询就是把子查询的结果(内存里的一张表)当作一张临时表，然后再对它进行处理。

exists型子查询：（把外层查询结果拿到内层，看内层的查询是否成立）
定义：exists子查询就是对外层表进行循环，再对内表进行内层查询。和in ()差不多，但是它们还是有区别的。主要是看两个张表大小差的程度。若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）；
</code></pre><p>其实，光这么说，很难明白的，因为你都没写过，根本理解不了，尤其是exisit子查询</p>
<h1 id="使用子查询原则"><a href="#使用子查询原则" class="headerlink" title="使用子查询原则"></a>使用子查询原则</h1><pre><code>1.一个子查询必须放在圆括号中。
2.将子查询放在比较条件的右边以增加可读性。
子查询不包含 ORDER BY 子句。对一个 SELECT 语句只能用一个 ORDER BY 子句，并且如果指定了它就必须放在主 SELECT 语句的最后。
3.在子查询中可以使用两种比较条件：单行运算符(&gt;, =, &gt;=, &lt;, &lt;&gt;, &lt;=) 和多行运算符(IN, ANY, ALL)。
</code></pre><h1 id="where型子查询"><a href="#where型子查询" class="headerlink" title="where型子查询"></a>where型子查询</h1><p>select * from a where a.xx = (select xx from b where b.xx=”xx”),这种感觉</p>
<h1 id="from型子查询"><a href="#from型子查询" class="headerlink" title="from型子查询"></a>from型子查询</h1><p>select <em> from (select </em> from a) as aa,这种感觉</p>
<h1 id="exists型子查询"><a href="#exists型子查询" class="headerlink" title="exists型子查询"></a>exists型子查询</h1><p>因为上面那两种，子查询，很明了简单，就不谈了，主要说下面的</p>
<p>尽量表达清楚</p>
<pre><code>EXISTS关键字表示存在。使用EXISTS关键字时，内层查询语句不返回查询的记录，
而是返回一个真假值，如果内层查询语句查询到满足条件的记录，
只要子查询中至少返回一个值，则EXISTS语句的值就为True。
就返回true，否则返回false。当返回的值为true时，外层查询语句将进行查询，
否则不进行查询。NOT EXISTS刚好与之相反。exists的用法和in ()差不多，
但是它们还是有区别的。主要是看两个张表大小差的程度。
若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）;
</code></pre><p>看上面这段话的，解释，保证，你看了，也不知道在说啥，其实说的稍微有点问题</p>
<p>正确的解释，应该是，上面的当然也没错</p>
<p>exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条 件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false</p>
<p>就是循环外层的查询结果，然后带进去，查看条件是否成立，不成立丢弃，成立留下</p>
<pre><code>select * from user where exists (select 1);
这句话，就会输出，user表中全部的人，因为后面的条件，对于每个人都成立
</code></pre><p>select * from user where userId in (1, 2, 3);</p>
<p>这样的in查询，等价于</p>
<p>select * from user where userId = 1 or userId = 2 or userId = 3;</p>
<p>因此，要求in后面的表是小表，才不至于，很大的表，循环多次</p>
<h1 id="记住一句话，谁的表大就用谁的索引"><a href="#记住一句话，谁的表大就用谁的索引" class="headerlink" title="记住一句话，谁的表大就用谁的索引"></a>记住一句话，谁的表大就用谁的索引</h1><p>下面来考虑exists和in的性能</p>
<pre><code>考虑如下SQL语句

1: select * from A where exists (select * from B where B.id = A.id);

2: select * from A where A.id in (select id from B);
</code></pre><p> 查询1.可以转化以下伪代码，便于理解</p>
<pre><code> for ($i = 0; $i &lt; count(A); $i++) {

 　　$a = get_record(A, $i); #从A表逐条获取记录

 　　if (B.id = $a[id]) #如果子条件成立

 　　　　$result[] = $a;

 }

return $result;
</code></pre><p> 大概就是这么个意思，其实可以看到,查询1主要是用到了B表的索引，A表如何对查询的效率影响应该不大<br> 也就是说，表B越大就越能利用到索引的优势</p>
<p> 而假设B表是小表的所有id为1,2,3,查询2可以转换为</p>
<pre><code>select * from A where A.id = 1 or A.id = 2 or A.id = 3;
</code></pre><p> 这个好理解了，这里主要是用到了A的索引，B表如何对查询影响不大<br>  也就是说，表A越大就越能利用到索引的优势</p>
<p> 下面再看not exists 和 not in</p>
<pre><code>1. select * from A where not exists (select * from B where B.id = A.id);

2. select * from A where A.id not in (select id from B);
</code></pre><p>看查询1，还是和上面一样，用了B的索引</p>
<p>而对于查询2，可以转化成如下语句</p>
<pre><code>select * from A where A.id != 1 and A.id != 2 and A.id != 3;
</code></pre><p>可以知道not in是个范围查询，这种!=的范围查询无法使用任何索引,等于说A表的每条记录，都要在B表里遍历一次，查看B表里是否存在这条记录</p>
<p>not in 和not exists如果查询语句</p>
<p>使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。<br>所以无论那个表大，用not exists都比not in要快。          </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先大概说一下，这个子查询吧，其实，mysql还有很多的细节地方要注意，有时间再说说，自己的理解吧</p>
<p>补充一句，昨天和妹子出去吃饭，今天居然就感冒生病了，心疼啊/(ㄒoㄒ)/~~，怪我了</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2017/07/05/java-synchronized/" class="prev">上一篇</a><a href="/2017/06/29/linux-grep/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 <a href="http://ghohankawk.github.io">韩坤</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>