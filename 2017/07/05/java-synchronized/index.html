<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于java中的synchronized的用法 · 闻道</title><meta name="description" content="关于java中的synchronized的用法 - 韩坤"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9654808400771776",
    enable_page_level_ads: true
});</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject'] = r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-100775956-1', 'auto');
ga('send', 'pageview');
</script><link rel="search" type="application/opensearchdescription+xml" href="http://ghohankawk.github.io/atom.xml" title="闻道"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">闻道</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives/" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about.html" target="_self" class="li component-nav-item"><p>关于我</p></a><a href="https://ghohankawk.gitbooks.io/book/content/" target="_blank" class="li component-nav-item"><p>个人书籍</p></a><ul class="shortcut-icons"><a href="http://blog.csdn.net/ghohankawk" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">关于java中的synchronized的用法</h1><div class="post-info">Jul 5, 2017</div><div class="post-content"><h1 id="今天要分享的内容是synchronized"><a href="#今天要分享的内容是synchronized" class="headerlink" title="今天要分享的内容是synchronized"></a>今天要分享的内容是synchronized</h1><p>这个地方也是，说起来知道同步的用法，但是并不是多么的清楚，和上面的那篇mysql的子查询一样，看到代码中很多这样写的。<br>就顺便研究总结一下： </p>
<h1 id="修饰对象有几种-能出现在什么地方"><a href="#修饰对象有几种-能出现在什么地方" class="headerlink" title="修饰对象有几种(能出现在什么地方)"></a>修饰对象有几种(能出现在什么地方)</h1><ul>
<li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分， 作用的对象是这个类的所有对象。</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法， 作用的对象是调用这个方法的对象；</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法， 作用的对象是这个类的所有对象；</li>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码， 作用的对象是调用这个代码块的对象；</li>
</ul>
<h1 id="2个锁"><a href="#2个锁" class="headerlink" title="2个锁"></a>2个锁</h1><p>上面的4种情况，核心也就是，2个锁</p>
<ol>
<li>对象锁，修饰一个类的成员方法和代码块，就是这种情况，他强调的是创建对象，调用对象本身，比如，a对象和b对象完全不同</li>
<li>类锁（其实没有，类比概念，好理解），也就是修饰类，和静态的方法，这两种的同步是一样的，他们强调的是类class这个对象的锁，因此a对象和b对象拥有同样的锁，所以是相同的</li>
</ol>
<h1 id="废话不多说，直接上例子吧"><a href="#废话不多说，直接上例子吧" class="headerlink" title="废话不多说，直接上例子吧"></a>废话不多说，直接上例子吧</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-07-05 19:52</div><div class="line"> */</div><div class="line">public class synchronizedTest &#123;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰方法块</div><div class="line">     */</div><div class="line">    static class SyncMehtodBlock implements Runnable &#123;</div><div class="line">        private static int count;</div><div class="line"></div><div class="line">        public SyncMehtodBlock() &#123;</div><div class="line">            count = 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtodBlock&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtodBlock&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰方法</div><div class="line">     */</div><div class="line">    static class SyncMehtod extends Thread &#123;</div><div class="line">        private synchronizedTest syn;</div><div class="line"></div><div class="line">        public SyncMehtod(synchronizedTest synchronizedTest) &#123;</div><div class="line">            this.syn = synchronizedTest;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            syn.test();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void test() &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtod&quot;);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtod&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰静态方法</div><div class="line">     */</div><div class="line">    static class SyncStaticMehtod extends Thread &#123;</div><div class="line"></div><div class="line">        public synchronized static void staticTest() &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;开始..SyncStaticMehtod&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;结束..SyncStaticMehtod&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            staticTest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰类</div><div class="line">     */</div><div class="line">    static class SyncClass extends Thread &#123;</div><div class="line"></div><div class="line">        public void classTest() &#123;</div><div class="line">            synchronized (synchronizedTest.class) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;开始..SyncClass&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;结束..SyncClass&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            classTest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //情况1，修饰方法块</div><div class="line">        SyncMehtodBlock syncMehtodBlock = new SyncMehtodBlock();</div><div class="line">        Thread thread1 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock1&quot;);</div><div class="line">        Thread thread2 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock2&quot;);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况2，修饰方法</div><div class="line">        synchronizedTest syn = new synchronizedTest();</div><div class="line">        SyncMehtod syncMehtod3 = new SyncMehtod(syn);</div><div class="line">        SyncMehtod syncMehtod4 = new SyncMehtod(syn);</div><div class="line">        syncMehtod3.start();</div><div class="line">        syncMehtod4.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况3，修饰静态方法</div><div class="line">        SyncStaticMehtod a = new SyncStaticMehtod();</div><div class="line">        SyncStaticMehtod b = new SyncStaticMehtod();</div><div class="line">        Thread thread5 = new Thread(a, &quot;SyncStaticMehtod1&quot;);</div><div class="line">        Thread thread6 = new Thread(b, &quot;SyncStaticMehtod2&quot;);</div><div class="line">        thread5.start();</div><div class="line">        thread6.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况4，修饰类</div><div class="line">        SyncClass c = new SyncClass();</div><div class="line">        SyncClass d = new SyncClass();</div><div class="line">        Thread thread7 = new Thread(c, &quot;SyncClass1&quot;);</div><div class="line">        Thread thread8 = new Thread(d, &quot;SyncClass2&quot;);</div><div class="line">        thread7.start();</div><div class="line">        thread8.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我写了一个，模拟4种情况的例子，报每个类型都包含进去了</p>
<p>请注意观察里面的synchronized的关键位置，出现的情况，以及每个测试例子，是如何新建的，区分不同</p>
<p>所有的例子，都是具有同步的，因为竞争，比如，a先开始，那么a先结束，然后才能轮到b开始，b结束</p>
<p>好好，体会里面的内容</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。</li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
</ol>
<p>我觉得别人说的，这三句话，已经说的很明白不过，我也就不加自己的体会了</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2017/07/03/mysql/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 <a href="http://ghohankawk.github.io">韩坤</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>