<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="ghohank">
    
    
    
    
    
    
    <title>闻道</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: '加载中';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-100775956-1', 'auto');
    ga('send', 'pageview');
</script>

    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-9654808400771776",
            enable_page_level_ads: true
        });
    </script>
</head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about.html">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        <li>
            <a class="scroll-to-top">回到顶部</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" http://punchline.asia/wp-content/uploads/2016/10/%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B10%E6%9C%8814%E8%87%B316%E6%97%A5%E5%8F%A3%E7%A2%91%E5%A0%B4%EF%BC%8C10%E6%9C%8821%E6%97%A5%E5%85%A8%E5%8F%B0%E6%AD%A3%E5%BC%8F%E4%B8%8A%E6%98%A0100403.jpg " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">二次元の世界</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('http://punchline.asia/wp-content/uploads/2016/10/%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B10%E6%9C%8814%E8%87%B316%E6%97%A5%E5%8F%A3%E7%A2%91%E5%A0%B4%EF%BC%8C10%E6%9C%8821%E6%97%A5%E5%85%A8%E5%8F%B0%E6%AD%A3%E5%BC%8F%E4%B8%8A%E6%98%A0100403.jpg');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('http://punchline.asia/wp-content/uploads/2016/10/%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B10%E6%9C%8814%E8%87%B316%E6%97%A5%E5%8F%A3%E7%A2%91%E5%A0%B4%EF%BC%8C10%E6%9C%8821%E6%97%A5%E5%85%A8%E5%8F%B0%E6%AD%A3%E5%BC%8F%E4%B8%8A%E6%98%A0100403.jpg');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">二次元の世界</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '1920',
                height: '1080'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-gitbook的自己定制的写书模板">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/15/gitbook/">gitbook的自己定制的写书模板</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-15
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是gitbook的使用"><a href="#今天要分享的内容是gitbook的使用" class="headerlink" title="今天要分享的内容是gitbook的使用"></a>今天要分享的内容是gitbook的使用</h1><p>今天本来在看js的commonJs，amd，cmd，umd这些模块内容</p>
<p>看着，看着，突然看到了gitbook的内容</p>
<p>发现很多人，都用这个，写一个类似，api或者一些列的书籍用</p>
<p>所以下午花时间，开始弄这个</p>
<p>开始也是啥不懂，慢慢总算摸清门路了</p>
<p>其实还是不会用</p>
<p>本来去掉了让人讨厌的，最下面的那个published with gitbook那个连接</p>
<p>结果和github同步了一次代码，全部丢失了</p>
<p>后来实在，是不想弄了，就留着吧，懒得弄啦</p>
<p>最后的解决方案就是</p>
<p>用gitbook的那个编辑器，直接写文章将来</p>
<p>或者像这个博客一样，全部用markdown的语法，自己写</p>
<p>显得的高大上</p>
<p>去我的github上面，可以找一下，gitbook的写作模板</p>
<p>顺便把首页的测试页链接，改为自己的书籍，将来补充一下，争取写成一个书单，或者笔记之类的东西吧</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63304470_cc053618b7d92f9794e300a7d7e3f1e2" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63304470" target="_blank">美少女で 閲覧数を取れなきゃ 幼女を出せ</a> by <a href="https://www.pixiv.net/member.php?id=1147470" target="_blank">ぎぇうす</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/15/gitbook/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-汤姆大叔的深入理解JavaScript读后感四（完结篇）">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/14/tomdashu4/">汤姆大叔的深入理解JavaScript读后感四（完结篇）</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-14
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇</h1><p>花了三天的时间，终于把大叔的博客，JavaScript系列看了一遍</p>
<p>收获颇丰啊，不愧是经典，一下子很多零散的东西就串联了起来</p>
<p>先简单说一下背景吧<br>大概是13年左右的时候，就有人推荐大叔的博客，那时第一个原因是水平不够，第二个没时间，总之就是没看过，但是听说过了</p>
<p>后来，陆续又自己完完整整的学了一遍JavaScript，就是大叔最后一篇文章里面推荐的，初级书籍，那边三圣经之一，看完了总觉得学会了，其实<br>看完就忘记了，不过有个大概印象了</p>
<p>再后来，毕业工作了，去做java后端了，因为有时候需要写简单的前端页面，就开始到了真正的实际应用，开始写的过程，才慢慢对一些概念，有了自己的认识<br>但是，还是停留在最初级的阶段，写个function函数，那种，变量都是全局的，简单的子自行，this分不清的水平</p>
<p>慢慢的，有个机会让我去定制前端组件，那个时候，自己开始模仿的写一些组件，但是都是初级的，不过正是因为这个原因，才有了一次写js的锻炼，有了这种训练<br>以前很多的概念开始，慢慢用上了</p>
<p>大概自认为，初级JavaScript之上，又达不到中级的水平吧，</p>
<p>大叔的系列，看完一遍，对我来说的收获</p>
<ol>
<li>弄清了function函数这个概念，实在太多了，比如，命名，申明，函数语句，匿名，自执行，等等</li>
<li>弄清了括号的用法和含义，（），这个东西，看着简单，不懂的话，还是不理解</li>
<li>弄清了闭包这个概念，这个概念每次问，都知道有那么回事，但是又具体说不上来，那种一直认为懂，其实还是不懂的概念，这篇文章终于弄清楚了</li>
<li>弄清了prototype这个玩意，就是所谓的原型的概念，只有函数才有</li>
<li>弄清了对象创建的方法，比如，function的，还有new，含有构造函数，等等</li>
<li>弄清了执行上下文，也就是作用域的概念，这个东西，没有比大叔写的更清楚的了</li>
<li>还有就是，有了上面的概念之后的，this指针，老生常谈了，网上的其他文章，只能写一些为啥，例子分析之类的，开始写不错，大叔这种原理分析，<br>各个场景的用法，这次就不怕分不清this了</li>
<li>当然了，还有，call，apply这些的用法</li>
<li>当然了，又温故知新了一遍设计模式，主要是理解了代码为啥有时候那么写的思路</li>
<li>有了上面总总的概念之后，看起完整的代码，才不会卡主分析里面任何一个细节<br>因为基础知识已经具备了，看起来，才能理解了</li>
</ol>
<p>说了这么多，其实呢，这个东西，不实践还是没有用的，如果没有当初自己一个人开始写js的那段实践，我估计也不会有今天<br>看博客那么大的收获</p>
<p>不敢说，都看懂了大叔所写，但是我心中的疑惑对js的，那些模糊的概念突然清晰了起来</p>
<p>书不是读一遍，就完事的，等以后有时间，再返回头看看，可能有更多的收获</p>
<p>上图</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63061360_9db8a1ab6d0b20a09558ed43369658e4" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63061360" target="_blank">まとめ</a> by <a href="https://www.pixiv.net/member.php?id=15385092" target="_blank">郁</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/14/tomdashu4/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-汤姆大叔的深入理解JavaScript读后感三（设计模式篇）">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/13/tomdashu3/">汤姆大叔的深入理解JavaScript读后感三（设计模式篇）</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-13
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感3"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感3" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感3"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感3</h1><p>挑选大叔里面，个人自己喜欢的设计模式实现</p>
<h1 id="第二十五部分，设计模式之单例模式"><a href="#第二十五部分，设计模式之单例模式" class="headerlink" title="第二十五部分，设计模式之单例模式"></a>第二十五部分，设计模式之单例模式</h1><p>在传统开发工程师眼里，单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 缓存的实例</div><div class="line">    var instance = this;</div><div class="line"></div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    // 重写构造函数</div><div class="line">    Universe = function () &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">uni.bang = &quot;123&quot;;</div><div class="line">console.log(uni === uni2); // true</div><div class="line">console.log(uni2.bang); // 123</div></pre></td></tr></table></figure>
<p>这个设计模式，简单明了，通过this进行缓存，剩下了去判断不存在的麻烦</p>
<h1 id="第二十六部分，设计模式之构造函数模式"><a href="#第二十六部分，设计模式之构造函数模式" class="headerlink" title="第二十六部分，设计模式之构造函数模式"></a>第二十六部分，设计模式之构造函数模式</h1><p>构造函数用于创建特定类型的对象——不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype</div><div class="line">主要是用来避免重写定义原型prototype对象</div><div class="line">*/</div><div class="line">Car.prototype.output= function () &#123;</div><div class="line">    return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var tom = new Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">var dudu = new Car(&quot;Dudu&quot;, 2010, 5000);</div><div class="line"></div><div class="line">console.log(tom.output());</div><div class="line">console.log(dudu.output());</div></pre></td></tr></table></figure></p>
<h1 id="第二十七部分，设计模式之建造者模式"><a href="#第二十七部分，设计模式之建造者模式" class="headerlink" title="第二十七部分，设计模式之建造者模式"></a>第二十七部分，设计模式之建造者模式</h1><p>建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">    // 使用ID来请求数据，然后返回数据.</div><div class="line">    asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function (resp) &#123;</div><div class="line">        // callback调用 response</div><div class="line">        callback(resp.responseText);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var el = document.querySelector(&apos;#test&apos;);</div><div class="line">el.addEventListener(&apos;click&apos;, getBeerByIdBridge, false);</div><div class="line"></div><div class="line">function getBeerByIdBridge(e) &#123;</div><div class="line">    getBeerById(this.id, function (beer) &#123;</div><div class="line">        console.log(&apos;Requested Beer: &apos; + beer);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。<br>也就是说，上面的函数中，getBeerById函数是稳定的，写了一个构建过程，而具体的构建细节由另外一个回调函数决定</p>
<p>其实，我觉得，这个部分，不属于java里面的建造者模式，更是一种模板模式，可能个人理解不同吧，反正大叔的意思，就是这种样子</p>
<h1 id="第二十八部分，设计模式之工厂模式"><a href="#第二十八部分，设计模式之工厂模式" class="headerlink" title="第二十八部分，设计模式之工厂模式"></a>第二十八部分，设计模式之工厂模式</h1><pre><code>什么时候使用工厂模式

以下几种情景下工厂模式特别有用：

对象的构建十分复杂
需要依赖具体环境创建不同实例
处理大量具有相同属性的小对象
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var productManager = &#123;&#125;;</div><div class="line"></div><div class="line">productManager.createProductA = function () &#123;</div><div class="line">    console.log(&apos;ProductA&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">productManager.createProductB = function () &#123;</div><div class="line">    console.log(&apos;ProductB&apos;);</div><div class="line">&#125;</div><div class="line">        </div><div class="line">productManager.factory = function (typeType) &#123;</div><div class="line">    return new productManager[typeType];</div><div class="line">&#125;</div><div class="line"></div><div class="line">productManager.factory(&quot;createProductA&quot;);</div></pre></td></tr></table></figure>
<p>一句话，就是根据不同的类型，调用不同的子类，进行实例化一个对象</p>
<h1 id="第二十九部分，设计模式之装饰者模式"><a href="#第二十九部分，设计模式之装饰者模式" class="headerlink" title="第二十九部分，设计模式之装饰者模式"></a>第二十九部分，设计模式之装饰者模式</h1><p>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var tree = &#123;&#125;;</div><div class="line">tree.decorate = function () &#123;</div><div class="line">    console.log(&apos;Make sure the tree won\&apos;t fall&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.getDecorator = function (deco) &#123;</div><div class="line">    tree[deco].prototype = this;</div><div class="line">    return new tree[deco];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.RedBalls = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.RedBalls.prototype.decorate(); // 第7步：先执行原型（这时候是Angel了）的decorate方法</div><div class="line">        console.log(&apos;Put on some red balls&apos;); // 第8步 再输出 red</div><div class="line">        // 将这2步作为RedBalls的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.BlueBalls = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.BlueBalls.prototype.decorate(); // 第1步：先执行原型的decorate方法，也就是tree.decorate()</div><div class="line">        console.log(&apos;Add blue balls&apos;); // 第2步 再输出blue</div><div class="line">        // 将这2步作为BlueBalls的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.Angel = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.Angel.prototype.decorate(); // 第4步：先执行原型（这时候是BlueBalls了）的decorate方法</div><div class="line">        console.log(&apos;An angel on the top&apos;); // 第5步 再输出angel</div><div class="line">        // 将这2步作为Angel的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree = tree.getDecorator(&apos;BlueBalls&apos;); // 第3步：将BlueBalls对象赋给tree，这时候父原型里的getDecorator依然可用</div><div class="line">tree = tree.getDecorator(&apos;Angel&apos;); // 第6步：将Angel对象赋给tree，这时候父原型的父原型里的getDecorator依然可用</div><div class="line">tree = tree.getDecorator(&apos;RedBalls&apos;); // 第9步：将RedBalls对象赋给tree</div><div class="line"></div><div class="line">tree.decorate(); // 第10步：执行RedBalls对象的decorate方法</div></pre></td></tr></table></figure>
<p>这段代码，主要是在于，<br>        tree.getDecorator 这段函数设计精妙<br>        他让tree接受一个新的函数，而每次都用这个新函数去替代之前的函数，并且同时让原型指向前一个，实现了一个<br>        继承关系，比如A-》B-》C，最开始tree是A，然后，放入一个，就变成B，之后为C</p>
<h1 id="第三十部分，设计模式之外观模式"><a href="#第三十部分，设计模式之外观模式" class="headerlink" title="第三十部分，设计模式之外观模式"></a>第三十部分，设计模式之外观模式</h1><p>外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。</p>
<p>外观模式经常被用于JavaScript类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。</p>
<p>外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点 外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var addMyEvent = function (el, ev, fn) &#123;</div><div class="line">    if (el.addEventListener) &#123;</div><div class="line">        el.addEventListener(ev, fn, false);</div><div class="line">    &#125; else if (el.attachEvent) &#123;</div><div class="line">        el.attachEvent(&apos;on&apos; + ev, fn);</div><div class="line">    &#125; else &#123;</div><div class="line">        el[&apos;on&apos; + ev] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;; </div><div class="line">再来一个简单的例子，说白了就是用一个接口封装其它的接口：</div><div class="line">var mobileEvent = &#123;</div><div class="line">    // ...</div><div class="line">    stop: function (e) &#123;</div><div class="line">        e.preventDefault();</div><div class="line">        e.stopPropagation();</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="第三十一部分，设计模式之代理模式"><a href="#第三十一部分，设计模式之代理模式" class="headerlink" title="第三十一部分，设计模式之代理模式"></a>第三十一部分，设计模式之代理模式</h1><p>代理，顾名思义就是帮助别人做事<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 先声明美女对象</div><div class="line">var girl = function (name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 这是dudu</div><div class="line">var dudu = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        alert(&quot;Hi &quot; + girl.name + &quot;, dudu送你一个礼物：&quot; + gift);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 大叔是代理</div><div class="line">var proxyTom = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        (new dudu(girl)).sendGift(gift); // 替dudu送花咯</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">说的简单一点，就是代理新类，必须包括被代理的对象，也就是可以主动new</div></pre></td></tr></table></figure></p>
<h1 id="第三十二部分，设计模式之观察者模式"><a href="#第三十二部分，设计模式之观察者模式" class="headerlink" title="第三十二部分，设计模式之观察者模式"></a>第三十二部分，设计模式之观察者模式</h1><p>观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">jQuery版本</div><div class="line"></div><div class="line">根据jQuery1.7版新增的on/off功能，我们也可以定义jQuery版的观察者：</div><div class="line"></div><div class="line">(function ($) &#123;</div><div class="line"></div><div class="line">    var o = $(&#123;&#125;);</div><div class="line"></div><div class="line">    $.subscribe = function () &#123;</div><div class="line">        o.on.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.unsubscribe = function () &#123;</div><div class="line">        o.off.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.publish = function () &#123;</div><div class="line">        o.trigger.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125; (jQuery));</div></pre></td></tr></table></figure>
<h1 id="第三十三部分，设计模式之策略模式"><a href="#第三十三部分，设计模式之策略模式" class="headerlink" title="第三十三部分，设计模式之策略模式"></a>第三十三部分，设计模式之策略模式</h1><p>策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">正常的模式，缺点就是，下次继续增加case进行判断</div><div class="line">        validator = &#123;</div><div class="line">            validate: function (value, type) &#123;</div><div class="line">                switch (type) &#123;</div><div class="line">                    case &apos;isNonEmpty &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // NonEmpty 验证结果</div><div class="line">                        &#125;</div><div class="line">                    case &apos;isNumber &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // Number 验证结果</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    case &apos;isAlphaNum &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // AlphaNum 验证结果</div><div class="line">                        &#125;</div><div class="line">                    default:</div><div class="line">                        &#123;</div><div class="line">                            return true;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        //  测试</div><div class="line">        alert(validator.validate(&quot;123&quot;, &quot;isNonEmpty&quot;));</div><div class="line"></div><div class="line">策略模式</div><div class="line"></div><div class="line">var validator = &#123;</div><div class="line"></div><div class="line">    // 所有可以的验证规则处理类存放的地方，后面会单独定义</div><div class="line">    types: &#123;&#125;,</div><div class="line"></div><div class="line">    // 验证类型所对应的错误消息</div><div class="line">    messages: [],</div><div class="line"></div><div class="line">    // 当然需要使用的验证类型</div><div class="line">    config: &#123;&#125;,</div><div class="line"></div><div class="line">    // 暴露的公开验证方法</div><div class="line">    // 传入的参数是 key =&gt; value对</div><div class="line">    validate: function (data) &#123;</div><div class="line"></div><div class="line">        var i, msg, type, checker, result_ok;</div><div class="line"></div><div class="line">        // 清空所有的错误信息</div><div class="line">        this.messages = [];</div><div class="line"></div><div class="line">        for (i in data) &#123;</div><div class="line">            if (data.hasOwnProperty(i)) &#123;</div><div class="line"></div><div class="line">                type = this.config[i];  // 根据key查询是否有存在的验证规则</div><div class="line">                checker = this.types[type]; // 获取验证规则的验证类</div><div class="line"></div><div class="line">                if (!type) &#123;</div><div class="line">                    continue; // 如果验证规则不存在，则不处理</div><div class="line">                &#125;</div><div class="line">                if (!checker) &#123; // 如果验证规则类不存在，抛出异常</div><div class="line">                    throw &#123;</div><div class="line">                        name: &quot;ValidationError&quot;,</div><div class="line">                        message: &quot;No handler to validate type &quot; + type</div><div class="line">                    &#125;;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                result_ok = checker.validate(data[i]); // 使用查到到的单个验证类进行验证</div><div class="line">                if (!result_ok) &#123;</div><div class="line">                    msg = &quot;Invalid value for *&quot; + i + &quot;*, &quot; + checker.instructions;</div><div class="line">                    this.messages.push(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return this.hasErrors();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // helper</div><div class="line">    hasErrors: function () &#123;</div><div class="line">        return this.messages.length !== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">然后剩下的工作，就是定义types里存放的各种验证类了，我们这里只举几个例子：</div><div class="line"></div><div class="line">// 验证给定的值是否不为空</div><div class="line">validator.types.isNonEmpty = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return value !== &quot;&quot;;</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值不能为空&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否是数字</div><div class="line">validator.types.isNumber = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !isNaN(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能是合法的数字，例如：1, 3.14 or 2010&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否只是字母或数字</div><div class="line">validator.types.isAlphaNum = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !/[^a-z0-9]/i.test(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能保护字母和数字，不能包含特殊字符&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">以配置替代之前的写死的那种方式，可以理解为开闭原则，不修改之前的代码</div></pre></td></tr></table></figure>
<h1 id="第三十四部分，设计模式之命令模式"><a href="#第三十四部分，设计模式之命令模式" class="headerlink" title="第三十四部分，设计模式之命令模式"></a>第三十四部分，设计模式之命令模式</h1><p>命令模式(Command)的定义是：用于将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理。此外，可以通过调用实现具体函数的对象来解耦命令对象与接收对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$(function () &#123;</div><div class="line"></div><div class="line">    var CarManager = &#123;</div><div class="line"></div><div class="line">        // 请求信息</div><div class="line">        requestInfo: function (model, id) &#123;</div><div class="line">            return &apos;The information for &apos; + model +</div><div class="line">        &apos; with ID &apos; + id + &apos; is foobar&apos;;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        // 购买汽车</div><div class="line">        buyVehicle: function (model, id) &#123;</div><div class="line">            return &apos;You have successfully purchased Item &apos;</div><div class="line">        + id + &apos;, a &apos; + model;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        // 组织view</div><div class="line">        arrangeViewing: function (model, id) &#123;</div><div class="line">            return &apos;You have successfully booked a viewing of &apos;</div><div class="line">        + model + &apos; ( &apos; + id + &apos; ) &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">CarManager.execute = function (command) &#123;</div><div class="line">    return CarManager[command.request](command.model, command.carID);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CarManager.execute(&#123; request: &quot;arrangeViewing&quot;, model: &apos;Ferrari&apos;, carID: &apos;145523&apos; &#125;);</div><div class="line"></div><div class="line">之前可能没明白命令模式，现在看这个例子，就很简单了，</div><div class="line">就是，我不具体的调用函数，而是改成一个命令，通过一个弄命令函数，传入不同的指令，实现方法的调用</div><div class="line">大叔的意思是说，不推荐使用，可以直接调用，就不用这么麻烦，前天是系统不复杂的时候</div></pre></td></tr></table></figure>
<h1 id="第三十五部分，设计模式之迭代器模式"><a href="#第三十五部分，设计模式之迭代器模式" class="headerlink" title="第三十五部分，设计模式之迭代器模式"></a>第三十五部分，设计模式之迭代器模式</h1><p>迭代器模式(Iterator)：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。</p>
<p>迭代器的几个特点是：</p>
<p>访问一个聚合对象的内容而无需暴露它的内部表示。<br>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。<br>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jQuery里一个非常有名的迭代器就是$.each方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：</div><div class="line"></div><div class="line">$.each([&apos;dudu&apos;, &apos;dudu&apos;, &apos;酸奶小妹&apos;, &apos;那个MM&apos;], function (index, value) &#123;</div><div class="line">    console.log(index + &apos;: &apos; + value);</div><div class="line">&#125;);</div><div class="line">//或者</div><div class="line">$(&apos;li&apos;).each(function (index) &#123;</div><div class="line">    console.log(index + &apos;: &apos; + $(this).text());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="第三十六部分，设计模式之中介者模式"><a href="#第三十六部分，设计模式之中介者模式" class="headerlink" title="第三十六部分，设计模式之中介者模式"></a>第三十六部分，设计模式之中介者模式</h1><p>软件开发中，中介者是一个行为设计模式，通过提供一个统一的接口让系统的不同部分进行通信。一般，如果系统有很多子模块需要直接沟通，都要创建一个中央控制点让其各模块通过该中央控制点进行交互。中介者模式可以让这些子模块不需要直接沟通，而达到进行解耦的目的。</p>
<p>打个比方，平时常见的机场交通控制系统，塔台就是中介者，它控制着飞机（子模块）的起飞和降落，因为所有的沟通都是从飞机向塔台汇报来完成的，而不是飞机之前相互沟通。中央控制系统就是该系统的关键，也就是软件设计中扮演的中介者角色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 如下代码是伪代码，请不要过分在意代码</div><div class="line">// 这里app命名空间就相当于扮演中介者的角色</div><div class="line">var app = app || &#123;&#125;;</div><div class="line"> </div><div class="line">// 通过app中介者来进行Ajax请求</div><div class="line">app.sendRequest = function ( options ) &#123;</div><div class="line">    return $.ajax($.extend(&#123;&#125;, options);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 请求URL以后，展示View</div><div class="line">app.populateView = function( url, view )&#123;</div><div class="line">  $.when(app.sendRequest(&#123;url: url, method: &apos;GET&apos;&#125;)</div><div class="line">     .then(function()&#123;</div><div class="line">         //显示内容</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 清空内容</div><div class="line">app.resetView = function( view )&#123;</div><div class="line">   view.html(&apos;&apos;);</div><div class="line">&#125;</div><div class="line">之前没有分清，中介和代理，其实区别是明显，中介，里面参与的是多个人，他共同维护这些人，而且还都彼此认识switch </div><div class="line">而代理，只是简单的处理一个人而已，参与者一</div></pre></td></tr></table></figure>
<p>另外，由于中介者模式把交互复杂性变成了中介者本身的复杂性，所以说中介者对象会比其它任何对象都复杂。</p>
<h1 id="第三十七部分，设计模式之享元模式"><a href="#第三十七部分，设计模式之享元模式" class="headerlink" title="第三十七部分，设计模式之享元模式"></a>第三十七部分，设计模式之享元模式</h1><p>Flyweight中有两个重要概念–内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，而外部信息可以在通过外部删除或者保存。</p>
<p>说白点,就是先捏一个的原始模型，然后随着不同场合和环境,再产生各具特征的具体模型，很显然,在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">var Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability )&#123;</div><div class="line">   this.id = id;</div><div class="line">   this.title = title;</div><div class="line">   this.author = author;</div><div class="line">   this.genre = genre;</div><div class="line">   this.pageCount = pageCount;</div><div class="line">   this.publisherID = publisherID;</div><div class="line">   this.ISBN = ISBN;</div><div class="line">   this.checkoutDate = checkoutDate;</div><div class="line">   this.checkoutMember = checkoutMember;</div><div class="line">   this.dueReturnDate = dueReturnDate;</div><div class="line">   this.availability = availability;</div><div class="line">&#125;;</div><div class="line">Book.prototype = &#123;</div><div class="line">   getTitle:function()&#123;</div><div class="line">       return this.title;</div><div class="line">   &#125;,</div><div class="line">   getAuthor: function()&#123;</div><div class="line">       return this.author;</div><div class="line">   &#125;,</div><div class="line">   getISBN: function()&#123;</div><div class="line">       return this.ISBN;</div><div class="line">   &#125;,</div><div class="line">/*其它get方法在这里就不显示了*/</div><div class="line"></div><div class="line"></div><div class="line">上面这种函数，最大的问题，就是后面的那4个参数，就算是同一本书，时间不一样，都算成是不一样的</div><div class="line">其实，你是想知道，书这个东西，而不是书*变量个，这样内存中有很多没用的例子</div><div class="line"></div><div class="line"></div><div class="line">$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line"> console.log(&apos;You clicked: &apos; + $(this).attr(&apos;id&apos;));</div><div class="line">&#125;);</div><div class="line">// 上面的代码，要避免使用，避免再次对DOM元素进行生成jQuery对象，因为这里可以直接使用DOM元素自身了。</div><div class="line">$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line"> console.log(&apos;You clicked: &apos; + this.id);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">其实，很简单，就是一个排列组合的问题</div><div class="line">比如，创建文件夹来举例吧，你是创建book1到book10,10个文件夹，还是，创建book文件夹，里面放1-10个子文件夹，一个11个文件夹</div><div class="line"></div><div class="line">第一种方案字符串是，5*9+6=51</div><div class="line">第二种方案是4+9+2=15</div><div class="line">这节省空间是明显的，别问啥意思</div></pre></td></tr></table></figure>
<h1 id="第三十八部分，设计模式之职责链模式"><a href="#第三十八部分，设计模式之职责链模式" class="headerlink" title="第三十八部分，设计模式之职责链模式"></a>第三十八部分，设计模式之职责链模式</h1><p>职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p>也就是说，请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。提交请求的对象并不明确知道哪一个对象将会处理它——也就是该请求有一个隐式的接受者（implicit receiver）。根据运行时刻，任一候选者都可以响应相应的请求，候选者的数目是任意的，你可以在运行时刻决定哪些候选者参与到链中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">var NO_TOPIC = -1;</div><div class="line">var Topic;</div><div class="line"></div><div class="line">function Handler(s, t) &#123;</div><div class="line">    this.successor = s || null;</div><div class="line">    this.topic = t || 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Handler.prototype = &#123;</div><div class="line">    handle: function () &#123;</div><div class="line">        if (this.successor) &#123;</div><div class="line">            this.successor.handle()</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    has: function () &#123;</div><div class="line">        return this.topic != NO_TOPIC;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">var app = new Handler(&#123;</div><div class="line">    handle: function () &#123;</div><div class="line">        console.log(&apos;app handle&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;, 3);</div><div class="line"></div><div class="line">var dialog = new Handler(app, 1);</div><div class="line">dialog.handle = function () &#123;</div><div class="line">    console.log(&apos;dialog before ...&apos;)</div><div class="line">    // 这里做具体的处理操作</div><div class="line">    Handler.prototype.handle.call(this); //继续往上走</div><div class="line">    console.log(&apos;dialog after ...&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var button = new Handler(dialog, 2);</div><div class="line">button.handle = function () &#123;</div><div class="line">    console.log(&apos;button before ...&apos;)</div><div class="line">    // 这里做具体的处理操作</div><div class="line">    Handler.prototype.handle.call(this);</div><div class="line">    console.log(&apos;button after ...&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">button.handle();</div><div class="line"></div><div class="line">通过代码的运行结果我们可以看出，如果想先自身处理，然后再调用继任者处理的话，就在末尾执行Handler.prototype.handle.call(this);代码，如果想先处理继任者的代码，就在开头执行Handler.prototype.handle.call(this);代码。</div><div class="line"></div><div class="line">prototype用的好，就得理解this和prototype</div></pre></td></tr></table></figure>
<h1 id="第三十九部分，设计模式之适配器模式"><a href="#第三十九部分，设计模式之适配器模式" class="headerlink" title="第三十九部分，设计模式之适配器模式"></a>第三十九部分，设计模式之适配器模式</h1><p>适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//鸭子</div><div class="line">var Duck = function()&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">Duck.prototype.fly = function()&#123;</div><div class="line">throw new Error(&quot;该方法必须被重写!&quot;);</div><div class="line">&#125;;</div><div class="line">Duck.prototype.quack = function()&#123;</div><div class="line">throw new Error(&quot;该方法必须被重写!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//火鸡</div><div class="line">var Turkey = function()&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">Turkey.prototype.fly = function()&#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;;</div><div class="line">Turkey.prototype.gobble = function()&#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//鸭子</div><div class="line">var MallardDuck = function () &#123;</div><div class="line">    Duck.apply(this);</div><div class="line">&#125;;</div><div class="line">MallardDuck.prototype = new Duck(); //原型是Duck</div><div class="line">MallardDuck.prototype.fly = function () &#123;</div><div class="line">    console.log(&quot;可以飞翔很长的距离!&quot;);</div><div class="line">&#125;;</div><div class="line">MallardDuck.prototype.quack = function () &#123;</div><div class="line">    console.log(&quot;嘎嘎！嘎嘎！&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//火鸡</div><div class="line">var WildTurkey = function () &#123;</div><div class="line">    Turkey.apply(this);</div><div class="line">&#125;;</div><div class="line">WildTurkey.prototype = new Turkey(); //原型是Turkey</div><div class="line">WildTurkey.prototype.fly = function () &#123;</div><div class="line">    console.log(&quot;飞翔的距离貌似有点短!&quot;);</div><div class="line">&#125;;</div><div class="line">WildTurkey.prototype.gobble = function () &#123;</div><div class="line">    console.log(&quot;咯咯！咯咯！&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<pre><code>那合适使用适配器模式好呢？如果有以下情况出现时，建议使用：

使用一个已经存在的对象，但其方法或属性接口不符合你的要求；
你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作；
想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性。
另外，适配器模式和其它几个模式可能容易让人迷惑，这里说一下大概的区别：

适配器和桥接模式虽然类似，但桥接的出发点不同，桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口。
装饰者模式增强了其它对象的功能而同时又不改变它的接口，因此它对应程序的透明性比适配器要好，其结果是装饰者支持递归组合，而纯粹使用适配器则是不可能的。
代理模式在不改变它的接口的条件下，为另外一个对象定义了一个代理。
</code></pre><h1 id="第四十部分，设计模式之组合模式"><a href="#第四十部分，设计模式之组合模式" class="headerlink" title="第四十部分，设计模式之组合模式"></a>第四十部分，设计模式之组合模式</h1><p>组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>常见的场景有asp.net里的控件机制（即control里可以包含子control，可以递归操作、添加、删除子control），类似的还有DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line">var MenuComponent = function () &#123;</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getName = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getDescription = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getPrice = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.isVegetarian = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.print = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.add = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.remove = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getChild = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var MenuItem = function (sName, sDescription, bVegetarian, nPrice) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.bVegetarian = bVegetarian;</div><div class="line">    this.nPrice = nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype = new MenuComponent();</div><div class="line">MenuItem.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getPrice = function () &#123;</div><div class="line">    return this.nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.isVegetarian = function () &#123;</div><div class="line">    return this.bVegetarian;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.print = function () &#123;</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription() + &quot;, &quot; + this.getPrice() + &quot;euros&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var Menu = function (sName, sDescription) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.aMenuComponents = [];</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.createIterator = function () &#123;</div><div class="line">        throw new Error(&quot;This method must be overwritten!&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">Menu.prototype = new MenuComponent();</div><div class="line">Menu.prototype.add = function (oMenuComponent) &#123;</div><div class="line">    // 添加子菜品</div><div class="line">    this.aMenuComponents.push(oMenuComponent);</div><div class="line">&#125;;</div><div class="line">Menu.prototype.remove = function (oMenuComponent) &#123;</div><div class="line">    // 删除子菜品</div><div class="line">    var aMenuItems = [];</div><div class="line">    var nMenuItem = 0;</div><div class="line">    var nLenMenuItems = this.aMenuComponents.length;</div><div class="line">    var oItem = null;</div><div class="line"></div><div class="line">    for (; nMenuItem &lt; nLenMenuItems; ) &#123;</div><div class="line">        oItem = this.aMenuComponents[nMenuItem];</div><div class="line">        if (oItem !== oMenuComponent) &#123;</div><div class="line">            aMenuItems.push(oItem);</div><div class="line">        &#125;</div><div class="line">        nMenuItem = nMenuItem + 1;</div><div class="line">    &#125;</div><div class="line">    this.aMenuComponents = aMenuItems;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getChild = function (nIndex) &#123;</div><div class="line">    //获取指定的子菜品</div><div class="line">    return this.aMenuComponents[nIndex];</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.print = function () &#123;</div><div class="line">    // 打印当前菜品以及所有的子菜品</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription());</div><div class="line">    console.log(&quot;--------------------------------------------&quot;);</div><div class="line"></div><div class="line">    var nMenuComponent = 0;</div><div class="line">    var nLenMenuComponents = this.aMenuComponents.length;</div><div class="line">    var oMenuComponent = null;</div><div class="line"></div><div class="line">    for (; nMenuComponent &lt; nLenMenuComponents; ) &#123;</div><div class="line">        oMenuComponent = this.aMenuComponents[nMenuComponent];</div><div class="line">        oMenuComponent.print();</div><div class="line">        nMenuComponent = nMenuComponent + 1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var DinnerMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">DinnerMenu.prototype = new Menu();</div><div class="line"></div><div class="line">var CafeMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">CafeMenu.prototype = new Menu();</div><div class="line"></div><div class="line">var PancakeHouseMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">PancakeHouseMenu.prototype = new Menu();</div><div class="line"></div><div class="line"></div><div class="line">var Mattress = function (aMenus) &#123;</div><div class="line">    this.aMenus = aMenus;</div><div class="line">&#125;;</div><div class="line">Mattress.prototype.printMenu = function () &#123;</div><div class="line">    this.aMenus.print();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">组合模式，特点就是抽象一个父子公用的类，比如，add，remove这些getChild之类的，必须提供</div></pre></td></tr></table></figure></p>
<h1 id="第四十一部分，设计模式之模板方法"><a href="#第四十一部分，设计模式之模板方法" class="headerlink" title="第四十一部分，设计模式之模板方法"></a>第四十一部分，设计模式之模板方法</h1><p>模板方法（TemplateMethod）定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法是一种代码复用的基本技术，在类库中尤为重要，因为他们提取了类库中的公共行为。模板方法导致一种反向的控制结构，这种结构就是传说中的“好莱坞法则”，即“别找找我们，我们找你</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">var CaffeineBeverage = function () &#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.prepareRecipe = function () &#123;</div><div class="line">    this.boilWater();</div><div class="line">    this.brew();</div><div class="line">    this.pourOnCup();</div><div class="line">    if (this.customerWantsCondiments()) &#123;</div><div class="line">        // 如果可以想加小料，就加上</div><div class="line"> this.addCondiments();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.boilWater = function () &#123;</div><div class="line">    console.log(&quot;将水烧开!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.pourOnCup = function () &#123;</div><div class="line">    console.log(&quot;将饮料到再杯子里!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.brew = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.addCondiments = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">// 默认加上小料</div><div class="line">CaffeineBeverage.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 冲咖啡</div><div class="line">var Coffee = function () &#123;</div><div class="line">    CaffeineBeverage.apply(this);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype = new CaffeineBeverage();</div><div class="line">Coffee.prototype.brew = function () &#123;</div><div class="line">    console.log(&quot;从咖啡机想咖啡倒进去!&quot;);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype.addCondiments = function () &#123;</div><div class="line">    console.log(&quot;添加糖和牛奶&quot;);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return confirm(&quot;你想添加糖和牛奶吗？&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//冲茶叶</div><div class="line">var Tea = function () &#123;</div><div class="line">    CaffeineBeverage.apply(this);</div><div class="line">&#125;;</div><div class="line">Tea.prototype = new CaffeineBeverage();</div><div class="line">Tea.prototype.brew = function () &#123;</div><div class="line">    console.log(&quot;泡茶叶!&quot;);</div><div class="line">&#125;;</div><div class="line">Tea.prototype.addCondiments = function () &#123;</div><div class="line">    console.log(&quot;添加柠檬!&quot;);</div><div class="line">&#125;;</div><div class="line">Tea.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return confirm(&quot;你想添加柠檬嘛？&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>模板方法应用于下列情况：</p>
<p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现<br>各子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复，不同之处分离为新的操作，最后，用一个钓鱼这些新操作的模板方法来替换这些不同的代码<br>控制子类扩展，模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展</p>
<h1 id="第四十二部分，设计模式之原型模式"><a href="#第四十二部分，设计模式之原型模式" class="headerlink" title="第四十二部分，设计模式之原型模式"></a>第四十二部分，设计模式之原型模式</h1><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var vehicle = &#123;</div><div class="line">    getModel: function () &#123;</div><div class="line">        console.log(&apos;车辆的模具是：&apos; + this.model);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var car = Object.create(vehicle, &#123;</div><div class="line">    &apos;id&apos;: &#123;</div><div class="line">        value: MY_GLOBAL.nextId(),</div><div class="line">        enumerable: true // 默认writable:false, configurable:false</div><div class="line"> &#125;,</div><div class="line">    &apos;model&apos;: &#123;</div><div class="line">        value: &apos;福特&apos;,</div><div class="line">        enumerable: true</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">说的简单一点，其实就是特指，JavaScript里面的原型模式</div></pre></td></tr></table></figure>
<h1 id="第四十三部分，设计模式之状态模式"><a href="#第四十三部分，设计模式之状态模式" class="headerlink" title="第四十三部分，设计模式之状态模式"></a>第四十三部分，设计模式之状态模式</h1><p>状态模式（State）允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类。<br>这个地方内容代码太长了<br>我自己理解，总结一下</p>
<ol>
<li>比如有A，B，C三种状态</li>
<li>那么每种状态必须对应了一组动作，比如开和关，那么3*2=6种状态</li>
<li>三种状态，有种转换关系，状态的改变，同样的开，代表的意思不一样</li>
<li>比如顺序，A-》B-》C-》A，那么同样的，动作，开随着状态的改变，意义发生变化<h1 id="第四十四部分，设计模式之桥接模式"><a href="#第四十四部分，设计模式之桥接模式" class="headerlink" title="第四十四部分，设计模式之桥接模式"></a>第四十四部分，设计模式之桥接模式</h1></li>
</ol>
<p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">// 通过ID发送请求，然后返回数据</div><div class="line">asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;</div><div class="line">// callback response</div><div class="line">callback(resp.responseText);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">桥接，看大叔的例子，还真是没懂，回去看了我之前写过的设计模式，才慢慢理解switch </div><div class="line">桥接=代理+策略</div><div class="line">为什么这么说？</div><div class="line">1. jdbc是桥接，怎么用，是不是每次主动输入一个mysql.jdbc这么个字符串？</div><div class="line">2. 代理模式很明白的只代理一个类，内部写死了</div><div class="line">3. 而策略模式，是有一组策略，客户端不需要具体使用了什么策略</div><div class="line">4. 那么桥接，就是你要明确的告诉这个代理，要用哪种策略</div><div class="line">5. 因此，你需要清楚，你是要给谁桥？</div><div class="line">6. 因此上面这个例子，callback，就是你自己传递尽量的，按个策略</div></pre></td></tr></table></figure>
<h1 id="第四十五部分，代码复用模式（避免篇）"><a href="#第四十五部分，代码复用模式（避免篇）" class="headerlink" title="第四十五部分，代码复用模式（避免篇）"></a>第四十五部分，代码复用模式（避免篇）</h1><p>写了6篇，应该让我们避免的模式，那么不要去话时间记忆不要用的，重点在下篇</p>
<h1 id="第四十六部分，代码复用模式（推荐篇）"><a href="#第四十六部分，代码复用模式（推荐篇）" class="headerlink" title="第四十六部分，代码复用模式（推荐篇）"></a>第四十六部分，代码复用模式（推荐篇）</h1><p>只需记住，大叔推荐，让我们记住的模式，就可以了</p>
<pre><code>模式1：原型继承

原型继承是让父对象作为子对象的原型，从而达到继承的目的：
function object(o) {
    function F() {
    }

    F.prototype = o;
    return new F();
}

// 要继承的父对象
var parent = {
    name: &quot;Papa&quot;
};

// 新对象
var child = object(parent);

// 测试
console.log(child.name); // &quot;Papa&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 创建新person
var papa = new Person();
// 继承
var kid = object(papa);
console.log(kid.getName()); // &quot;Adam&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 继承
var kid = object(Person.prototype);
console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的
console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型
记住一句话，prototype是一个对象

function object(o) {
    function F() {
    }

    F.prototype = o;
    return new F();
}

// 要继承的父对象
var parent = {
    name: &quot;Papa&quot;
};

// 新对象
var child = object(parent);

// 测试
console.log(child.name); // &quot;Papa&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 创建新person
var papa = new Person();
// 继承
var kid = object(papa);
console.log(kid.getName()); // &quot;Adam&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 继承
var kid = object(Person.prototype);
console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的
console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型

模式2：复制所有属性进行继承

这种方式的继承就是将父对象里所有的属性都复制到子对象上，一般子对象可以使用父对象的数据。

先来看一个浅拷贝的例子：

/* 浅拷贝 */
function extend(parent, child) {
    var i;
    child = child || {};
    for (i in parent) {
        if (parent.hasOwnProperty(i)) {
            child[i] = parent[i];
        }
    }
    return child;
}

var dad = { name: &quot;Adam&quot; };
var kid = extend(dad);
console.log(kid.name); // &quot;Adam&quot;

var dad = {
    counts: [1, 2, 3],
    reads: { paper: true }
};
var kid = extend(dad);
kid.counts.push(4);
console.log(dad.counts.toString()); // &quot;1,2,3,4&quot;
console.log(dad.reads === kid.reads); // true
代码的最后一行，你可以发现dad和kid的reads是一样的，也就是他们使用的是同一个引用，这也就是浅拷贝带来的问题。


/* 深拷贝 */
function extendDeep(parent, child) {
    var i,
        toStr = Object.prototype.toString,
        astr = &quot;[object Array]&quot;;

    child = child || {};

    for (i in parent) {
        if (parent.hasOwnProperty(i)) {
            if (typeof parent[i] === &apos;object&apos;) {
                child[i] = (toStr.call(parent[i]) === astr) ? [] : {};
                extendDeep(parent[i], child[i]);
            } else {
                child[i] = parent[i];
            }
        }
    }
    return child;
}

var dad = {
    counts: [1, 2, 3],
    reads: { paper: true }
};
var kid = extendDeep(dad);

kid.counts.push(4);
console.log(kid.counts.toString()); // &quot;1,2,3,4&quot;
console.log(dad.counts.toString()); // &quot;1,2,3&quot;

console.log(dad.reads === kid.reads); // false
kid.reads.paper = false;

这个地方就是厉害在，上面的递归那部分，当包含复合部分就会重新递归调用一次 


模式3：混合（mix-in）

混入就是将一个对象的一个或多个（或全部）属性（或方法）复制到另外一个对象，我们举一个例子：

function mix() {
    var arg, prop, child = {};
    for (arg = 0; arg &lt; arguments.length; arg += 1) {
        for (prop in arguments[arg]) {
            if (arguments[arg].hasOwnProperty(prop)) {
                child[prop] = arguments[arg][prop];
            }
        }
    }
    return child;
}

var cake = mix(
                { eggs: 2, large: true },
                { butter: 1, salted: true },
                { flour: &apos;3 cups&apos; },
                { sugar: &apos;sure!&apos; }
                );

console.dir(cake);


模式4：借用方法

一个对象借用另外一个对象的一个或两个方法，而这两个对象之间不会有什么直接联系。不用多解释，直接用代码解释吧：

var one = {
    name: &apos;object&apos;,
    say: function (greet) {
        return greet + &apos;, &apos; + this.name;
    }
};

// 测试
console.log(one.say(&apos;hi&apos;)); // &quot;hi, object&quot;

var two = {
    name: &apos;another object&apos;
};

console.log(one.say.apply(two, [&apos;hello&apos;])); // &quot;hello, another object&quot;

// 将say赋值给一个变量，this将指向到全局变量
var say = one.say;
console.log(say(&apos;hoho&apos;)); // &quot;hoho, undefined&quot;

// 传入一个回调函数callback
var yetanother = {
    name: &apos;Yet another object&apos;,
    method: function (callback) {
        return callback(&apos;Hola&apos;);
    }
};
console.log(yetanother.method(one.say)); // &quot;Holla, undefined&quot;

function bind(o, m) {
    return function () {
        return m.apply(o, [].slice.call(arguments));
    };
}

var twosay = bind(two, one.say);
console.log(twosay(&apos;yo&apos;)); // &quot;yo, another object&quot;


// ECMAScript 5给Function.prototype添加了一个bind()方法，以便很容易使用apply()和call()。

if (typeof Function.prototype.bind === &apos;undefined&apos;) {
    Function.prototype.bind = function (thisArg) {
        var fn = this,
slice = Array.prototype.slice,
args = slice.call(arguments, 1);
        return function () {
            return fn.apply(thisArg, args.concat(slice.call(arguments)));
        };
    };
}

var twosay2 = one.say.bind(two);
console.log(twosay2(&apos;Bonjour&apos;)); // &quot;Bonjour, another object&quot;

var twosay3 = one.say.bind(two, &apos;Enchanté&apos;);
console.log(twosay3()); // &quot;Enchanté, another object&quot;
</code></pre><h1 id="第四十七部分，对象创建模式（上篇）"><a href="#第四十七部分，对象创建模式（上篇）" class="headerlink" title="第四十七部分，对象创建模式（上篇）"></a>第四十七部分，对象创建模式（上篇）</h1><pre><code>模式1：命名空间（namespace）

命名空间可以减少全局命名所需的数量，避免命名冲突或过度。一般我们在进行对象层级定义的时候，经常是这样的：

var app = app || {};
app.moduleA = app.moduleA || {};

// 更简洁的方式
var MYAPP = MYAPP || {};


模式2：定义依赖

有时候你的一个模块或者函数可能要引用第三方的一些模块或者工具，这时候最好将这些依赖模块在刚开始的时候就定义好，以便以后可以很方便地替换掉。

var myFunction = function () {
    // 依赖模块
    var event = YAHOO.util.Event,
        dom = YAHOO.util.dom;

    // 其它函数后面的代码里使用局部变量event和dom
};

};
模式3：私有属性和私有方法

JavaScript本书不提供特定的语法来支持私有属性和私有方法，但是我们可以通过闭包来实现，代码如下：


function Gadget() {
    // 私有对象
    var name = &apos;iPod&apos;;
    // 公有函数
    this.getName = function () {
        return name;
    };
}

模式4：Revelation模式

也是关于隐藏私有方法的模式，和《深入理解JavaScript系列（3）：全面解析Module模式》里的Module模式有点类似，但是不是return的方式，而是在外部先声明一个变量，然后在内部给变量赋值公有方法。代码如下：

var myarray;

(function () {
    var astr = &quot;[object Array]&quot;,
        toString = Object.prototype.toString;

    function isArray(a) {
        return toString.call(a) === astr;
    }

    function indexOf(haystack, needle) {
        var i = 0,
            max = haystack.length;
        for (; i &lt; max; i += 1) {
            if (haystack[i] === needle) {
                return i;
            }
        }
        return -1;
    }

    //通过赋值的方式，将上面所有的细节都隐藏了
    myarray = {
        isArray: isArray,
        indexOf: indexOf,
        inArray: indexOf
    };
} ());

模式5：链模式

链模式可以你连续可以调用一个对象的方法，比如obj.add(1).remove(2).delete(4).add(2)这样的形式，其实现思路非常简单，就是将this原样返回。代码如下：

var obj = {
    value: 1,
    increment: function () {
        this.value += 1;
        return this;
    },
    add: function (v) {
        this.value += v;
        return this;
    },
    shout: function () {
        console.log(this.value);
    }
};
</code></pre><h1 id="第四十八部分，对象创建模式（下篇）"><a href="#第四十八部分，对象创建模式（下篇）" class="headerlink" title="第四十八部分，对象创建模式（下篇）"></a>第四十八部分，对象创建模式（下篇）</h1><pre><code>模式6：函数语法糖

函数语法糖是为一个对象快速添加方法（函数）的扩展，这个主要是利用prototype的特性，代码比较简单，我们先来看一下实现代码：

if (typeof Function.prototype.method !== &quot;function&quot;) {
    Function.prototype.method = function (name, implementation) {
        this.prototype[name] = implementation;
        return this;
    };
}
模式7：对象常量

对象常量是在一个对象提供set,get,ifDefined各种方法的体现，而且对于set的方法只会保留最先设置的对象，后期再设置都是无效的，已达到别人无法重载的目的。实现代码如下：

var constant = (function () {
    var constants = {},
        ownProp = Object.prototype.hasOwnProperty,
    // 只允许设置这三种类型的值
        allowed = {
            string: 1,
            number: 1,
            boolean: 1
        },


模式8：沙盒模式

沙盒（Sandbox）模式即时为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个Sandbox里有3个方法event,dom,ajax，在调用其中2个组成一个环境的话，和调用三个组成的环境完全没有干扰。

模式9：静态成员

静态成员（Static Members）只是一个函数或对象提供的静态属性，可分为私有的和公有的，就像C#或Java里的public static和private static一样。

我们先来看一下公有成员，公有成员非常简单，我们平时声明的方法，函数都是公有的，比如：

// 构造函数
var Gadget = function () {
};

// 公有静态方法
Gadget.isShiny = function () {
    return &quot;you bet&quot;;
};

// 原型上添加的正常方法
Gadget.prototype.setPrice = function (price) {
    this.price = price;
};

// 调用静态方法
console.log(Gadget.isShiny()); // &quot;you bet&quot;

// 创建实例，然后调用方法
var iphone = new Gadget();
iphone.setPrice(500);


而私有静态成员，我们可以利用其闭包特性去实现，以下是两种实现方式。

第一种实现方式：

var Gadget = (function () {
    // 静态变量/属性
    var counter = 0;

    // 闭包返回构造函数的新实现
    return function () {
        console.log(counter += 1);
    };
} ()); // 立即执行

var g1 = new Gadget(); // logs 1
var g2 = new Gadget(); // logs 2
var g3 = new Gadget(); // logs 3
</code></pre><h1 id="第四十九部分，Function模式（上篇）"><a href="#第四十九部分，Function模式（上篇）" class="headerlink" title="第四十九部分，Function模式（上篇）"></a>第四十九部分，Function模式（上篇）</h1><pre><code>回调函数

在JavaScript中，当一个函数A作为另外一个函数B的其中一个参数时，则函数A称为回调函数，即A可以在函数B的周期内执行（开始、中间、结束时均可）。


配置对象

如果一个函数（或方法）的参数只有一个参数，并且参数为对象字面量，我们则称这种模式为配置对象模式。例如，如下代码：

var conf = {
    username:&quot;shichuan&quot;,
    first:&quot;Chuan&quot;,
    last:&quot;Shi&quot;
};


返回函数

返回函数，则是指在一个函数的返回值为另外一个函数，或者根据特定的条件灵活创建的新函数，示例代码如下：

var setup = function () {
    console.log(1);
    return function () {
        console.log(2);
    };
};
// 调用setup 函数
var my = setup(); // 输出 1
my(); // 输出 2
// 或者直接调用也可
setup()();

强调一句，这种形式的this，认为是ao，激活对象，也可以认为是null，因此是global


偏应用

忽略

Currying

Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。

忽略
</code></pre><h1 id="第五十部分，Function模式（下篇）"><a href="#第五十部分，Function模式（下篇）" class="headerlink" title="第五十部分，Function模式（下篇）"></a>第五十部分，Function模式（下篇）</h1><pre><code>立即执行的对象初始化

该模式的意思是指在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作，通常该模式可以用在一次性执行的代码上。

({
    // 这里你可以定义常量，设置其它值
    maxwidth: 600,
    maxheight: 400,

    //  当然也可以定义utility方法
    gimmeMax: function () {
        return this.maxwidth + &quot;x&quot; + this.maxheight;
    },

    // 初始化
    init: function () {
        console.log(this.gimmeMax());
        // 更多代码...
    }
}).init();  // 这样就开始初始化咯


分支初始化

分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。之前我们在做事件处理的时候，通常使用类似下面的代码：

var utils = {
    addListener: function (el, type, fn) {
        if (typeof window.addEventListener === &apos;function&apos;) {
            el.addEventListener(type, fn, false);
        } else if (typeof document.attachEvent !== &apos;undefined&apos;) {
            el.attachEvent(&apos;on&apos; + type, fn);
        } else {
            el[&apos;on&apos; + type] = fn;
        }
    },
    removeListener: function (el, type, fn) {
    }
};

内存优化

该模式主要是利用函数的属性特性来避免大量的重复计算。通常代码形式如下：

var myFunc = function (param) {
    if (!myFunc.cache[param]) {
        var result = {};
        // ... 复杂操作 ...
        myFunc.cache[param] = result;
    }
    return myFunc.cache[param];
};

// cache 存储
myFunc.cache = {};
</code></pre>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/13/tomdashu3/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-汤姆大叔的深入理解JavaScript读后感二（17——24节）">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/13/tomdashu2/">汤姆大叔的深入理解JavaScript读后感二（17——24节）</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-13
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感2"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感2" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感2"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感2</h1><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=527602&auto=1&height=66"></iframe></p>
<h1 id="第十七部分，面向对象编程之概论"><a href="#第十七部分，面向对象编程之概论" class="headerlink" title="第十七部分，面向对象编程之概论"></a>第十七部分，面向对象编程之概论</h1><p>我们有必要掌握一些OOP基本的特征，并澄清概论中的主要概念。主要讨论封装，继承，多态，接口，那些传统的面向对象概念，可以忽略不看，不影响</p>
<h1 id="第十八部分，面向对象编程之ECMAScript实现（推荐）"><a href="#第十八部分，面向对象编程之ECMAScript实现（推荐）" class="headerlink" title="第十八部分，面向对象编程之ECMAScript实现（推荐）"></a>第十八部分，面向对象编程之ECMAScript实现（推荐）</h1><p>总结如下：</p>
<pre><code>1. 原始值类型
   回头来看6中用于ECMAScript程序的数据类型，前5种是原始值类型，包括Undefined、Null、Boolean、String、Number、Object。
2. 有必要需要注意的是规范还区分了这内置对象、元素对象和宿主对象。
所有ECMAScript实现的对象都是原生对象（其中一些是内置对象、一些在程序执行的时候创建，例如用户自定义对象）。内置对象是原生对象的一个子集、是在程序开始之前内置到ECMAScript里的（例如，parseInt, Match等）。所有的宿主对象是由宿主环境提供的，通常是浏览器，并可能包括如window、alert等。
也有对象是由特殊的内置构造函数创建： Function（函数对象构造器）、Array（数组构造器） RegExp（正则表达式构造器）、Math（数学模块）、 Date（日期的构造器）等等，这些对象也是Object对象类型的值
3. 字面量Literal

   对于三个对象的值：对象（object）,数组（array）和正则表达式（regular expression）
4. 然而，如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：
function A() {}
A.prototype = {
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // false!
因此，对函数的原型引用需要手工恢复：

function A() {}
A.prototype = {
  constructor: A,
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // true
5. a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype

   此外， 实例的[[Prototype]]值确实是在构造函数的prototype属性上获取的。

   然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。
  对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。

  这个地方，原型链，特别难理解，详细的看第一篇，观后感的，原型链的，链接，那个是非常详细的说明 
6. 有误解：

   if (foo instanceof Foo) {
     ...
   }
   这不是用来检测对象foo是否是用Foo构造函数创建的，
所有instanceof运算符只需要一个对象属性——foo.[[Prototype]]，在原型链中从Foo.prototype开始检查其是否存在。

7. alert(1..toString()); // &quot;1&quot;，不是语法错误
   大部分程序里使用原型是用来存储对象的方法、默认状态和共享对象的属性。
</code></pre><h1 id="第十九部分，求值策略-Evaluation-strategy"><a href="#第十九部分，求值策略-Evaluation-strategy" class="headerlink" title="第十九部分，求值策略(Evaluation strategy)"></a>第十九部分，求值策略(Evaluation strategy)</h1><p>很多程序员都确信在JavaScript中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参</p>
<pre><code>1. 按值传递
   按值传递，很多开发人员都很了解了，参数的值是调用者传递的对象值的拷贝(copy of value），函数内部改变参数的值不会影响到外面的对象（该参数在外面的值），一般来说，是重新分配了新内存(我们不关注分配内存是怎么实现的——也是是栈也许是动态内存分配），该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。
2. 按引用传递
   另外一个众所周知的按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。
3. 按共享传递（Call by sharing）
最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象（例如外部的该对象不是想按值传递一样完全的拷贝),改变该参数对象的属性值将会影响到外部的对象。
4. 现在我们知道了ECMAScript中将对象作为参数传递的策略了——按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象
传递的是引用的拷贝（地址副本）

再强调一下，这里所说对象的值是地址（address），而不是对象结构本身，将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。
</code></pre><h1 id="第二十部分，《你真懂JavaScript吗？》答案详解"><a href="#第二十部分，《你真懂JavaScript吗？》答案详解" class="headerlink" title="第二十部分，《你真懂JavaScript吗？》答案详解"></a>第二十部分，《你真懂JavaScript吗？》答案详解</h1><p>总结如下：</p>
<pre><code>1.  题目1

    if (!(&quot;a&quot; in window)) {
        var a = 1;
    }
    alert(a);
   答案是undefined
2. var a = 1,
       b = function a(x) {
           x &amp;&amp; a(--x);
       };
   alert(a);
   答案1
3. function a(x) {
       return x * 2;
   }
   var a;
   alert(a);
   答案 a函数
4. function b(x, y, a) {
       arguments[2] = 10;
       alert(a);
   }
   b(1, 2, 3);
   答案是10
5. function a() {
       alert(this);
   }
   a.call(null);
    答案是window
</code></pre><h1 id="第二十一部分，S-O-L-I-D五大原则之接口隔离原则ISP"><a href="#第二十一部分，S-O-L-I-D五大原则之接口隔离原则ISP" class="headerlink" title="第二十一部分，S.O.L.I.D五大原则之接口隔离原则ISP"></a>第二十一部分，S.O.L.I.D五大原则之接口隔离原则ISP</h1><p>没看懂，基本不用看</p>
<h1 id="第二十二部分，S-O-L-I-D五大原则之依赖倒置原则DIP"><a href="#第二十二部分，S-O-L-I-D五大原则之依赖倒置原则DIP" class="headerlink" title="第二十二部分，S.O.L.I.D五大原则之依赖倒置原则DIP]"></a>第二十二部分，S.O.L.I.D五大原则之依赖倒置原则DIP]</h1><p>稍微看懂了，估计是因为java看多了，ioc，基本不用看</p>
<h1 id="第二十三部分，JavaScript与DOM（上）——也适用于新手"><a href="#第二十三部分，JavaScript与DOM（上）——也适用于新手" class="headerlink" title="第二十三部分，JavaScript与DOM（上）——也适用于新手"></a>第二十三部分，JavaScript与DOM（上）——也适用于新手</h1><pre><code>最重要的是Element, Text, Document。

 Element节点在页面里展示的是一个元素，所以如果你有段落元素(&lt;p&gt;)，你可以通过这个DOM节点来访问。
 Text节点在页面里展示的所有文本相关的元素，所以如果你的段落有文本在里面的话，你可以直接通过DOM的Text节点来访问这个文本
 Document节点代表是整个文档，它是DOM的根节点。

nodeType类型，1是元素，2是属性，3是text节点，详细的type类型可以通过此地址：

    Node.ELEMENT_NODE == 1
    Node.ATTRIBUTE_NODE == 2
    Node.TEXT_NODE == 3
    Node.CDATA_SECTION_NODE == 4
    Node.ENTITY_REFERENCE_NODE == 5
    Node.ENTITY_NODE == 6
    Node.PROCESSING_INSTRUCTION_NODE == 7
    Node.COMMENT_NODE == 8
    Node.DOCUMENT_NODE == 9
    Node.DOCUMENT_TYPE_NODE == 10
    Node.DOCUMENT_FRAGMENT_NODE == 11
    Node.NOTATION_NODE == 12
</code></pre><h1 id="第二十四部分，JavaScript与DOM（下）"><a href="#第二十四部分，JavaScript与DOM（下）" class="headerlink" title="第二十四部分，JavaScript与DOM（下）"></a>第二十四部分，JavaScript与DOM（下）</h1><pre><code>node节点的2种类型，一种是元素节点，一种是text节点，上一章节已经列出了所有的节点类型，这两种需要我们现在特别注意。创建元素可以通过createElement方法，而创建text节点可以使用createTextNode，相应代码如下：
正如我们上章所说的，DOM和JavaScript语言是2个单独的东西，浏览器事件是DOM API的一部分，而不是JavaScript的一部分。

‘mouseover’ – 鼠标移动到某元素上的时候触发mouseover事件。
 ‘mouseout’ – 鼠标从某元素离开的时候触发mouseout事件。
 ‘mousemove’ – 鼠标在某元素上移动但未离开的时候触发mousemove事件。
 ‘change’ – 控件失去input焦点的时候触发该事件（或者值被改变的时候）。

 ‘load’ – 页面加载完毕（包括内容、图片、frame、object）的时候触发该事件。
 ‘resize’ – 页面大小改变的时候触发该事件（例如浏览器缩放）。
 ‘scroll’ – 页面滚动的时候触发该事件。
 ‘unload’ – 从页面或frame删除所有内容的时候触发该事件（例如离开一个页面）。

 严格来说，有2中不同的模型：W3C模型和微软模型，除IE之外W3C模型支持所有的现代浏览器，而微软模型只支持IE

 使用W3C模型的代码如下：

 // 格式：target.addEventListener( type, function, useCapture );  
 // 例子:  
 var myIntro = document.getElementById(&apos;intro&apos;);
 myIntro.addEventListener(&apos;click&apos;, introClick, false);
 使用IE模型的代码如下：

 // 格式: target.attachEvent ( &apos;on&apos; + type, function );  
 // 例子:  
 var myIntro = document.getElementById(&apos;intro&apos;);
 myIntro.attachEvent(&apos;onclick&apos;, introClick);

 一个非常重要的内容是Event对象，当事件发生的时候出发某个函数，该Event对象将自动在函数内可用，该对象包含了很多事件触发时候的信息，但IE却没有这么实现，而是自己实现的，IE浏览器是通过全局对象window下的event属性来包含这些信息

 例如当你想取消默认的行为的时候你可以使用Event对象里的preventDefault()方法，但IE里不得不使用对象的returnValue属性值来控制


 事件冒泡，就是事件触发的时候通过DOM向上冒泡，首先要知道不是所有的事件都有冒泡。事件在一个目标元素上触发的时候，该事件将触发一一触发祖先节点元素，直到最顶层的元素：
 如图所示，如果a连接被点击，触发触发连接的click事件，然后触发p的click事件，以此再触发div和body的click事件。顺序不变，而且不一定是在同时触发的。
 举例来说，如果你有一个很多行的大表格，在每个&lt;tr&gt;上绑定点击事件是个非常危险的想法，因为性能是个大问题。流行的做法是使用事件委托。事件委托描述的是将事件绑定在容器元素上，然后通过判断点击的target子元素的类型来触发相应的事件。
 事件委托依赖于事件冒泡，如果事件冒泡到table之前被禁用的话，那上面的代码就无法工作了。

 经典的事件处理模型，微软的冒泡，以及网景的捕获模型，w3c的两者兼容，网上例子很多，去看解释
</code></pre>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/13/tomdashu2/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-汤姆大叔的深入理解JavaScript读后感一（1——16节）">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/12/tomdashu/">汤姆大叔的深入理解JavaScript读后感一（1——16节）</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-12
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感</h1><h1 id="第一部分，编写高质量JavaScript代码的基本要点"><a href="#第一部分，编写高质量JavaScript代码的基本要点" class="headerlink" title="第一部分，编写高质量JavaScript代码的基本要点"></a>第一部分，编写高质量JavaScript代码的基本要点</h1><p>内容不多，但是作为从头规范开始，值得遵循，现在看来，才更能明白里面的道理。<br>总结一下：</p>
<pre><code>1. 避免全局变量，为啥？自己去看，以及隐式全局变量的副作用，那怎么办？命名空间
2. 推荐单一的单var形式，如  var a = 1,b = 2,myobject = {};形式
3. for循环，预存缓存变量，for-in遍历对象用hasOwnProperty，去掉原型链的属性
4. 避免使用eval，记住该咒语“eval()是魔鬼”，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免                     
5. 编码规范，缩进，空格，花括号，分号
6. 命名函数，啥时候大写，啥时候小写，推荐驼峰命名
7. 关于注解，通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。
</code></pre><h1 id="第二部分，揭秘命名函数表达式"><a href="#第二部分，揭秘命名函数表达式" class="headerlink" title="第二部分，揭秘命名函数表达式"></a>第二部分，揭秘命名函数表达式</h1><p>总结如下：</p>
<pre><code>1. 什么是申明函数？
2. 什么是表达式函数？
3. 什么是函数语句？
4. 什么是命名函数？
5. 主要是区别的地方，很细微，然后又很多浏览器的怪异行为，坑比较多
6. 还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式
7. 后面的部分，如果第一次看，肯定看不懂，是啥意思，建议先忽略掉
</code></pre><h1 id="第三部分，全面解析Module模式"><a href="#第三部分，全面解析Module模式" class="headerlink" title="第三部分，全面解析Module模式"></a>第三部分，全面解析Module模式</h1><p>总结如下：</p>
<pre><code>1. 正常的module模式，缺点就是，每次都必须new，每个实例都是单独的
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Calculator = function (eq) &#123;</div><div class="line">       //这里可以声明私有成员</div><div class="line">   </div><div class="line">       var eqCtl = document.getElementById(eq);</div><div class="line">   </div><div class="line">       return &#123;</div><div class="line">           // 暴露公开的成员</div><div class="line">           add: function (x, y) &#123;</div><div class="line">               var val = x + y;</div><div class="line">               eqCtl.innerHTML = val;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<pre><code>2. 改进过后的，利用函数自执行，可以直接使用
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;, privateName = &quot;博客园&quot;;</div><div class="line"></div><div class="line">    function privateAddTopic(data) &#123;</div><div class="line">        // 这里是内部处理代码</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my.Name = privateName;</div><div class="line">    my.AddTopic = function (data) &#123;</div><div class="line">        privateAddTopic(data);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<pre><code>3. 改進松耦合
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (my) &#123;</div><div class="line"></div><div class="line">    // 添加一些功能   </div><div class="line">    </div><div class="line">    return my;</div><div class="line">&#125; (blogModule || &#123;&#125;));</div></pre></td></tr></table></figure>
<pre><code>4. 克隆
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  var blogModule = (function (old) &#123;</div><div class="line">       var my = &#123;&#125;,</div><div class="line">           key;</div><div class="line">    for (key in old) &#123;</div><div class="line">        if (old.hasOwnProperty(key)) &#123;</div><div class="line">            my[key] = old[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var oldAddPhotoMethod = old.AddPhoto;</div><div class="line">    my.AddPhoto = function () &#123;</div><div class="line">        // 克隆以后，进行了重写，当然也可以继续调用oldAddPhotoMethod</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<pre><code>5. 子模块
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">blogModule.CommentSubModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;;</div><div class="line">    // ...</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<h1 id="第四部分，立即调用的函数表达式"><a href="#第四部分，立即调用的函数表达式" class="headerlink" title="第四部分，立即调用的函数表达式"></a>第四部分，立即调用的函数表达式</h1><pre><code>1. 自動執行
(function () { /* code */ } ()); // 推荐使用这个
2. (function () { /* code */ })(); // 但是这个也是可以用的，括號
3.在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。
4. 闭包的经典例子
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">   错误的：</div><div class="line">   var elems = document.getElementsByTagName(&apos;a&apos;);</div><div class="line">   </div><div class="line">   for (var i = 0; i &lt; elems.length; i++) &#123;</div><div class="line">   </div><div class="line">       elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</div><div class="line">           e.preventDefault();</div><div class="line">           alert(&apos;I am link #&apos; + i);</div><div class="line">       &#125;, &apos;false&apos;);</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">正确的：会锁住对应的index的值，虽然i最后为10，但是之前的值，已经记录好了</div><div class="line">var elems = document.getElementsByTagName(&apos;a&apos;);</div><div class="line"></div><div class="line">for (var i = 0; i &lt; elems.length; i++) &#123;</div><div class="line"></div><div class="line">    (function (lockedInIndex) &#123;</div><div class="line"></div><div class="line">        elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</div><div class="line">            e.preventDefault();</div><div class="line">            alert(&apos;I am link #&apos; + lockedInIndex);</div><div class="line">        &#125;, &apos;false&apos;);</div><div class="line"></div><div class="line">    &#125;)(i);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">   ``` </div><div class="line">       5. 不管什么是自执行，还是立即调用，不用分那么清楚，只需知道立即执行一次匿名函数就够了</div><div class="line">       </div><div class="line"># 第五部分，强大的原型和原型链</div><div class="line"></div><div class="line">    1. 原型关键词，prototype</div><div class="line">    2. 说白了，原型就是一个对象</div><div class="line">    3. 通过hasOwnProperty，区分属性从哪里来的</div><div class="line">    4. 默认还有一个原型的链条，一直到Object.prototype为止</div><div class="line">    5. 所有的对象都有&quot;[[prototype]]&quot;属性（通过__proto__访问），该属性对应对象的原型</div><div class="line">    6. 所有的函数对象都有&quot;prototype&quot;属性，该属性的值会被赋值给该函数创建的对象的&quot;__proto__&quot;属性</div><div class="line">    7. 所有的原型对象都有&quot;constructor&quot;属性，该属性对应创建所有指向该原型的实例的构造函数</div><div class="line">    8. 函数对象和原型对象通过&quot;prototype&quot;和&quot;constructor&quot;属性进行相互关联</div><div class="line">    9. 最简单易懂的看下边</div><div class="line">   [原型链介绍](https://www.talkingcoder.com/article/6360227501704156372)</div><div class="line"></div><div class="line"># 第六七八部分，S.O.L.I.D五大原则之单一职责SRP（忽略）</div><div class="line"></div><div class="line">    The Single Responsibility Principle（单一职责SRP）</div><div class="line">    The Open/Closed Principle（开闭原则OCP）</div><div class="line">    The Liskov Substitution Principle（里氏替换原则LSP）</div><div class="line">    The Interface Segregation Principle（接口分离原则ISP）</div><div class="line">    The Dependency Inversion Principle（依赖反转原则DIP）</div><div class="line"># 第九部分，根本没有“JSON对象”这回事！</div><div class="line"></div><div class="line">    简单的说</div><div class="line">    1. // 这是JSON字符串</div><div class="line">       var foo = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;;</div><div class="line">    2. // 这是对象字面量</div><div class="line">       var bar = &#123; &quot;prop&quot;: &quot;val&quot; &#125;;</div><div class="line">    3. // 将字符串反序列化成json对象</div><div class="line">       var my_obj = JSON.parse( foo );</div><div class="line">    4. json对象，和字面量对象，明显的区别，前者必须有引号，后者去掉引号可以</div><div class="line">           var bar = &#123; prop: &quot;val&quot; &#125;;合法的</div><div class="line">    </div><div class="line"># 第十部分，JavaScript核心（晋级高手必读篇）</div><div class="line">    1. 执行上下文栈(Execution Context Stack)，有三种类型：global, function和eval。</div><div class="line">    2. 执行上下文(Execution Context)，变量对象(variable object)，this指针(this value)，作用域链(scope chain)</div><div class="line">    函数表达式[function expression]（而不是函数声明[function declarations，区别请参考本系列第2章]）是不包含在VO[variable object]里面的</div><div class="line">    3. 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。</div><div class="line">       它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</div><div class="line">    4. 当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了</div><div class="line">    5. 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</div><div class="line">    6. 这表示，在我们去搜寻__parent__之前，首先会去__proto__的链接中。</div><div class="line">    7. 闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</div><div class="line">    8. 在ECMAScript中，是不可以给this赋值的，因为，还是那句话，this不是变量。</div><div class="line">    9. this是执行上下文环境的一个属性，而不是某个变量对象的属性</div><div class="line"># 第十一部分，执行上下文（Execution Contexts）</div><div class="line">可以把调用上下文作为第二个参数传递给eval。那么，如果这个上下文存在，就有可能影响“私有”(有人喜欢这样叫它)变量。</div><div class="line"># 第十二部分，变量对象（Variable Object）</div><div class="line">```angularjs</div><div class="line">    if (true) &#123;</div><div class="line">        var a = 1;</div><div class="line">        &#125; else &#123;</div><div class="line">        var b = 2;</div><div class="line">        &#125;</div><div class="line">    alert(a); // 1</div><div class="line">    alert(b); // undefined,不是b没有声明，而是b的值是undefined</div></pre></td></tr></table></figure>
<p>变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">a = 10;</div><div class="line">alert(window.a); // 10</div><div class="line"> </div><div class="line">alert(delete a); // true</div><div class="line"> </div><div class="line">alert(window.a); // undefined</div><div class="line"> </div><div class="line">var b = 20;</div><div class="line">alert(window.b); // 20</div><div class="line"> </div><div class="line">alert(delete b); // false</div><div class="line"> </div><div class="line">alert(window.b); // still 20</div></pre></td></tr></table></figure></p>
<p>但是这个规则在有个上下文里不起走样，那就是eval上下文，变量没有{DontDelete}特性。</p>
<h1 id="第十三部分，This-Yes-this"><a href="#第十三部分，This-Yes-this" class="headerlink" title="第十三部分，This? Yes,this!"></a>第十三部分，This? Yes,this!</h1><pre><code>1，一个函数上下文中确定this值的通用规则如下：
2. 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。
3. 我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的this值，答案在于引用类型（type Reference）不同的中间值。
4. 标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名
5. (function () {
     alert(this); // null =&gt; global
   })();
6. 函数调用中手动设置this，apply,call
7. 作为构造器调用的函数中的this,都将this的值设置为新创建的对象。
8. 引用类型和this为null,默认为golbal
</code></pre><h1 id="第十四部分，作用域链-Scope-Chain"><a href="#第十四部分，作用域链-Scope-Chain" class="headerlink" title="第十四部分，作用域链(Scope Chain)"></a>第十四部分，作用域链(Scope Chain)</h1><pre><code>1. 函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。
2. 注意这重要的一点－－[[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁 
3. 闭包理解
var x = 10;

function foo() {
  alert(x);
}

(function () {
  var x = 20;
  foo(); // 10, but not 20
})();
[[Scope]]包括在函数内创建的词法作用域（父变量对象）。当函数进一步激活时，在变量对象的这个词法链（静态的存储于创建时）中，来自较高作用域的变量将被搜寻。
此外，这个例子也清晰的表明，一个函数（这个例子中为从函数“foo”返回的匿名函数）的[[scope]]持续存在，即使是在函数创建的作用域已经完成之后。
4. 通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象
5. 源于ECMAScript 的原型特性。如果一个属性在对象中没有直接找到，查询将在原型链中继续。即常说的二维链查找。（1）作用域链环节；（2）每个作用域链－－深入到原型链环节
6. 全局和eval上下文中的作用域链,全局上下文的作用域链仅包含全局对象
7. 在代码执行阶段有两个声明能修改作用域链。这就是with声明和catch语句。它们添加到作用域链的最前端，对象须在这些声明中出现的标识符中查找。
</code></pre><h1 id="第十五部分，函数（Functions）"><a href="#第十五部分，函数（Functions）" class="headerlink" title="第十五部分，函数（Functions）"></a>第十五部分，函数（Functions）</h1><pre><code>1。 只有这2个位置可以声明函数，也就是说:不可能在表达式位置或一个代码块中定义它。
2. // 函数可以在如下地方声明：
   // 1) 直接在全局上下文中
   function globalFD() {
     // 2) 或者在一个函数的函数体内
     function innerFD() {}
   }
3. 相当一部分问题出现了，我们为什么需要函数表达式？答案很明显——在表达式中使用它们，”不会污染”变量对象。最简单的例子是将一个函数作为参数传递给其它函数。
4. 这种模式中，初始化的FE的名称通常被忽略：
(function () {
   // 初始化作用域 
})();
5. ”为何在函数创建后的立即调用中必须用圆括号来包围它？”，答案就是：表达式句子的限制就是这样的。
6. function () {
     ...
   }();

   // 即便有名称

   function foo() {
     ...
   }();
如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。

第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。
</code></pre><h1 id="第十六部分，闭包（Closures）"><a href="#第十六部分，闭包（Closures）" class="headerlink" title="第十六部分，闭包（Closures）"></a>第十六部分，闭包（Closures）</h1><pre><code>var z = 10;

function foo() {
  alert(z);
}

foo(); // 10 – 使用静态和动态作用域的时候

(function () {

  var z = 20;
  foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域

})();

// 将foo作为参数的时候是一样的
(function (funArg) {

  var z = 30;
  funArg(); // 10 – 静态作用域, 30 – 动态作用域

})(foo);
上述描述的就是两类funarg问题 —— 取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。

为了解决上述问题，就引入了 闭包的概念。

这里说明一下，开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，甚至理解成只有匿名函数才能是闭包。

再说一下，因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。
ECMAScript中，闭包指的是：

从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
从实践角度：以下函数才算是闭包：
即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
在代码中引用了自由变量

顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：

闭包还有另外一个非常重要的应用 —— 延迟调用：

var a = 10;
setTimeout(function () {
  alert(a); // 10, after one second
}, 1000);

还可以创建封装的作用域来隐藏辅助对象：

var foo = {};

// 初始化
(function (object) {

  var x = 10;

  object.getX = function _getX() {
    return x;
  };

})(foo);

alert(foo.getX()); // 获得闭包 &quot;x&quot; – 10
</code></pre>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/12/tomdashu/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-adSense试试看">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/09/adSense/">adSense试试看</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-09
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是adSense"><a href="#今天要分享的内容是adSense" class="headerlink" title="今天要分享的内容是adSense"></a>今天要分享的内容是adSense</h1>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/09/adSense/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-写在高考前，对弟弟的祝福">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/06/before-gaokao/">写在高考前，对弟弟的祝福</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-06
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="随便写点"><a href="#随便写点" class="headerlink" title="随便写点"></a>随便写点</h1><p>记得十年前，这个时候，已经进入了考场，转眼，十年都过去了<br>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/06/before-gaokao/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-关于log4j的使用说明">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/06/log4j/">关于log4j的使用说明</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-06
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是log4j的使用。"><a href="#今天要分享的内容是log4j的使用。" class="headerlink" title="今天要分享的内容是log4j的使用。"></a>今天要分享的内容是log4j的使用。</h1><p>每个系统都有日志记录，而多数都是用的log4j，以为会配置了，懂了，发现还是有些细节的问题，要问，说不上来<br>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/06/log4j/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-六一儿童节快乐（补）">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/02/liuyi/">六一儿童节快乐（补）</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-02
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="昨天这么重要的节日忘记了"><a href="#昨天这么重要的节日忘记了" class="headerlink" title="昨天这么重要的节日忘记了"></a>昨天这么重要的节日忘记了</h1><p>今天专程来补图，喵帕斯~<br>祝天下所有的大小朋友，儿童节快乐~<br><img src="http://img.ngacn.cc/attachments/mon_201706/01/-9lddQ13m-9na1KxT1kSgl-d8.jpg" alt=""><br>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/02/liuyi/">阅读全文</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-java中的pattern和matcher的用法">
    <header class="cube-excerpt-header">
        <h1><a href="/2017/06/02/java-match/">java中的pattern和matcher的用法</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2017-06-02
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
            <span id="busuanzi_container_page_pv">
                <i class="cube-icon fa-eye" aria-hidden="true"><span style="display: inline-block" id="busuanzi_value_page_pv"></span></i>
            </span>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="今天要分享的内容是java语言中的pattern和matcher的用法"><a href="#今天要分享的内容是java语言中的pattern和matcher的用法" class="headerlink" title="今天要分享的内容是java语言中的pattern和matcher的用法"></a>今天要分享的内容是java语言中的pattern和matcher的用法</h1><p>java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。<br>它包括两个类：Pattern和Matcher Pattern 一个Pattern是一个正则表达式经编译后的表现模式。<br>Matcher 一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。<br>首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，<br>然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。<br>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2017/06/02/java-match/">阅读全文</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-7">
    
    <li class="cube-pagination-prev">
        <a href="/page/2/">« 上一页</a>
    </li>
    
    
        
            
            <li class="cube-pagination-index">
                <a href="/">1</a>
            </li>
            
        
            
            <li class="cube-pagination-index">
                <a href="/page/2">2</a>
            </li>
            
        
            
            <li class="cube-pagination-index disabled">
                <span>3</span>
            </li>
            
        
            
            <li class="cube-pagination-index">
                <a href="/page/4">4</a>
            </li>
            
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/4/">下一页 »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="搜索" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="搜索" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="title">
    <a>珍惜时间</a>
</div>
<div class="cube-clock cube-sidebar" id="cube-clock">
    <style>
        #cube-clock{
            height:300px;
        }

    </style>
    <iframe src="/origin/clock.html" style="width:100%;height:100%;overflow-x:hidden;"    frameborder="0">
    </iframe>
</div>


<div class="title">
    <a>图片欣赏</a>
</div>
<div class="cube-pic cube-sidebar" id="cube-pic">
    <style>
        .cube-pic{
            height:340px;
        }

    </style>
    <iframe src="/origin/pics.html" style="width:100%;height:100%;overflow-x:hidden;"    frameborder="0">
    </iframe>
</div>



<div class="title">
    <a>我在哪里？</a>
</div>
<div class="cube-map cube-sidebar" id="cube-map">
    <style>
        .cube-map{
            height:365px;
        }

    </style>
    <iframe src="/origin/map.html" style="width:100%;height:100%;overflow-x:hidden;"    frameborder="0">
    </iframe>
</div>



<div class="title">
    <a>最爱音乐</a>
</div>
<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":true,"showlrc":0,"theme":"#b7daff","mutex":true,"mode":"random","preload":"auto","listmaxheight":"513px","music":[{"title":"You","author":"雪野五月","url":"http://fs.w.kugou.com/201709301412/ade28c2d08580c10cc2af3f0408df27d/G014/M03/11/01/roYBAFUKii-AYLzJADzMkUW2wrM890.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20141220/20141220175754495447.jpg"},{"title":"あいぞめ","author":"能登麻美子","url":"http://fs.w.kugou.com/201709301410/f5aa2ac76884dd92ab5123c9f1f1580c/G009/M07/01/19/qYYBAFT-T1GAYzlVAEUJNzS7FeY980.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20140411/20140411182558407258.jpg"},{"title":"逆さまの蝶","author":"SNoW","url":"http://fs.w.kugou.com/201709301312/3d2eb3cc5b2c2b9b15b0f819a9bb94c7/G011/M04/19/03/Sw0DAFT-rIiAB5T5AELUb0ACOaA266.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20110704/20110704110207910.jpg"},{"title":"Only My Railgun","author":"fripSide","url":"http://fs.w.kugou.com/201709301412/020400366b16a59e96f3e8e757db7b82/G012/M06/0A/04/TA0DAFULdzuAQT5xAD7H1p1vchc426.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20140901/20140901133905743482.jpg"},{"title":"Continued Story","author":"黒石ひとみ","url":"http://fs.w.kugou.com/201709301410/6e5f221dedf36ec624313a22da7bbc97/G005/M0A/06/15/pYYBAFUIRdeAOkNWAEyLwX4EGs8349.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20131214/20131214151506586339.jpg"},{"title":"青空","author":"Lia","url":"http://fs.w.kugou.com/201709301414/67ffa781675410bf1bb9041fd0601cee/G006/M09/1D/15/poYBAFS3912AEvH3AD9DQT130PY308.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20151219/20151219102303708.jpg"},{"title":"God knows...","author":"平野綾","url":"http://fs.w.kugou.com/201709301414/bffce7489a4768cdacee3271433d1480/G047/M03/16/10/D5QEAFYmheqAUNFQAESkqo_0ay0392.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20160924/20160924170911713.jpg"},{"title":"I Do","author":"Ilaria Graziano","url":"http://fs.w.kugou.com/201709301414/0dabf35c3b8ace7d1b382b3cfba5bdd9/G010/M07/1E/00/qoYBAFULeA-Aa9k4AEdgpyzbLdE313.mp3","pic":"http://singerimg.kugou.com/uploadpic/softhead/400/20140403/20140403181759832730.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: '开启歌词',
            close: '关闭歌词'
        }
    })(window)
</script>



<div class="title">
    <a>推荐视频</a>
</div>
<div class="cube-video cube-sidebar" id="cube-video">
    <style>
        .cube-video{
            height:300px;
        }
    </style>
    <video src="http://vjs.zencdn.net/v/oceans.mp4" style="width:100%;height:100%;background:#000;" controls ></video>

</div>




<div class="title">
    <a>日常撸狗</a>
</div>
<div class="cube-demo cube-sidebar" id="cube-demo">
    <style>
        .cube-demo{
            height:365px;
        }

    </style>
    <iframe src="/origin/robbot.html" style="width:100%;height:100%;overflow-x:hidden;"    frameborder="0">
    </iframe>
</div>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>近期文章</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2017/12/20/linux-usual-cmd/" title="关于在linux上你必须要学的常用命令">关于在linux上你必须要学的常用命令</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2017/11/03/shotcut-sublime/" title="关于sublime的不可不知的快捷键">关于sublime的不可不知的快捷键</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2017/11/03/shotcut-vim/" title="关于vim的不可不知的快捷键">关于vim的不可不知的快捷键</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2017/10/12/js-es6/" title="ES6新特性概览总结">ES6新特性概览总结</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2017/08/31/person-leave/" title="关于生命中最亲的人的离别">关于生命中最亲的人的离别</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>个人链接</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/Ghohankawk" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://is5.mzstatic.com/image/thumb/Purple128/v4/06/c4/9f/06c49f4a-9d81-2193-3dd7-0ea79a377cf0/source/175x175bb.jpg">
            
            <a href="http://blog.csdn.net/ghohankawk" target="_blank">CSDN</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>友情链接</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/avatar.png">
            <a href="http://sora1.coding.me/" target="_blank">该主题大佬</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    <span style="display: inline;" id="busuanzi_container_site_uv">本站总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑" style="color:black"></span> 次</span>
<span style="display: inline;" id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑" style="color:black"></span> 次</span>

© 2017 ghohank

<br>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
<style>
#live2dcanvas{
    left: 0;
}
</style>

    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="150" height="300" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: 60px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/haru/haru.model.json",0.5)</script>
  
</body>
</html>