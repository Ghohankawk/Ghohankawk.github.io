<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闻道</title>
  <subtitle>闻道有先后，术业有专攻，如是而已</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ghohankawk.github.io/"/>
  <updated>2017-07-05T12:43:12.872Z</updated>
  <id>http://ghohankawk.github.io/</id>
  
  <author>
    <name>韩坤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于java中的synchronized的用法</title>
    <link href="http://ghohankawk.github.io/2017/07/05/java-synchronized/"/>
    <id>http://ghohankawk.github.io/2017/07/05/java-synchronized/</id>
    <published>2017-07-05T11:35:14.231Z</published>
    <updated>2017-07-05T12:43:12.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是synchronized"><a href="#今天要分享的内容是synchronized" class="headerlink" title="今天要分享的内容是synchronized"></a>今天要分享的内容是synchronized</h1><p>这个地方也是，说起来知道同步的用法，但是并不是多么的清楚，和上面的那篇mysql的子查询一样，看到代码中很多这样写的。<br>就顺便研究总结一下： </p>
<h1 id="修饰对象有几种-能出现在什么地方"><a href="#修饰对象有几种-能出现在什么地方" class="headerlink" title="修饰对象有几种(能出现在什么地方)"></a>修饰对象有几种(能出现在什么地方)</h1><ul>
<li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分， 作用的对象是这个类的所有对象。</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法， 作用的对象是调用这个方法的对象；</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法， 作用的对象是这个类的所有对象；</li>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码， 作用的对象是调用这个代码块的对象；</li>
</ul>
<h1 id="2个锁"><a href="#2个锁" class="headerlink" title="2个锁"></a>2个锁</h1><p>上面的4种情况，核心也就是，2个锁</p>
<ol>
<li>对象锁，修饰一个类的成员方法和代码块，就是这种情况，他强调的是创建对象，调用对象本身，比如，a对象和b对象完全不同</li>
<li>类锁（其实没有，类比概念，好理解），也就是修饰类，和静态的方法，这两种的同步是一样的，他们强调的是类class这个对象的锁，因此a对象和b对象拥有同样的锁，所以是相同的</li>
</ol>
<h1 id="废话不多说，直接上例子吧"><a href="#废话不多说，直接上例子吧" class="headerlink" title="废话不多说，直接上例子吧"></a>废话不多说，直接上例子吧</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-07-05 19:52</div><div class="line"> */</div><div class="line">public class synchronizedTest &#123;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰方法块</div><div class="line">     */</div><div class="line">    static class SyncMehtodBlock implements Runnable &#123;</div><div class="line">        private static int count;</div><div class="line"></div><div class="line">        public SyncMehtodBlock() &#123;</div><div class="line">            count = 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtodBlock&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtodBlock&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰方法</div><div class="line">     */</div><div class="line">    static class SyncMehtod extends Thread &#123;</div><div class="line">        private synchronizedTest syn;</div><div class="line"></div><div class="line">        public SyncMehtod(synchronizedTest synchronizedTest) &#123;</div><div class="line">            this.syn = synchronizedTest;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            syn.test();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void test() &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtod&quot;);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtod&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰静态方法</div><div class="line">     */</div><div class="line">    static class SyncStaticMehtod extends Thread &#123;</div><div class="line"></div><div class="line">        public synchronized static void staticTest() &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;开始..SyncStaticMehtod&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;结束..SyncStaticMehtod&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            staticTest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰类</div><div class="line">     */</div><div class="line">    static class SyncClass extends Thread &#123;</div><div class="line"></div><div class="line">        public void classTest() &#123;</div><div class="line">            synchronized (synchronizedTest.class) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;开始..SyncClass&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;结束..SyncClass&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            classTest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //情况1，修饰方法块</div><div class="line">        SyncMehtodBlock syncMehtodBlock = new SyncMehtodBlock();</div><div class="line">        Thread thread1 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock1&quot;);</div><div class="line">        Thread thread2 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock2&quot;);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况2，修饰方法</div><div class="line">        synchronizedTest syn = new synchronizedTest();</div><div class="line">        SyncMehtod syncMehtod3 = new SyncMehtod(syn);</div><div class="line">        SyncMehtod syncMehtod4 = new SyncMehtod(syn);</div><div class="line">        syncMehtod3.start();</div><div class="line">        syncMehtod4.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况3，修饰静态方法</div><div class="line">        SyncStaticMehtod a = new SyncStaticMehtod();</div><div class="line">        SyncStaticMehtod b = new SyncStaticMehtod();</div><div class="line">        Thread thread5 = new Thread(a, &quot;SyncStaticMehtod1&quot;);</div><div class="line">        Thread thread6 = new Thread(b, &quot;SyncStaticMehtod2&quot;);</div><div class="line">        thread5.start();</div><div class="line">        thread6.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况4，修饰类</div><div class="line">        SyncClass c = new SyncClass();</div><div class="line">        SyncClass d = new SyncClass();</div><div class="line">        Thread thread7 = new Thread(c, &quot;SyncClass1&quot;);</div><div class="line">        Thread thread8 = new Thread(d, &quot;SyncClass2&quot;);</div><div class="line">        thread7.start();</div><div class="line">        thread8.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我写了一个，模拟4种情况的例子，报每个类型都包含进去了</p>
<p>请注意观察里面的synchronized的关键位置，出现的情况，以及每个测试例子，是如何新建的，区分不同</p>
<p>所有的例子，都是具有同步的，因为竞争，比如，a先开始，那么a先结束，然后才能轮到b开始，b结束</p>
<p>好好，体会里面的内容</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。</li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
</ol>
<p>我觉得别人说的，这三句话，已经说的很明白不过，我也就不加自己的体会了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是synchronized&quot;&gt;&lt;a href=&quot;#今天要分享的内容是synchronized&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是synchronized&quot;&gt;&lt;/a&gt;今天要分享的内容是synchronized&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于mysql中select子查询</title>
    <link href="http://ghohankawk.github.io/2017/07/03/mysql/"/>
    <id>http://ghohankawk.github.io/2017/07/03/mysql/</id>
    <published>2017-07-03T11:58:01.077Z</published>
    <updated>2017-07-03T12:38:51.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是mysql的select子查询"><a href="#今天要分享的内容是mysql的select子查询" class="headerlink" title="今天要分享的内容是mysql的select子查询"></a>今天要分享的内容是mysql的select子查询</h1><p>一直记得凯哥，半年前说过的一句话，原来你不知道，子查询啊，其实，我知道是又这么一回事<br>但是，具体又说不上来，大概就是那种，一看就知道，但是你有不完全知道的类型吧<br>现在在写hive语法的时候又碰到了，那么就好好总结一次吧。 </p>
<h1 id="子查询定义"><a href="#子查询定义" class="headerlink" title="子查询定义"></a>子查询定义</h1><p>在一个表表达中可以调用另一个表表达式，这个被调用的表表达式叫做子查询（subquery），<br>那么也称作子选择（subselect）或内嵌选择（inner select）。<br>子查询的结果传递给调用它的表达式继续处理。</p>
<p>说人话就是，一个sql语句，出现了2个以上的select关键词，这个清晰了吧？</p>
<h1 id="子查询分类1"><a href="#子查询分类1" class="headerlink" title="子查询分类1"></a>子查询分类1</h1><pre><code>1*1   标量子查询：返回的结果集是一个标量集合，一行一列，也就是一个标量值。可以指定一个标量表达式的任何地方，都可以用一个标量子查询。
1*n   行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。
n*1   列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）。
n*n   表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。
     就这么四类
</code></pre><p>从定义上讲，</p>
<p>每个标量子查询也是一个行子查询和一个列子查询，反之则不是；</p>
<p>每个行子查询和列子查询也是一个表子查询，反之也不是。</p>
<h1 id="子查询分类2"><a href="#子查询分类2" class="headerlink" title="子查询分类2"></a>子查询分类2</h1><pre><code>where型子查询：（把内层查询结果当作外层查询的比较条件）
定义：where型的子查询就是把内层查询的结果当作外层查询的条件。

from型子查询：（把内层的查询结果供外层再次查询）
定义：from子查询就是把子查询的结果(内存里的一张表)当作一张临时表，然后再对它进行处理。

exists型子查询：（把外层查询结果拿到内层，看内层的查询是否成立）
定义：exists子查询就是对外层表进行循环，再对内表进行内层查询。和in ()差不多，但是它们还是有区别的。主要是看两个张表大小差的程度。若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）；
</code></pre><p>其实，光这么说，很难明白的，因为你都没写过，根本理解不了，尤其是exisit子查询</p>
<h1 id="使用子查询原则"><a href="#使用子查询原则" class="headerlink" title="使用子查询原则"></a>使用子查询原则</h1><pre><code>1.一个子查询必须放在圆括号中。
2.将子查询放在比较条件的右边以增加可读性。
子查询不包含 ORDER BY 子句。对一个 SELECT 语句只能用一个 ORDER BY 子句，并且如果指定了它就必须放在主 SELECT 语句的最后。
3.在子查询中可以使用两种比较条件：单行运算符(&gt;, =, &gt;=, &lt;, &lt;&gt;, &lt;=) 和多行运算符(IN, ANY, ALL)。
</code></pre><h1 id="where型子查询"><a href="#where型子查询" class="headerlink" title="where型子查询"></a>where型子查询</h1><p>select * from a where a.xx = (select xx from b where b.xx=”xx”),这种感觉</p>
<h1 id="from型子查询"><a href="#from型子查询" class="headerlink" title="from型子查询"></a>from型子查询</h1><p>select <em> from (select </em> from a) as aa,这种感觉</p>
<h1 id="exists型子查询"><a href="#exists型子查询" class="headerlink" title="exists型子查询"></a>exists型子查询</h1><p>因为上面那两种，子查询，很明了简单，就不谈了，主要说下面的</p>
<p>尽量表达清楚</p>
<pre><code>EXISTS关键字表示存在。使用EXISTS关键字时，内层查询语句不返回查询的记录，
而是返回一个真假值，如果内层查询语句查询到满足条件的记录，
只要子查询中至少返回一个值，则EXISTS语句的值就为True。
就返回true，否则返回false。当返回的值为true时，外层查询语句将进行查询，
否则不进行查询。NOT EXISTS刚好与之相反。exists的用法和in ()差不多，
但是它们还是有区别的。主要是看两个张表大小差的程度。
若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）;
</code></pre><p>看上面这段话的，解释，保证，你看了，也不知道在说啥，其实说的稍微有点问题</p>
<p>正确的解释，应该是，上面的当然也没错</p>
<p>exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条 件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false</p>
<p>就是循环外层的查询结果，然后带进去，查看条件是否成立，不成立丢弃，成立留下</p>
<pre><code>select * from user where exists (select 1);
这句话，就会输出，user表中全部的人，因为后面的条件，对于每个人都成立
</code></pre><p>select * from user where userId in (1, 2, 3);</p>
<p>这样的in查询，等价于</p>
<p>select * from user where userId = 1 or userId = 2 or userId = 3;</p>
<p>因此，要求in后面的表是小表，才不至于，很大的表，循环多次</p>
<h1 id="记住一句话，谁的表大就用谁的索引"><a href="#记住一句话，谁的表大就用谁的索引" class="headerlink" title="记住一句话，谁的表大就用谁的索引"></a>记住一句话，谁的表大就用谁的索引</h1><p>下面来考虑exists和in的性能</p>
<pre><code>考虑如下SQL语句

1: select * from A where exists (select * from B where B.id = A.id);

2: select * from A where A.id in (select id from B);
</code></pre><p> 查询1.可以转化以下伪代码，便于理解</p>
<pre><code> for ($i = 0; $i &lt; count(A); $i++) {

 　　$a = get_record(A, $i); #从A表逐条获取记录

 　　if (B.id = $a[id]) #如果子条件成立

 　　　　$result[] = $a;

 }

return $result;
</code></pre><p> 大概就是这么个意思，其实可以看到,查询1主要是用到了B表的索引，A表如何对查询的效率影响应该不大<br> 也就是说，表B越大就越能利用到索引的优势</p>
<p> 而假设B表是小表的所有id为1,2,3,查询2可以转换为</p>
<pre><code>select * from A where A.id = 1 or A.id = 2 or A.id = 3;
</code></pre><p> 这个好理解了，这里主要是用到了A的索引，B表如何对查询影响不大<br>  也就是说，表A越大就越能利用到索引的优势</p>
<p> 下面再看not exists 和 not in</p>
<pre><code>1. select * from A where not exists (select * from B where B.id = A.id);

2. select * from A where A.id not in (select id from B);
</code></pre><p>看查询1，还是和上面一样，用了B的索引</p>
<p>而对于查询2，可以转化成如下语句</p>
<pre><code>select * from A where A.id != 1 and A.id != 2 and A.id != 3;
</code></pre><p>可以知道not in是个范围查询，这种!=的范围查询无法使用任何索引,等于说A表的每条记录，都要在B表里遍历一次，查看B表里是否存在这条记录</p>
<p>not in 和not exists如果查询语句</p>
<p>使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。<br>所以无论那个表大，用not exists都比not in要快。          </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先大概说一下，这个子查询吧，其实，mysql还有很多的细节地方要注意，有时间再说说，自己的理解吧</p>
<p>补充一句，昨天和妹子出去吃饭，今天居然就感冒生病了，心疼啊/(ㄒoㄒ)/~~，怪我了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是mysql的select子查询&quot;&gt;&lt;a href=&quot;#今天要分享的内容是mysql的select子查询&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是mysql的select子查询&quot;&gt;&lt;/a&gt;今天要分享的内容是mysql
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于linux中的grep用法</title>
    <link href="http://ghohankawk.github.io/2017/06/29/linux-grep/"/>
    <id>http://ghohankawk.github.io/2017/06/29/linux-grep/</id>
    <published>2017-06-29T11:29:00.193Z</published>
    <updated>2017-06-29T12:16:25.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是grep这个命令"><a href="#今天要分享的内容是grep这个命令" class="headerlink" title="今天要分享的内容是grep这个命令"></a>今天要分享的内容是grep这个命令</h1><p>之前有一篇写了awk，那么grep的这个命令也就顺便研究一下</p>
<h1 id="grep背景简介"><a href="#grep背景简介" class="headerlink" title="grep背景简介"></a>grep背景简介</h1><p>  grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。Unix的grep家族包 括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能 更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p>
<p>  grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到屏幕，不影响原文件内容。</p>
<p>  grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<h1 id="grep正则表达式元字符集（基本集）"><a href="#grep正则表达式元字符集（基本集）" class="headerlink" title="grep正则表达式元字符集（基本集）"></a>grep正则表达式元字符集（基本集）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">^</div><div class="line">锚定行的开始 如：&apos;^grep&apos;匹配所有以grep开头的行。</div><div class="line"></div><div class="line">$</div><div class="line">锚定行的结束 如：&apos;grep$&apos;匹配所有以grep结尾的行。</div><div class="line"></div><div class="line">.</div><div class="line">匹配一个非换行符的字符 如：&apos;gr.p&apos;匹配gr后接一个任意字符，然后是p。</div><div class="line"></div><div class="line">*</div><div class="line">匹配零个或多个先前字符 如：&apos;*grep&apos;匹配所有一个或多个空格后紧跟grep的行。 .*一起用代表任意字符。</div><div class="line"></div><div class="line">[]</div><div class="line">匹配一个指定范围内的字符，如&apos;[Gg]rep&apos;匹配Grep和grep。</div><div class="line"></div><div class="line">[^]</div><div class="line">匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。</div><div class="line"></div><div class="line">\(..\)</div><div class="line">标记匹配字符，如&apos;\(love\)&apos;，love被标记为1。</div><div class="line"></div><div class="line">\&lt;</div><div class="line">锚定单词的开始，如:&apos;\&lt;grep&apos;匹配包含以grep开头的单词的行。</div><div class="line"></div><div class="line">\&gt;</div><div class="line">锚定单词的结束，如&apos;grep\&gt;&apos;匹配包含以grep结尾的单词的行。</div><div class="line"></div><div class="line">x\&#123;m\&#125;</div><div class="line">重复字符x，m次，如：&apos;0\&#123;5\&#125;&apos;匹配包含5个o的行。</div><div class="line"></div><div class="line">x\&#123;m,\&#125;</div><div class="line">重复字符x,至少m次，如：&apos;o\&#123;5,\&#125;&apos;匹配至少有5个o的行。</div><div class="line"></div><div class="line">x\&#123;m,n\&#125;</div><div class="line">重复字符x，至少m次，不多于n次，如：&apos;o\&#123;5,10\&#125;&apos;匹配5--10个o的行。</div><div class="line"></div><div class="line">\w</div><div class="line">匹配文字和数字字符，也就是[A-Za-z0-9]，如：&apos;G\w*p&apos;匹配以G后跟零个或多个文字或数字字符，然后是p。</div><div class="line"></div><div class="line">\W</div><div class="line">\w的反置形式，匹配一个或多个非单词字符，如点号句号等。</div><div class="line"></div><div class="line">\b</div><div class="line">单词锁定符，如: &apos;\bgrep\b&apos;只匹配grep。</div></pre></td></tr></table></figure>
<h1 id="用于egrep和-grep-E的元字符扩展集"><a href="#用于egrep和-grep-E的元字符扩展集" class="headerlink" title="用于egrep和 grep -E的元字符扩展集"></a>用于egrep和 grep -E的元字符扩展集</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">+</div><div class="line">匹配一个或多个先前的字符。如：&apos;[a-z]+able&apos;，匹配一个或多个小写字母后跟able的串，如loveable,enable,disable等。</div><div class="line"></div><div class="line">?</div><div class="line">匹配零个或多个先前的字符。如：&apos;gr?p&apos;匹配g后跟一个r或没有字符，然后是p的行。</div><div class="line"></div><div class="line">a|b|c</div><div class="line">匹配a或b或c。如：grep|sed匹配grep或sed</div><div class="line"></div><div class="line">()</div><div class="line">分组符号，如：love(able|rs)ov+匹配loveable或lovers，匹配一个或多个ov。</div><div class="line"></div><div class="line">    \(\)：将一个或多个字符捆绑在一起，当作一个整体进行处理；</div><div class="line"></div><div class="line">        # grep &quot;\(xy\)\+&quot; grep.txt</div><div class="line"></div><div class="line">        \(xy\)*ab</div><div class="line"></div><div class="line">Note：分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：\1,\2,\3,.....</div><div class="line"></div><div class="line">    \1：从左侧起，第一个左括号以及与之匹配右括号之间的模式所匹配到的字符；</div><div class="line"></div><div class="line">        \(ab\+\(xy\)*\)：</div><div class="line"></div><div class="line">            \1：ab\+\(xy\)*</div><div class="line"></div><div class="line">            \2：xy</div><div class="line"></div><div class="line">x&#123;m&#125;,x&#123;m,&#125;,x&#123;m,n&#125;</div><div class="line">作用同x\&#123;m\&#125;,x\&#123;m,\&#125;,x\&#123;m,n\&#125;</div></pre></td></tr></table></figure>
<h1 id="POSIX字符类"><a href="#POSIX字符类" class="headerlink" title="POSIX字符类"></a>POSIX字符类</h1><p>为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是A-Za-z0-9的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[:alnum:]</div><div class="line">文字数字字符</div><div class="line"></div><div class="line">[:alpha:]</div><div class="line">文字字符</div><div class="line"></div><div class="line">[:digit:]</div><div class="line">数字字符</div><div class="line"></div><div class="line">[:graph:]</div><div class="line">非空字符（非空格、控制字符）</div><div class="line"></div><div class="line">[:lower:]</div><div class="line">小写字符</div><div class="line"></div><div class="line">[:cntrl:]</div><div class="line">控制字符</div><div class="line"></div><div class="line">[:print:]</div><div class="line">非空字符（包括空格）</div><div class="line"></div><div class="line">[:punct:]</div><div class="line">标点符号</div><div class="line"></div><div class="line">[:space:]</div><div class="line">所有空白字符（新行，空格，制表符）</div><div class="line"></div><div class="line">[:upper:]</div><div class="line">大写字符</div><div class="line"></div><div class="line">[:xdigit:]</div><div class="line">十六进制数字（0-9，a-f，A-F）</div></pre></td></tr></table></figure>
<h1 id="Grep命令选项"><a href="#Grep命令选项" class="headerlink" title="Grep命令选项"></a>Grep命令选项</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">-?</div><div class="line">同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。</div><div class="line"></div><div class="line">-b，--byte-offset</div><div class="line">打印匹配行前面打印该行所在的偏移。</div><div class="line"></div><div class="line">-c,--count</div><div class="line">只打印匹配的行数，不显示匹配的内容，数量匹配了多少行。</div><div class="line"></div><div class="line">-f File，--file=File</div><div class="line">从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。</div><div class="line"></div><div class="line">-h，--no-filename</div><div class="line">当搜索多个文件时，不显示匹配文件名前缀。</div><div class="line"></div><div class="line">-i，--ignore-case</div><div class="line">忽略大小写差别。</div><div class="line"></div><div class="line">-q，--quiet</div><div class="line">取消显示，只返回退出状态。0则表示找到了匹配的行。</div><div class="line"></div><div class="line">-l，--files-with-matches</div><div class="line">打印匹配模板的文件清单。</div><div class="line"></div><div class="line">-L，--files-without-match</div><div class="line">打印不匹配模板的文件清单。</div><div class="line"></div><div class="line">-n，--line-number</div><div class="line">在匹配的行前面打印行号。</div><div class="line"></div><div class="line">-s，--silent</div><div class="line">不显示关于不存在或者无法读取文件的错误信息。</div><div class="line"></div><div class="line">-v，--revert-match</div><div class="line">反检索，只显示不匹配的行。</div><div class="line"></div><div class="line">-w，--word-regexp</div><div class="line">如果被\&lt;和\&gt;引用，就把表达式做为一个单词搜索。</div><div class="line"></div><div class="line">-V，--version</div><div class="line">显示软件版本信息。</div><div class="line"></div><div class="line">--color=auto：对匹配到的文本着色显示；</div><div class="line"></div><div class="line"></div><div class="line">    -o：仅显示匹配到的字符串</div><div class="line"></div><div class="line">    -A #：after，显示匹配的后#行</div><div class="line"></div><div class="line">    -B #：before，显示匹配的前#行</div><div class="line"></div><div class="line">    -C #：context，前后各#行</div><div class="line"></div><div class="line">    -E：使用ERE，支持扩展的正则表达式</div><div class="line"></div><div class="line">    -s：不显示不存在或无匹配的错误信息</div></pre></td></tr></table></figure>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">要用好grep这个工具，其实就是要写好正则表达式，所以这里不对grep的所有功能进行实例讲解，只列几个例子，讲解一个正则表达式的写法。</div><div class="line"></div><div class="line">$ ls -l | grep &apos;^a&apos;</div><div class="line">通过管道过滤ls -l输出的内容，只显示以a开头的行。</div><div class="line"></div><div class="line">$ grep &apos;test&apos; d*</div><div class="line">显示所有以d开头的文件中包含test的行。</div><div class="line"></div><div class="line">$ grep &apos;test&apos; aa bb cc</div><div class="line">显示在aa，bb，cc文件中匹配test的行。</div><div class="line"></div><div class="line">$ grep &apos;[a-z]\&#123;5\&#125;&apos; aa</div><div class="line">显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</div><div class="line"></div><div class="line">$ grep &apos;w\(es\)t.*\1&apos; aa</div><div class="line">如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.*），这些字符后面紧跟着另外一个es（\1），找到就显示该行。如果用egrep或grep -E，就不用&quot;\&quot;号进行转义，直接写成&apos;w(es)t.*\1&apos;就可以了。</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>grep确实很强大，同时，相对awk还是简单多了，无论是命令还是使用</p>
<p>毕竟只是单纯的去查找，而不做任何的修改内容上</p>
<p>awk函数多，又可以自己编程</p>
<p>多到底，grep还是考验对正则表达式的理解</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是grep这个命令&quot;&gt;&lt;a href=&quot;#今天要分享的内容是grep这个命令&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是grep这个命令&quot;&gt;&lt;/a&gt;今天要分享的内容是grep这个命令&lt;/h1&gt;&lt;p&gt;之前有一篇写了awk
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于linux中的awk用法</title>
    <link href="http://ghohankawk.github.io/2017/06/29/linux-awk/"/>
    <id>http://ghohankawk.github.io/2017/06/29/linux-awk/</id>
    <published>2017-06-29T08:05:45.038Z</published>
    <updated>2017-06-29T11:19:55.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是awk这个命令"><a href="#今天要分享的内容是awk这个命令" class="headerlink" title="今天要分享的内容是awk这个命令"></a>今天要分享的内容是awk这个命令</h1><p>因为要看日志，以前公司业务小的时候，能下载到本地用文本工具一个一个去找，但是现在不行了</p>
<p>面对hive大数据，根本行不通，没办法，不得不面对这个命令</p>
<h1 id="先来了解一下awk背景知识"><a href="#先来了解一下awk背景知识" class="headerlink" title="先来了解一下awk背景知识"></a>先来了解一下awk背景知识</h1><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)，如果没有指定模式，则所有被操作所指定的行都被处理。awk分别代表其作者姓氏的第一个字母。因为它的作者是三个人，分别是Alfred Aho、Brian Kernighan、Peter Weinberger。gawk是awk的GNU版本，它提供了Bell实验室和GNU的一些扩展。下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk。</p>
<h1 id="语法和选项"><a href="#语法和选项" class="headerlink" title="语法和选项"></a>语法和选项</h1><p>  1.语法</p>
<pre><code>awk [options] &apos;script&apos; var=value file(s)
awk [options] -f scriptfile var=value file(s)
</code></pre><ol>
<li><p>命令选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-F fs or --field-separator fs</div><div class="line">指定输入分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</div><div class="line"></div><div class="line">-v var=value or --asign var=value</div><div class="line">赋值一个用户定义变量。</div><div class="line"></div><div class="line">-f scripfile or --file scriptfile</div><div class="line">从脚本文件中读取awk命令。</div><div class="line"></div><div class="line">-mf nnn and -mr nnn</div><div class="line">对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</div><div class="line"></div><div class="line">-W compact or --compat, -W traditional or --traditional</div><div class="line">在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</div><div class="line"></div><div class="line">-W copyleft or --copyleft, -W copyright or --copyright</div><div class="line">打印简短的版权信息。</div><div class="line"></div><div class="line">-W help or --help, -W usage or --usage</div><div class="line">打印全部awk选项和每个选项的简短说明。</div><div class="line"></div><div class="line">-W lint or --lint</div><div class="line">打印不能向传统unix平台移植的结构的警告。</div><div class="line"></div><div class="line">-W lint-old or --lint-old</div><div class="line">打印关于不能向传统unix平台移植的结构的警告。</div><div class="line"></div><div class="line">-W posix</div><div class="line">打开兼容模式。但有以下限制，不识别：\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。</div><div class="line"></div><div class="line">-W re-interval or --re-inerval</div><div class="line">允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</div><div class="line"></div><div class="line">-W source program-text or --source program-text</div><div class="line">使用program-text作为源代码，可与-f命令混用。</div><div class="line"></div><div class="line">-W version or --version</div><div class="line">打印bug报告信息的版本。</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="模式和操作"><a href="#模式和操作" class="headerlink" title="模式和操作"></a>模式和操作</h1><p>awk脚本是由模式和操作组成的：</p>
<p>pattern {action} </p>
<p>如<br>$ awk ‘/root/‘ test，或</p>
<p>$ awk ‘$3 &lt; 100’ test。</p>
<p>两者是可选的，如果没有模式，则action应用到全部记录，如果没有action，则输出匹配全部记录。</p>
<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>  模式可以是以下任意一个：</p>
<pre><code>/正则表达式/：使用通配符的扩展集。
关系表达式：可以用下面运算符表中的关系运算符进行操作，可以是字符串或数字的比较，如$2&gt;%1选择第二个字段比第一个字段长的行。
模式匹配表达式：用运算符~(匹配)和~!(不匹配)。
pattern语句块，模式：指定一个行的范围。该语法不能包括BEGIN和END模式。
BEGIN：让用户指定在第一条输入记录被处理之前所发生的动作，通常可在这里设置全局变量。
END：让用户在最后一条输入记录被读取之后发生的动作。 
</code></pre><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>  操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内。主要有四部份：</p>
<pre><code>变量或数组赋值
输出命令
内置函数
控制流命令
</code></pre><h1 id="awk脚本基本结构"><a href="#awk脚本基本结构" class="headerlink" title="awk脚本基本结构"></a>awk脚本基本结构</h1><pre><code>awk &apos;BEGIN{ print &quot;start&quot; } pattern{ commands } END{ print &quot;end&quot; }&apos; file 
</code></pre><p>  一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：<br> pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>
<p>当使用不带参数的print时，它就打印当前行，当print的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用，</p>
<p>例如： </p>
<pre><code>echo | awk &apos;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; }&apos; 
v1 v2 v3 
</code></pre><p> 双引号拼接使用： </p>
<pre><code>echo | awk &apos;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; }&apos; 
v1=v2=v3
</code></pre><p>{ }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i=0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。</p>
<h1 id="awk的环境变量"><a href="#awk的环境变量" class="headerlink" title="awk的环境变量"></a>awk的环境变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">变量	描述</div><div class="line">$n	当前记录的第n个字段，字段间由FS分隔。</div><div class="line">$0	完整的输入记录。</div><div class="line">ARGC	命令行参数的数目。</div><div class="line">ARGIND	命令行中当前文件的位置(从0开始算)。</div><div class="line">ARGV	包含命令行参数的数组。</div><div class="line">CONVFMT	数字转换格式(默认值为%.6g)</div><div class="line">ENVIRON	环境变量关联数组。</div><div class="line">ERRNO	最后一个系统错误的描述。</div><div class="line">FIELDWIDTHS	字段宽度列表(用空格键分隔)。</div><div class="line">FILENAME	当前文件名。</div><div class="line">FNR	同NR，但相对于当前文件。</div><div class="line">FS	字段分隔符(默认是任何空格)。</div><div class="line">IGNORECASE	如果为真，则进行忽略大小写的匹配。</div><div class="line">NF	当前记录中的字段数。</div><div class="line">NR	当前记录数。</div><div class="line">OFMT	数字的输出格式(默认值是%.6g)。</div><div class="line">OFS	输出字段分隔符(默认值是一个空格)。</div><div class="line">ORS	输出记录分隔符(默认值是一个换行符)。</div><div class="line">RLENGTH	由match函数所匹配的字符串的长度。</div><div class="line">RS	记录分隔符(默认是一个换行符)。</div><div class="line">RSTART	由match函数所匹配的字符串的第一个位置。</div><div class="line">SUBSEP	数组下标分隔符(默认值是\034)。</div></pre></td></tr></table></figure>
<h1 id="awk运算符"><a href="#awk运算符" class="headerlink" title="awk运算符"></a>awk运算符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">运算符	描述</div><div class="line">= += -= *= /= %= ^= **=	赋值</div><div class="line">?:	C条件表达式</div><div class="line">||	逻辑或</div><div class="line">&amp;&amp;	逻辑与</div><div class="line">~ ~!	匹配正则表达式和不匹配正则表达式</div><div class="line">&lt; &lt;= &gt; &gt;= != ==	关系运算符</div><div class="line">空格	连接</div><div class="line">+ -	加，减</div><div class="line">* / &amp;	乘，除与求余</div><div class="line">+ - !	一元加，减和逻辑非</div><div class="line">^ ***	求幂</div><div class="line">++ --	增加或减少，作为前缀或后缀</div><div class="line">$	字段引用</div><div class="line">in	数组成员</div></pre></td></tr></table></figure>
<h1 id="熟悉一组专有名词"><a href="#熟悉一组专有名词" class="headerlink" title="熟悉一组专有名词"></a>熟悉一组专有名词</h1><ol>
<li>记录</li>
</ol>
<p>awk把每一个以换行符结束的行称为一个记录。<br>记录分隔符：默认的输入和输出的分隔符都是回车，保存在内建变量ORS和RS中。<br>$0变量：它指的是整条记录。如$ awk ‘{print $0}’ test将输出test文件中的所有记录。<br>变量NR：一个计数器，每处理完一条记录，NR的值就增加1。如$ awk ‘{print NR,$0}’ test将输出test文件中所有记录，并在记录前显示记录号。</p>
<ol>
<li>域</li>
</ol>
<p>记录中每个单词称做“域”，默认情况下以空格或tab分隔。awk可跟踪域的个数，并在内建变量NF中保存该值。如$ awk ‘{print $1,$3}’ test将打印test文件中第一和第三个以空格分开的列(域)。</p>
<ol>
<li>域分隔符</li>
</ol>
<p>内建变量FS保存输入域分隔符的值，默认是空格或tab。我们可以通过-F命令行选项修改FS的值。如$ awk -F: ‘{print $1,$5}’ test将打印以冒号为分隔符的第一，第五列的内容。<br>可以同时使用多个域分隔符，这时应该把分隔符写成放到方括号中，如$awk -F’[:\t]’ ‘{print $1,$3}’ test，表示以空格、冒号和tab作为分隔符。<br>输出域的分隔符默认是一个空格，保存在OFS中。如$ awk -F: ‘{print $1,$5}’ test，$1和$5间的逗号就是OFS的值。</p>
<h1 id="gawk专用正则表达式元字符"><a href="#gawk专用正则表达式元字符" class="headerlink" title="gawk专用正则表达式元字符"></a>gawk专用正则表达式元字符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">\Y 匹配一个单词开头或者末尾的空字符串。</div><div class="line"></div><div class="line">\B 匹配单词内的空字符串。</div><div class="line"></div><div class="line">\&lt; 匹配一个单词的开头的空字符串，锚定开始。</div><div class="line"></div><div class="line">\&gt;匹配一个单词的末尾的空字符串，锚定末尾。</div><div class="line"></div><div class="line">\w匹配一个字母数字组成的单词。</div><div class="line"></div><div class="line">\W匹配一个非字母数字组成的单词。</div><div class="line"></div><div class="line">\‘匹配字符串开头的一个空字符串。</div><div class="line"></div><div class="line">\&apos;匹配字符串末尾的一个空字符串。</div></pre></td></tr></table></figure>
<h1 id="匹配操作符"><a href="#匹配操作符" class="headerlink" title="匹配操作符(~)"></a>匹配操作符(~)</h1><p>  用来在记录或者域内匹配正则表达式。如$ awk ‘$1 ~/^root/‘ test将显示test文件第一列中以root开头的行。</p>
<h1 id="一组例子"><a href="#一组例子" class="headerlink" title="一组例子"></a>一组例子</h1><pre><code class="angularjs">$ awk &apos;/^(no|so)/&apos; test-----打印所有以模式no或so开头的行。

$ awk &apos;/^[ns]/{print $1}&apos; test-----如果记录以n或s开头，就打印这个记录。

$ awk &apos;$1 ~/[0-9][0-9]$/(print $1}&apos; test-----如果第一个域以两个数字结束就打印这个记录。

$ awk &apos;$1 == 100 || $2 &lt; 50&apos; test-----如果第一个或等于100或者第二个域小于50，则打印该行。

$ awk &apos;$1 != 10&apos; test-----如果第一个域不等于10就打印该行。

$ awk &apos;/test/{print $1 + 10}&apos; test-----如果记录包含正则表达式test，则第一个域加10并打印出来。

$ awk &apos;{print ($1 &gt; 5 ? &quot;ok &quot;$1: &quot;error&quot;$1)}&apos; test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。

$ awk &apos;/^root/,/^mysql/&apos; test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。
</code></pre>
<h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><pre><code class="angularjs">函数名称    返回值
atan2(x,y)    y,x范围内的余切
cos(x)    余弦函数
exp(x)    求幂
int(x)    取整
log(x)    自然对数
rand()    随机数
sin(x)    正弦
sqrt(x)    平方根
srand(x)    x是rand()函数的种子
int(x)    取整，过程没有舍入
rand()    产生一个大于等于0而小于1的随机数
</code></pre>
<h1 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h1><pre><code class="angularjs">
函数名    说明 
mktime( YYYY MM dd HH MM ss[ DST])    生成时间格式 
strftime([format [, timestamp]])    格式化时间输出，将时间戳转为时间字符串 具体格式，见下表. 
systime()    得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数




格式    描述
%a    星期几的缩写(Sun)
%A    星期几的完整写法(Sunday)
%b    月名的缩写(Oct)
%B    月名的完整写法(October)
%c    本地日期和时间
%d    十进制日期
%D    日期 08/20/99
%e    日期，如果只有一位会补上一个空格
%H    用十进制表示24小时格式的小时
%I    用十进制表示12小时格式的小时
%j    从1月1日起一年中的第几天
%m    十进制表示的月份
%M    十进制表示的分钟
%p    12小时表示法(AM/PM)
%S    十进制表示的秒
%U    十进制表示的一年中的第几个星期(星期天作为一个星期的开始)
%w    十进制表示的星期几(星期天是0)
%W    十进制表示的一年中的第几个星期(星期一作为一个星期的开始)
%x    重新设置本地日期(08/20/99)
%X    重新设置本地时间(12：00：00)
%y    两位数字表示的年(99)
%Y    当前月份
%Z    时区(PDT)
%%    百分号(%)


 $ awk &apos;{ now=strftime( &quot;%D&quot;, systime() ); print now }&apos;
 $ awk &apos;{ now=strftime(&quot;%m/%d/%y&quot;); print now }&apos;
</code></pre>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><pre><code class="angularjs">gsub( Ere, Repl, [ In ] )    除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 
sub( Ere, Repl, [ In ] )    用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 
index( String1, String2 )    在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 
length [(String)]    返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 
blength [(String)]    返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 
substr( String, M, [ N ] )    返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 
match( String, Ere )    在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 
split( String, A, [Ere] )    将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 
tolower( String )    返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 
toupper( String )    返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 
sprintf(Format, Expr, Expr, . . . )
</code></pre>
<h1 id="如何把一行竖排的数据转换成横排？实用"><a href="#如何把一行竖排的数据转换成横排？实用" class="headerlink" title="如何把一行竖排的数据转换成横排？实用"></a>如何把一行竖排的数据转换成横排？实用</h1><p>awk ‘{printf(“%s,”,$1)}’ filename</p>
<h1 id="跟grep的区别是？"><a href="#跟grep的区别是？" class="headerlink" title="跟grep的区别是？"></a>跟grep的区别是？</h1><ol>
<li><p>grep用于在文件中查找特定的内容</p>
</li>
<li><p>awk可以用来加工特定的信息，用于扩展和报表</p>
</li>
<li><p>sed是流shi的文本编辑处理，可以替换，增加，删除等操作</p>
</li>
</ol>
<p>因此，awk和sed不仅可以用于查找，有自己的函数，可以完成，复杂的信息提取</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是awk这个命令&quot;&gt;&lt;a href=&quot;#今天要分享的内容是awk这个命令&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是awk这个命令&quot;&gt;&lt;/a&gt;今天要分享的内容是awk这个命令&lt;/h1&gt;&lt;p&gt;因为要看日志，以前公司业务小
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx入门系列二</title>
    <link href="http://ghohankawk.github.io/2017/06/29/nginx2/"/>
    <id>http://ghohankawk.github.io/2017/06/29/nginx2/</id>
    <published>2017-06-29T03:12:32.223Z</published>
    <updated>2017-06-29T08:02:23.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是还是nginx相关"><a href="#今天要分享的内容是还是nginx相关" class="headerlink" title="今天要分享的内容是还是nginx相关"></a>今天要分享的内容是还是nginx相关</h1><h1 id="Nginx-重写规则指南"><a href="#Nginx-重写规则指南" class="headerlink" title="Nginx 重写规则指南"></a>Nginx 重写规则指南</h1><p>既然你看到这里，我想，不用问，你也肯定知道，nginx是运维要玩的东西，开发不直接管，那么</p>
<p>记住一句话：<br>不懂程序的运维，不是好运维；不懂运维的开发，不是 好开发。</p>
<p>对于重写规则 说到底就是正则匹配，同时，如果想把 apache 转换成 nginx，重写规则也是要改的咯。</p>
<ol>
<li><p>rewrite 模块介绍</p>
<p>nginx 的重写模块是一个简单的正则表达式匹配与一个虚拟堆叠机结合。依赖于 PCRE 库，因此需要安装 pcre。根 据相关变量重定向和选择不同的配置，从一个 location 跳转到另一个 location，不过这样的循环最多可以执行 10 次，超过后 nginx 将返回 500 错误。同时，重写模块包含 set 指令，来创建新的变量并设其值，这在有些情景 下非常有用的，如记录条件标识、传递参数到其他 location、记录做了什么等等。</p>
</li>
<li><p>rewrite 模块指令</p>
<pre><code>break 
语法：break 默认值：none
使用字段：server, location, if 完成当前设置的重写规则，停止执行其他的重写规则。

if
语法：if (condition) { … } 默认值：none 
使用字段：server, location
注意：尽量考虑使用 trp_files 代替。 判断的条件可以有以下值：
1. 一个变量的名称：空字符传”“或者一些“0”开始的字符串为 false。
2. 字符串比较：使用=或!=运算符
3. 正则表达式匹配：使用~(区分大小写)和~*(不区分大小写)，取反运算!~和!~*。
4. 文件是否存在：使用-f 和!-f 操作符
5. 目录是否存在：使用-d 和!-d 操作符
7. 文件、目录、符号链接是否存在：使用-e 和!-e 操作符
8. 文件是否可执行：使用-x 和!-x 操作符

return 
语法：return code 默认值：none
使用字段：server, location, if
停止处理并为客户端返回状态码。非标准的 444 状态码将关闭连接，不发送任何响应头。】
可以使用的状态码有：
204，400，402-406，408，410, 411, 413, 416 与 500-504。如果状态码附带文字段落，该文本将被放置在响应 主体。相反，如果状态码后面是一个 URL，该 URL 将成为 location 头补值。没有状态码的 URL 将被视为一个 302 状态码。

rewrite
语法：rewrite regex replacement flag 默认值：none
使用字段：server, location, if
按照相关的正则表达式与字符串修改 URI，指令按照在配置文件中出现的顺序执行。可以在重写指令后面添加标记。
注意：如果替换的字符串以 http://开头，请求将被重定向，并且不再执行多余的 rewrite 指令。 

尾部的标记(flag)可以是以下的值：
last – 停止处理重写模块指令，之后搜索 location 与更改后的 URI 匹配。 
break – 完成重写指令。
redirect – 返回 302 临时重定向，如果替换字段用 http://开头则被使用。 
permanent – 返回 301 永久重定向。

rewrite_log 语法：rewrite_log on | off 默认值：rewrite_log off
使用字段：server, location, if 变量：无
启用时将在 error log 中记录 notice 级别的重写日志。

set
语法：set variable value 默认值：none  
使用字段：server, location, if 为给定的变量设置一个特定值。
uninitialized_variable_warn 
语法：uninitialized_variable_warn on|off 默认值：uninitialized_variable_warn on 
使用字段：http, server, location, if 控制是否记录未初始化变量的警告信息。
</code></pre></li>
</ol>
<ol>
<li>重写规则组成部分</li>
</ol>
<ul>
<li><p>任何重写规则的第一部分都是一个正则表达式 可以使用括号来捕获，后续可以根据位置来将其引用，位置变量值取决于捕获正则表达式中的顺序，$1 引用第一 个括号中的值，$2 引用第二个括号中的值，以此类推。如：</p>
<pre><code>^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$
</code></pre><p>$1 是两个小写字母组成的字符串，$2 是由小写字母和 0 到 9 的数字组成的 5 个字符的字符串，$3 将是个文件名，<br>$4 是 png、jpg、gif 中的其中一个。</p>
</li>
<li><p>重写规则的第二部分是 URI<br>请求被改写。该 URI 可能包含正则表达式中的捕获的位置参数或这个级别下的 nginx 任何配置变量。如：<br>/data?file=$3.$4<br>如果这个 URI 不匹配 nginx 配置的任何 location，那么将给客户端返回 301(永久重定向)或 302(临时重定向)的状 态码来表示重定向类型。该状态码可以通过第三个参数来明确指定。</p>
</li>
</ul>
<ul>
<li><p>重写规则的第三部分<br>第三部分也就是尾部的标记(flag)。 last 标记将导致重写后的 URI 搜索匹配 nginx 的其他 location，最多可循 环 10 次。如：</p>
<pre><code>rewrite    &apos;^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$&apos;    /data?file=$3.$4 last; break 指令可以当做自身指令。如：
if ($bwhog) {
limit_rate 300k; break;
}
</code></pre></li>
</ul>
<p>另一个停止重写模块处理指令是 return， 来控制主 HTTP 模块处理请求。 这意味着，nginx 直接返回信息给客户 端，与 error_page 结合为客户端呈现格式化的 HTML 页面或激活不同的模块来完成请求。如果状态码附带文字段 落，该文本将被放置在响应主体。相反，如果状态码后面是一个 URL，该 URL 将成为 location 头补值。没有状态 码的 URL 将被视为一个 302 状态码。如：</p>
<pre><code>location = /image404.html {
return    404    &quot;image not found\n&quot;;
}
</code></pre><ol>
<li><p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">#  定义 image 日志格式</div><div class="line">log_format imagelog &apos;[$time_local] &apos; $image_file &apos; &apos; $image_type &apos; &apos; $body_bytes_sent &apos; &apos; $status;</div><div class="line">#  开启重写日志</div><div class="line">rewrite_log on;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">root /home/www;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">#  重写规则信息</div><div class="line">error_log logs/rewrite.log notice;</div><div class="line">#  注意这里要用‘’单引号引起来，避免&#123;&#125;</div><div class="line">rewrite &apos;^/images/([a-z]&#123;2&#125;)/([a-z0-9]&#123;5&#125;)/(.*)\.(png|jpg|gif)$&apos; /data?file=$3.$4;</div><div class="line">#  注意不能在上面这条规则后面加上“last”参数，否则下面的 set 指令不会执行</div><div class="line">set $image_file $3; set $image_type $4;</div><div class="line">&#125;</div><div class="line">location /data &#123;</div><div class="line">#  指定针对图片的日志格式，来分析图片类型和大小</div><div class="line">access_log logs/images.log mian; root /data/images;</div><div class="line">#   应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最</div><div class="line"> </div><div class="line">后一个 url 里</div><div class="line"></div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line">try_files /$arg_file /image404.html;</div><div class="line"> </div><div class="line">location = /image404.html &#123;</div><div class="line">#  图片不存在返回特定的信息</div><div class="line">return 404 &quot;image not found\n&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>nginx 逻辑运算<br>nginx 的配置中不支持 if 条件的逻辑与&amp;&amp; 逻辑或|| 运算 ，而且不支持 if 的嵌套语法，否则会报下面的错误： nginx: [emerg] invalid condition。<br>我们可以用变量的方式来间接实现。 要实现的语句：</p>
<pre><code>if    ($arg_unitid = 42012 &amp;&amp; $uri ~/thumb/){ echo        &quot;www.ttlsa.com&quot;;
}
</code></pre></li>
</ol>
<p>   如果按照这样来配置，就会报 nginx: [emerg] invalid condition 错误。 可以这么来实现，如下所示：</p>
<pre><code>set    $flag 0;
if ($uri ~ ^/thumb/[0-9]+_160.jpg$){ set $flag &quot;${flag}1&quot;;
}
if ($arg_unitid = 42012){ set $flag &quot;${flag}1&quot;;
}
if ($flag = &quot;011&quot;){ echo &quot;www.ttlsa.com&quot;;
}
</code></pre><ol>
<li><p>隐藏 Nginx 版本号的安全性与方法</p>
<pre><code># vim nginx.conf
在 http {—}里加上 server_tokens off;    如：
</code></pre></li>
<li><p>nginx 正向代理</p>
<p>我们平时用的最多的最常见的是反向代理。那么 nginx 的正向代理是如何配置的呢？</p>
<pre><code>server {
listen 8090; location / {
resolver 218.85.157.99 218.85.152.99;
resolver_timeout 30s;
proxy_pass http://$host$request_uri;
}
access_log    /data/httplogs/proxy-$host-aceess.log;
}
</code></pre><p>就这么简单哈。  </p>
<p>resolver 指令<br>语法: resolver address … [valid=time]; 默认值: none<br>配置段: http, server, location<br>配置 DNS 服务器 IP 地址。可以指定多个，以轮询方式请求。<br>nginx 会缓存解析的结果。默认情况下，缓存时间是名字解析响应中的 TTL 字段的值，可以通过 valid 参数更改。</p>
<p>resolver_timeout 指令<br>语法: resolver_timeout time; 默认值: resolver_timeout 30s;<br>配置段: http, server, location 解析超时时间。</p>
</li>
<li><p>nginx的最大好处，例子解释</p>
</li>
</ol>
<p>由于公司内网有多台服务器的 http 服务要映射到公司外网静态 IP，如果用路由的端口映射来做，就只能一台内网 服务器的 80 端口映射到外网 80 端口，其他服务器的 80 端口只能映射到外网的非 80 端口。非 80 端口的映射在访<br>问的时候要域名加上端口，比较麻烦。并且公司入口路由最多只能做 20 个端口映射。肯定以后不够用。<br>然后 k 兄就提议可以在内网搭建个 nginx 反向代理服务器，将 nginx 反向代理服务器的 80 映射到外网 IP 的 80， 这样指向到公司外网 IP 的域名的 HTTP 请求就会发送到 nginx 反向代理服务器，利用 nginx 反向代理将不同域名 的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器 的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>关于一些，高级的概念，还有第三方模块，这些内容就不属于入门级别的了</p>
<p>这两篇的意义，在于，你能初步，能看懂nginx的配置文件，每个配置的含义，以及初步的开发跳转，基本足够了</p>
<p>等后续，碰到这些高级的概念或者应用的时候，在去看</p>
<p>不是为了单纯的学习而学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是还是nginx相关&quot;&gt;&lt;a href=&quot;#今天要分享的内容是还是nginx相关&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是还是nginx相关&quot;&gt;&lt;/a&gt;今天要分享的内容是还是nginx相关&lt;/h1&gt;&lt;h1 id=&quot;N
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx入门系列一</title>
    <link href="http://ghohankawk.github.io/2017/06/28/nginx/"/>
    <id>http://ghohankawk.github.io/2017/06/28/nginx/</id>
    <published>2017-06-28T07:45:35.736Z</published>
    <updated>2017-06-29T04:20:51.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是nginx的基本知识"><a href="#今天要分享的内容是nginx的基本知识" class="headerlink" title="今天要分享的内容是nginx的基本知识"></a>今天要分享的内容是nginx的基本知识</h1><h1 id="先看一下conf文件解释"><a href="#先看一下conf文件解释" class="headerlink" title="先看一下conf文件解释"></a>先看一下conf文件解释</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"># vi nginx.conf</div><div class="line"></div><div class="line">user	nobody nobody; #	运行 nginx 的所属组和所有者</div><div class="line"></div><div class="line">worker_processes	2; #	开启两个 nginx 工作进程,一般几个 CPU 核心就写几 </div><div class="line"></div><div class="line">error_log	logs/error.log	notice; #	错误日志路径</div><div class="line"></div><div class="line">pid	logs/nginx.pid; # pid 路径 </div><div class="line"></div><div class="line">events &#123;</div><div class="line">    worker_connections	1024; #	一个进程能同时处理 1024 个请求</div><div class="line">    &#125;</div><div class="line">http &#123;</div><div class="line"></div><div class="line">include		mime.types; </div><div class="line"></div><div class="line">default_type	application/octet-stream;</div><div class="line"></div><div class="line">log_format	main	‘$remote_addr – $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘</div><div class="line">‘”$http_user_agent” “$http_x_forwarded_for”‘; </div><div class="line"></div><div class="line">access_log	logs/access.log	main; #	默认访问日志路径 sendfile		on;</div><div class="line"></div><div class="line">keepalive_timeout	65; # keepalive 超时时间</div><div class="line"></div><div class="line">#	开始配置一个域名,一个 server 配置段一般对应一个域名 </div><div class="line"></div><div class="line">server &#123;</div><div class="line">    </div><div class="line">listen	80; </div><div class="line"></div><div class="line">#	在本机所有 ip 上监听 80,也可以写为 192.168.1.202:80,这样的话,就只监听 192.168.1.202 上的 80 口 </div><div class="line"></div><div class="line">server_name	www.heytool.com; #	域名</div><div class="line"></div><div class="line">root		/www/html/www.heytool.com; #	站点根目录（程序目录）</div><div class="line"></div><div class="line">index	index.html index.htm; #	索引文件</div><div class="line"></div><div class="line">location / &#123;	#	可以有多个 location</div><div class="line">    root	/www/html/www.heytool.com; #	站点根目录（程序目录）</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">error_page	500 502 503 504	/50x.html;</div><div class="line"></div><div class="line">#	定义错误页面,如果是 500 错误,则把站点根目录下的 50x.html 返回给用户 </div><div class="line"></div><div class="line">location = /50x.html &#123;</div><div class="line">    root	/www/html/www.heytool.com;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#	开始配置站点</div><div class="line"> </div><div class="line">bbs.heytool.com server &#123;</div><div class="line">    listen	80;</div><div class="line">    server_name	bbs.heytool.com;  </div><div class="line">    root	/www/html/bbs.heytool.com;</div><div class="line">    index	index.html index.htm; #	索引文件 </div><div class="line">    location / &#123;</div><div class="line">    root	/www/html/bbs.heytool.com;</div><div class="line">      &#125;</div><div class="line">    error_page	500 502 503 504	/50x.html; </div><div class="line">    location = /50x.html &#123;</div><div class="line">    root	/www/html/bbs.heytool.com;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="nginx-启动，测试，关闭，重启"><a href="#nginx-启动，测试，关闭，重启" class="headerlink" title="nginx 启动，测试，关闭，重启"></a>nginx 启动，测试，关闭，重启</h1><pre><code># /usr/local/nginx-1.0.6/sbin/nginx    //启动 nginx
# /usr/local/nginx-1.0.6/sbin/nginx –t //测试 nginx 配置文件的准确性
# /usr/local/nginx-1.0.6/sbin/nginx –s reload //重载 nginx
# /usr/local/nginx-1.0.6/sbin/nginx –s stop //关闭 nginx
</code></pre><h1 id="nginx-配置虚拟主机"><a href="#nginx-配置虚拟主机" class="headerlink" title="nginx 配置虚拟主机"></a>nginx 配置虚拟主机</h1><p>也就是我们通常说的配置域名.</p>
<pre><code>server_name：虚拟主机的域名，可以写多个域名，类似于别名，比如说你可以配置成
server_name b.ttlsa.com c.ttlsa.com d.ttlsa.com，这样的话，访问任何一个域名，内容都是一样的 listen 80，监听 ip 和端口，这边仅仅只有端口，表示当前服务器所有 ip 的 80 端口，如果只想监听 127.0.0.1 的 80，写法如下：
listen 127.0.0.1:80
root /data/site/b.ttlsa.com：站点根目录，你网站文件存放的地方。注：站点目录和域名尽量一样，养成一个 好习惯
access_log /data/logs/nginx/b.ttlsa.com-access.log main：访问日志 location /{}
</code></pre><h1 id="nginx-location-配置"><a href="#nginx-location-配置" class="headerlink" title="nginx location 配置"></a>nginx location 配置</h1><p>语法规则： location [=|~|~*|^~] /uri/ { … }</p>
<ol>
<li>= 表示精确匹配,这个优先级也是最高的</li>
<li>^~ 表示 uri 以某个常规字符串开头，理解为匹配 url 路径即可。<br>nginx 不对 url 做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa 匹配到（注意是空格）。</li>
<li>~    表示区分大小写的正则匹配</li>
<li>~* 表示不区分大小写的正则匹配(和上面的唯一区别就是大小写)</li>
<li>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则</li>
<li>/ 通用匹配，任何请求都会匹配到，默认匹配. </li>
</ol>
<p>多个 location 配置的情况下匹配顺序为：</p>
<p>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止 匹配，按当前匹配规则处理请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">例子，有如下匹配规则： </div><div class="line">location / </div><div class="line">    &#123;</div><div class="line">        echo &quot;/&quot;; //需要安装 echo 模块才行,这边大家可以改成各自的规则</div><div class="line">    &#125;</div><div class="line">location = / </div><div class="line">    &#123; </div><div class="line">    echo &quot;=/&quot;;</div><div class="line">    &#125;</div><div class="line">location = /nginx </div><div class="line">    &#123; </div><div class="line">    echo &quot;=/nginx&quot;;</div><div class="line">    &#125;</div><div class="line">location ~ \.(gif|jpg|png|js|css)$ </div><div class="line">    &#123; echo &quot;small-gif/jpg/png&quot;;</div><div class="line">    &#125;</div><div class="line">location ~* \.png$ </div><div class="line">    &#123; echo &quot;all-png&quot;;</div><div class="line">    &#125;</div><div class="line">location ^~ /static/ </div><div class="line">    &#123; echo &quot;static&quot;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>那么</p>
<ol>
<li><a href="http://a.ttlsa.com/，完全匹配=/" target="_blank" rel="external">http://a.ttlsa.com/，完全匹配=/</a></li>
<li><a href="http://a.ttlsa.com/nginx,完全匹配了”=/nginx”" target="_blank" rel="external">http://a.ttlsa.com/nginx,完全匹配了”=/nginx”</a></li>
<li><a href="http://a.ttlsa.com/xxx/1111.PNG" target="_blank" rel="external">http://a.ttlsa.com/xxx/1111.PNG</a> （注意,这是大写），最后匹配到了~* .png$</li>
<li><a href="http://a.ttlsa.com/static/1111.png,虽然" target="_blank" rel="external">http://a.ttlsa.com/static/1111.png,虽然</a> static 放在最后面,但是因为有^的缘故,他是最匹配的.</li>
</ol>
<h1 id="nginx-root-amp-alias-文件路径配置"><a href="#nginx-root-amp-alias-文件路径配置" class="headerlink" title="nginx root&amp;alias 文件路径配置"></a>nginx root&amp;alias 文件路径配置</h1><p>nginx 指定文件路径有两种方式 root 和 alias，root 与 alias 主要区别在于 nginx 如何解释 location 后面的 uri，这会使两者分别以不同的方式将请求映射到 服务器文件上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">例子一：</div><div class="line">location ~ ^/weblogs/ &#123;</div><div class="line">root /data/weblogs/www.ttlsa.com; autoindex on;</div><div class="line">auth_basic	&quot;Restricted&quot;; auth_basic_user_file	passwd/weblogs;</div><div class="line">&#125;</div><div class="line">如果一个请求的 URI 是/weblogs/httplogs/www.ttlsa.com-access.log 时，web 服务器将会返回服务器上的</div><div class="line">/data/weblogs/www.ttlsa.com/weblogs/httplogs/www.ttlsa.com-access.log 的文件。 [info]root 会根据完整的 URI 请求来映射，也就是/path/uri。[/info] 因此，前面的请求映射为 path/weblogs/httplogs/www.ttlsa.com-access.log。</div><div class="line"></div><div class="line">例子二：</div><div class="line"></div><div class="line"></div><div class="line">location ^~ /binapp/ &#123;</div><div class="line">limit_conn limit 4; limit_rate 200k; internal;</div><div class="line">alias /data/statics/bin/apps/;</div><div class="line">&#125;</div><div class="line">alias 会把 location 后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。如果一个请求的 URI 是</div><div class="line">/binapp/a.ttlsa.com/favicon 时，web 服务器将会返回服务器上的</div><div class="line">/data/statics/bin/apps/a.ttlsa.com/favicon.jgp 的文件。 [warning]1. 使用 alias 时，目录名后面一定要加”/”。</div><div class="line">2. alias 可以指定任何名称。</div><div class="line">3. alias 在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</div><div class="line">4.	alias 只能位于 location 块中。[/warning]</div></pre></td></tr></table></figure></p>
<p>总结一下，就是，root相当于是根，特别之处根是在什么地方，</p>
<p>而alias是别号，也就是映射的那个路径，还可以是其他的别的地方，因此本身要去掉</p>
<h1 id="nginx变量"><a href="#nginx变量" class="headerlink" title="nginx变量"></a>nginx变量</h1><p>ngx_http_core_module 模块提供了大量的变量</p>
<pre><code>参数名称    注释
$arg_PARAMETER    HTTP 请求中某个参数的值，如/index.php?site=www.ttlsa.com，可以用$arg_site 取 得 www.ttlsa.com 这个值.
$args HTTP    请求中的完整参数。例如，在请求/index.php?width=400&amp;height=200 中，$args 表示 字符串 width=400&amp;height=200.
$binary_remote_addr    二进制格式的客户端地址。例如：\x0A\xE0B\x0E
$body_bytes_sent       表示在向客户端发送的 http 响应中，包体部分的字节数
$content_length         表示客户端请求头部中的 Content-Length 字段
$content_type    表示客户端请求头部中的 Content-Type 字段
$cookie_COOKIE          表示在客户端请求头部中的 cookie 字段
$document_root          表示当前请求所使用的 root 配置项的值
$uri    表示当前请求的 URI，不带任何参数
$document_uri    与$uri 含义相同
$request_uri    表示客户端发来的原始请求 URI，带完整的参数。$uri 和$document_uri 未必是用户的 原始请求，在内部重定向后可能是重定向后的 URI，而$request_uri 永远不会改变，始终是客户端的原始 URI.
$host    表示客户端请求头部中的 Host 字段。如果 Host 字段不存在，则以实际处理的 server
（虚拟主机）名称代替。如果 Host 字段中带有端口，如 IP:PORT，那么$host 是去掉端口的，它的值为 IP。$host 是全小写的。这些特性与 http_HEADER 中的 http_host 不同，http_host 只取出 Host 头部对应的值。
$hostname    表示 Nginx 所在机器的名称，与 gethostbyname 调用返回的值相同
$http_HEADER    表示当前 HTTP 请求中相应头部的值。HEADER 名称全小写。例如，示请求中 Host 头部 对应的值    用 $http_host 表
$sent_http_HEADER    表示返回客户端的 HTTP 响应中相应头部的值。HEADER 名称全小写。例如，用 $sent_ http_content_type 表示响应中 Content-Type 头部对应的值
$is_args    表示请求中的 URI 是否带参数，如果带参数，$is_args 值为 ?，如果不带参数，则是 空字符串
$limit_rate    表示当前连接的限速是多少，0 表示无限速
$nginx_version          表示当前 Nginx 的版本号
$query_string    请求 URI 中的参数，与 $args 相同，然而 $query_string 是只读的不会改变
$remote_addr    表示客户端的地址
$remote_port    表示客户端连接使用的端口
$remote_user    表示使用 Auth Basic Module 时定义的用户名
$request_filename     表示用户请求中的 URI 经过 root 或 alias 转换后的文件路径
$request_body    表示 HTTP 请求中的包体，该参数只在 proxy_pass 或 fastcgi_pass 中有意义
$request_body_file      表示 HTTP 请求中的包体存储的临时文件名
$request_completion    当请求已经全部完成时，其值为 “ok”。若没有完成，就要返回客户端，则其值为空字 符串；或者在断点续传等情况下使用 HTTP range 访问的并不是文件的最后一块，那么其值也是空字符串。
$request_method        表示 HTTP 请求的方法名，如 GET、PUT、POST 等
$scheme    表示 HTTP scheme，如在请求 https://nginx.com/中表示 https
$server_addr    表示服务器地址
$server_name    表示服务器名称
$server_port    表示服务器端口
$server_protocol        表示服务器向客户端发送响应的协议，如 HTTP/1.1 或 HTTP/1.0
</code></pre><h1 id="nginx-日志配置"><a href="#nginx-日志配置" class="headerlink" title="nginx 日志配置"></a>nginx 日志配置</h1><p>日志对于统计排错来说非常有利的。 日志格式通过 log_format 命令来定义。ngx_http_log_module 是用来定义请求日志格式的。</p>
<ol>
<li>access_log<br>语法: access_log path [format [buffer=size [flush=time]]];<br>默认值: access_log logs/access.log combined;</li>
<li>log_format 指令<br>语法: log_format name string …;<br>默认值: log_format combined “…”<br>有一个默认的无需设置的 combined 日志格式，相当于 apache 的 combined 日志格式，如下所示：</li>
</ol>
<pre><code>log_format    combined    &apos;$remote_addr - $remote_user    [$time_local]    &apos;
&apos; &quot;$request&quot;    $status    $body_bytes_sent    &apos; &apos; &quot;$http_referer&quot;    &quot;$http_user_agent&quot; &apos;;


log_format    proxy    &apos;$http_x_forwarded_for - $remote_user    [$time_local]    &apos; &apos; &quot;$request&quot;    $status $body_bytes_sent &apos;
&apos; &quot;$http_referer&quot;    &quot;$http_user_agent&quot; &apos;; 
</code></pre><ol>
<li>日志格式变量</li>
</ol>
<pre><code>$remote_addr, $http_x_forwarded_for 记录客户端 IP 地址
$remote_user 记录客户端用户名称
$request 记录请求的 URL 和 HTTP 协议
$status 记录请求状态
$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与 Apache 模块 mod_log_config 里的 “%B”参数兼容。
$bytes_sent 发送给客户端的总字节数。
$connection 连接的序列号。
$connection_requests 当前通过一个连接获得的请求数量。
$msec 日志写入时间。单位为秒，精度是毫秒。
$pipe 如果请求是通过 HTTP 流水线(pipelined)发送，pipe 值为“p”，否则为“.”。
$http_referer 记录从哪个页面链接访问过来的
$http_user_agent 记录客户端浏览器相关信息
$request_length 请求的长度（包括请求行，请求头和请求正文）。
$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送 给客户端后进行日志写入为止。
$time_iso8601 ISO8601 标准格式下的本地时间。
$time_local 通用日志格式下的本地时间。
</code></pre><ol>
<li><p>open_log_file_cache 指令</p>
<p>语法: open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time]; open_log_file_cache off;<br>默认值: open_log_file_cache off;<br>配置段: http, server, location<br>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用 open_log_file_cache 来设置日志 文件缓存(默认是 off)，格式如下：<br>参数注释如下：<br>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用 LRU 算法将描述符关闭。 inactive:设置存活时间，默认是 10s<br>min_uses:设置在 inactive 时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是 1 次 valid:设置检查频率，默认 60s<br>off：禁用缓存 实例如下：</p>
<pre><code>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</code></pre></li>
<li><p>log_not_found 指令</p>
<p> 语法: log_not_found on | off;<br> 默认值: log_not_found on;<br> 配置段: http, server, location<br> 是否在 error_log 中记录不存在的错误。默认是。</p>
</li>
<li><p>log_subrequest 指令</p>
<p>语法: log_subrequest on | off;<br>默认值: log_subrequest off;<br>配置段: http, server, location<br>是否在 access_log 中记录子请求的访问日志。默认不记录。</p>
</li>
<li><p>rewrite_log 指令</p>
<p>由 ngx_http_rewrite_module 模块提供的。用来记录重写日志的。对于调试重写规则建议开启。    Nginx 重写规则 指南<br>语法: rewrite_log on | off; 默认值: rewrite_log off;<br>配置段: http, server, location, if<br>启用时将在 error log 中记录 notice 级别的重写日志。</p>
</li>
<li><p>error_log 指令</p>
<p>语法: error_log file | stderr | syslog:server=address[,parameter=value] [debug | info | notice | warn | error | crit | alert | emerg];<br>默认值: error_log logs/error.log error;<br>配置段: main, http, server,<br>location 配置错误日志。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是nginx的基本知识&quot;&gt;&lt;a href=&quot;#今天要分享的内容是nginx的基本知识&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是nginx的基本知识&quot;&gt;&lt;/a&gt;今天要分享的内容是nginx的基本知识&lt;/h1&gt;&lt;h1 i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中string的不可不知的编码知识</title>
    <link href="http://ghohankawk.github.io/2017/06/27/java-encode/"/>
    <id>http://ghohankawk.github.io/2017/06/27/java-encode/</id>
    <published>2017-06-27T12:00:21.421Z</published>
    <updated>2017-06-27T12:38:31.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java的string的字符串编码"><a href="#今天要分享的内容是java的string的字符串编码" class="headerlink" title="今天要分享的内容是java的string的字符串编码"></a>今天要分享的内容是java的string的字符串编码</h1><h1 id="首先记住一句话，字符串在-java-内存中总是按-unicode-编码存储的"><a href="#首先记住一句话，字符串在-java-内存中总是按-unicode-编码存储的" class="headerlink" title="首先记住一句话，字符串在 java 内存中总是按 unicode 编码存储的"></a>首先记住一句话，字符串在 java 内存中总是按 unicode 编码存储的</h1><h1 id="先看一个测试用例"><a href="#先看一个测试用例" class="headerlink" title="先看一个测试用例"></a>先看一个测试用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-27 14:24</div><div class="line"> */</div><div class="line">public class unicode &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 字符串转换unicode</div><div class="line">     */</div><div class="line">    public static String string2Unicode(String string) &#123;</div><div class="line"></div><div class="line">        StringBuffer unicode = new StringBuffer();</div><div class="line">        for (int i = 0; i &lt; string.length(); i++) &#123;</div><div class="line"></div><div class="line">            // 取出每一个字符</div><div class="line">            char c = string.charAt(i);</div><div class="line"></div><div class="line">            // 转换为unicode</div><div class="line">            unicode.append(&quot;\\u&quot; + Integer.toHexString(c));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return unicode.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * unicode 转字符串</div><div class="line">     */</div><div class="line">    public static String unicode2String(String unicode) &#123;</div><div class="line"></div><div class="line">        StringBuffer string = new StringBuffer();</div><div class="line"></div><div class="line">        String[] hex = unicode.split(&quot;\\\\u&quot;);</div><div class="line"></div><div class="line">        for (int i = 1; i &lt; hex.length; i++) &#123;</div><div class="line"></div><div class="line">            // 转换出每一个代码点</div><div class="line">            int data = Integer.parseInt(hex[i], 16);</div><div class="line"></div><div class="line">            // 追加成string</div><div class="line">            string.append((char) data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return string.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 测试字符串长度</div><div class="line">     */</div><div class="line">    public static void stringLength(String string) &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;String is = &quot; + string+&quot; ,default length = &quot;+ string.length());</div><div class="line">        System.out.println(&quot;String is = &quot; + string+&quot; ,getBytes length = &quot;+ string.getBytes().length);</div><div class="line">        System.out.println(&quot;String 中包含 &quot; + (string.getBytes().length-string.length())+&quot; 个中文&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String test = &quot;中文ab&quot;;</div><div class="line"></div><div class="line">        String unicode = string2Unicode(test);</div><div class="line"></div><div class="line">        String string = unicode2String(unicode) ;</div><div class="line"></div><div class="line">        System.out.println(unicode);</div><div class="line"></div><div class="line">        System.out.println(string);</div><div class="line">        String test1 = &quot;中文&quot;;</div><div class="line">        String test2 = &quot;ab&quot;;</div><div class="line">        stringLength(test);</div><div class="line">        stringLength(test1);</div><div class="line">        stringLength(test2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子里面，还提供了一个，快速判断，字符串中，包含的中文个数方法</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>首先，Java中的一个char是2个字节。java采用unicode，2个字节来表示一个字符，这点与C语言中不同，c语言中采用ASCII，在大多数系统中，一个char通常占1个字节，但是在0~127整数之间的字符映射，unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节，但如果采用其他编码方式，一个字符占用的字节数则各不相同。</p>
<p>在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。</p>
<pre><code>我的系统的默认编码方式为GBK，因此对于字符串 “中文ab”，
 如果调用length（）方法返回其长度，得到的结果将为：4。该方法返回的是字符串的字符数，无论是中文字符还是英文字符，都被看做是一个字符。
 如果将其转换为byte数组，而后返回byte数组的长度，得到的结果将为：6。因为在GBK编码中，中文占2个字节，而英文字符占1个字节。
</code></pre><h1 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h1><p>  字符：人们使用的记号，抽象意义上的一个符号。比如：‘1’,‘中’,‘a’</p>
<p>  字节：计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间</p>
<p>  字符集：使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。</p>
<p>  编码：规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码” </p>
<p>  平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p>
<h1 id="iso8859－1"><a href="#iso8859－1" class="headerlink" title="iso8859－1"></a>iso8859－1</h1><p>属于单字节编码，最多能表示的字符范围是 0-255，应用于英文系列。比如，字母 ‘a’ 的编码为0x61=97。 很明显，iso8859-1 编码表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用 iso8859-1 编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在 iso8859-1 编码，以 gb2312 编码为例，应该是”d6d0 cec4” 两个字符，使用 iso8859-1 编码的时候则将它拆开为 4 个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是 UTF 编码，则是 6 个字节 “e4 b8 ad e6 96 87”。很明显，这种表示方法还需要以另一种编码为基础。（unicode）</p>
<h1 id="GB2312-GBK"><a href="#GB2312-GBK" class="headerlink" title="GB2312/GBK"></a>GB2312/GBK</h1><p>这是汉字的国标码，专门用来表示汉字，是双字节编码，而英文字母和 iso8859-1 一致（兼容iso8859-1 编码）。其中 gbk 编码能够用来同时表示繁体字和简体字，而 gb2312 只能表示简体字，gbk是兼容gb2312 编码的。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>这是最统一的编码，可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容 iso8859-1 编码的，也不兼容任何编码。不过，相对于iso8859-1 编码来说，unicode 编码只是在前面增加了一个 0 字节，比如字母 ‘a’ 为 “00 61”。 需要说明的是，定长编码便于计算机处理（注意 GB2312/GBK 不是定长编码），而 unicode 又可以用来表示所有字符，所以在很多软件内部是使用 unicode 编码来处理的，比如 java。</p>
<h1 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h1><p>考虑到 unicode 编码不兼容 iso8859-1 编码，而且容易占用更多的空间：因为对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便于传输和存储。因此而产生了 utf 编码，utf 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符，不过，utf 编码是不定长编码，每一个字符的长度从1-6个字节不等。另外，utf 编码自带简单的校验功能。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节。注意，虽然说utf是为了使用更少的空间而使用的，但那只是相对于 unicode编码来说，如果已经知道是汉字，则使用 GB2312/GBK 无疑是最节省的。不过另一方面，值得说明的是，虽然 utf 编码对汉字使用3个字节，但即使对于汉字网页，utf 编码也会比 unicode 编码节省，因为网页中包含了很多的英文字符。</p>
<h1 id="getBytes-charset"><a href="#getBytes-charset" class="headerlink" title="getBytes(charset)"></a>getBytes(charset)</h1><pre><code>这是 java 字符串处理的一个标准函数，其作用是将字符串所表示的字符按照 charset 编码，并以字节方式表示。
注意字符串在 java 内存中总是按 unicode 编码存储的。
当Java程序从输入流、文件或字符文字量等途径获得字符串时，均会做字符编码的转换，例如InputStreamReader 的构造函数中就需要指定编码方式，而对于从文件和字符文字量中获得字符串时，均采用系统默认的编码方式对字符数据进行解码。
</code></pre><p>考虑下面一段代码： </p>
<pre><code>String str=”中”;
① byte[] bytes = str.getBytes();
② bytes = str.getBytes(“ISO-8859-1”);
</code></pre><p> 语句①：将一个只含有一个字符“中”的字符串文字量赋给 String 类的一个对象 str，字符文字量“中”是按照操作系统默认编码方式进行编码，在中文 windows 系统中通常是“GBK”，“中”在GBK编码中是0xD6D0，在将该字符赋给str时，Java会对该字符串进行编码转换，即将GBK编码方式的“中”转换成Unicode编码方式的“中”，Unicode编码方式“中”的编码是0x4E2D，所以str在程序运行期间在内存中的二进制表示成16进制就是0x4E2D。</p>
<p> 语句②：获得str字符串的二进制形式。getBytes(String encoding)方法需要指定编码方式，表示获得该字符串在何种编码方式中的二进制形式。此语句中没有设置参数，表示采用操作系统默认的编码方式，即此处获得的bytes是“中”在GBK编码中的二进制形式，即bytes[0]=0xD6, bytes[1]=0xD0。</p>
<p> 语句③：该语句与语句②的区别就是指定了编码方式，此处指定的是ISO-8859-1，即通常所说的Latin-1，该编码采用8bit对字符编码，所以编码空间中只有256个字符。该编码中只包含了基本的ASCII码和一些扩展的其它西欧字符，所以该字符集中不可能包含中文的“中”字，也就是说Java虚拟机无法在ISO-8859-1编码集中找到“中”字对应的编码，针对这种情况，就只返回一个问号(?,0x3f)字符，所以此时bytes.length只有1，且bytes[0]=0x3f。</p>
<h1 id="new-String-byte-bytes-String-encoding"><a href="#new-String-byte-bytes-String-encoding" class="headerlink" title="new String(byte[] bytes, String encoding)"></a>new String(byte[] bytes, String encoding)</h1><pre><code>getBytes()方法从字符串获得二进制的字节数组。如果要从二进制的字节数组获得字符串，则就需要使用new String(byte[] bytes, String encoding)方法，该方法按照encoding编码方法对字节数组bytes中的二进制数组进行解析，生成一个新的字符串对象。

  byte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};
  ① String str = new String(bytes);
  ② str = new String(bytes,”ISO-8859-1”);
</code></pre><p>语句①：定义一个字节数组。</p>
<p>语句②：将该字节数组中的二进制数据按照默认的编码方式（GBK）编码成字符串，我们知道GBK中0xD6 0xD0表示“中”，0x31表示字符“1”（GBK兼容ASCII，但不兼容ISO-8859-1除ASCII之外的部分），所以str得到的值是“中1”。</p>
<p>语句③：该句用ISO-8859-1编码方式对该字节数据进行编码，由于在ISO-8859-1编码方式中一个字节会被解析成一个字符，所以该字节数组会被解释成包含三个字符的字符串，但由于在ISO-8859-1编码方式中没有对应0xD6和0xD0的字符，所以前两个字符会产生两个问号，由于0x31在ISO-8859-1编码中对应字符“1”（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我相信看了，上面这么些背景知识，是不是以前，不清楚的东西，都有写明白了？多看几次，就更能理解了 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java的string的字符串编码&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java的string的字符串编码&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java的string的字符串编码&quot;&gt;&lt;/a&gt;今天要分享的内容
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中String的getBytes的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/26/java-getBytes/"/>
    <id>http://ghohankawk.github.io/2017/06/26/java-getBytes/</id>
    <published>2017-06-26T12:30:03.233Z</published>
    <updated>2017-06-26T12:37:59.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java的string方法getBytes"><a href="#今天要分享的内容是java的string方法getBytes" class="headerlink" title="今天要分享的内容是java的string方法getBytes"></a>今天要分享的内容是java的string方法getBytes</h1><h1 id="先看一个测试用例"><a href="#先看一个测试用例" class="headerlink" title="先看一个测试用例"></a>先看一个测试用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-26 20:28</div><div class="line"> */</div><div class="line">public class testGetBytes &#123;</div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * 1、Unicode是一种编码规范，是为解决全球字符通用编码而设计的，而rUTF-8,UTF-16等是这种规范的一种实现。</div><div class="line"></div><div class="line">     2、java内部采用Unicode编码规范，也就是支持多语言的，具体采用的UTF-16编码方式。</div><div class="line"></div><div class="line">     3、不管程序过程中用到了gbk,iso8859-1等格式，在存储与传递的过程中实际传递的都是Unicode编码的数据，要想接收到的值不出现乱码，就要保证传过去的时候用的是A编码，接收的时候也用A编码来转换接收。</div><div class="line"></div><div class="line">     4、如果双方的file.encoding确保都相同，那就省事了，都默认转了，但往往在不同项目交互时很多时候是不一致的，这个时候是必须要进行编码转换的。</div><div class="line"></div><div class="line">     5、无论如论转换，java程序的数据都是要先和Unicode做转换，这样也就是能处理多语言字符集的原因了。底层保持了一致，只要在传值和接值的时候也一致就肯定不会出现乱码了。</div><div class="line">     * */</div><div class="line"></div><div class="line">    public static void main(String[] args) throws UnsupportedEncodingException &#123;</div><div class="line"></div><div class="line"></div><div class="line">        String str = &quot;中文字符&quot;;</div><div class="line"></div><div class="line">        System.out.println(&quot;original string---&quot; + str);// 会正常输出原始串</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         * str.getBytes();  如果括号中不写charset，则采用的是Sytem.getProperty(&quot;file.encoding&quot;),即当前文件的编码方式，</div><div class="line">         *</div><div class="line">         * 很多人写的是系统的默认编码，通过代码测试并非如此，实际得到的是文件的编码方式*</div><div class="line">         *</div><div class="line">         * str.getBytes(&quot;charset&quot;);//指定charset，即将底层存储的Unicode码解析为charset编码格式的字节数组方式</div><div class="line">         *</div><div class="line">         * String new_str=new String(str.getBytes(&quot;utf-8&quot;),&quot;gbk&quot;));</div><div class="line">         *</div><div class="line">         * //将已经解析出来的字节数据转化为gbk编码格式的字符串，在内存中即为gbk格式的字节数组转为Unicode去交互传递</div><div class="line">         */</div><div class="line"></div><div class="line">        String new_str = new String(str.getBytes(&quot;utf-8&quot;), &quot;gbk&quot;);</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         * 此时的输出是乱码，在UTF-8的file.encoding下输出gbk格式的数据肯定是乱码,但是new_str的确是gbk编码式的</div><div class="line">         *</div><div class="line">         * 此时的乱码源于encoding不符，但gbk格式的new_str本身数据并没有问题,通过下面的转换也可以看得出来</div><div class="line">         */</div><div class="line"></div><div class="line">        System.out.println(&quot;new string----&quot; + new_str);</div><div class="line"></div><div class="line">        String final_str = new String(new_str.getBytes(&quot;gbk&quot;), &quot;utf-8&quot;);// 此处的含意与最上边的注释是一致的参数含意</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         *输出是正常的，此时将gbk编码格式的new_str字符串，用gbk这个charset去解析它，然后用utf-8再转码一次，</div><div class="line">         *</div><div class="line">         * 因为new_str确实是gbk格式的，才能经过utf-8编码得到正常的数据显示。</div><div class="line">         */</div><div class="line"></div><div class="line">        System.out.println(&quot;final string---&quot; + final_str);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常说明，要干什么，再加一个链接按钮 <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">xxx</a>. </p>
<h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><pre><code>1. 首先，你要明白，什么是uinicode，她和utf-8，以及utf-16，是什么关系
2. 其实，你要知道，java中是用了，utf-16
3. 再深入一点，就是，你也必须知道byte这个类型，就是所谓的字节数组了
4. 他和int的区别，怎么转换
5. byte数组里面存储的内容，怎么转换成对应的中文字符的？什么编码映射关系，转过去的？
6. 还有就是，你会经常看到0xff，这种，还有&amp;，按位于的这种操作，具体是什么含义
7. 大小端的问题，是什么意思？在网络里面如何区分？
</code></pre><p>这个地方，之前其实就一直看过，每次看完一遍，以为真的懂了，但是，过后，还是不知道，啥原理</p>
<p>这次，写过了，可能过一段时间又忘记了，但是，如果真正的理解了原理的话，就难忘记了</p>
<p>这个地方，不管前后端，都必须掌握</p>
<p>去看ruan大神的，那片，unicode文章，绝对有收获。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java的string方法getBytes&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java的string方法getBytes&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java的string方法getBytes&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Java中的ThreadLocal用法</title>
    <link href="http://ghohankawk.github.io/2017/06/20/java-threadlocal/"/>
    <id>http://ghohankawk.github.io/2017/06/20/java-threadlocal/</id>
    <published>2017-06-20T12:24:34.672Z</published>
    <updated>2017-06-20T12:43:18.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java中的ThreadLocal"><a href="#今天要分享的内容是java中的ThreadLocal" class="headerlink" title="今天要分享的内容是java中的ThreadLocal"></a>今天要分享的内容是java中的ThreadLocal</h1><p>并发编程中，一个重要的内容是数据共享。当你创建了实现Runnable接口的线程，然后开启使用相同Runnable实例的各种Thread对象，所有 的线程便共享定义在Runnable对象中的属性。也就是说，当你在一个线程中改变任意属性时，所有的线程都会因此受到影响，同时会看到第一个线程修改后的值。有时我们希望如此，比如：多个线程增大或减小同一个计数器变量；但是，有时我们希望确保每个线程，只能工作在它自己的线程实例的拷贝上，同时不会影 响其他线程的数据。</p>
<h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>  ThreadLocal是一个关于创建线程局部变量的类。</p>
<p>  通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。</p>
<ul>
<li>在当前线程中，任何一个点都可以访问到ThreadLocal的值。</li>
<li>该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。</li>
</ul>
<h1 id="如何创建ThreadLocal变量"><a href="#如何创建ThreadLocal变量" class="headerlink" title="如何创建ThreadLocal变量"></a>如何创建ThreadLocal变量</h1><pre><code>private ThreadLocal myThreadLocal = new ThreadLocal();
</code></pre><p>  通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。</p>
<h1 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h1><ol>
<li><p>创建，支持泛型</p>
<p>ThreadLocal<string> mStringThreadLocal = new ThreadLocal&lt;&gt;();</string></p>
</li>
<li><p>set方法</p>
<p>mStringThreadLocal.set(“hank”);</p>
</li>
<li><p>get方法</p>
<p>mStringThreadLocal.get();</p>
</li>
<li>initialValue()：返回当前线程赋予局部线程变量的初始值。<h1 id="具体用例"><a href="#具体用例" class="headerlink" title="具体用例"></a>具体用例</h1></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-20 20:33</div><div class="line"> */</div><div class="line">public class threadlocal &#123;</div><div class="line">    public static class MyRunnable implements Runnable &#123;</div><div class="line"></div><div class="line">        private ThreadLocal threadLocal = new ThreadLocal();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            threadLocal.set((int) (Math.random() * 100D));</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;  ==  &quot; + threadLocal.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyRunnable my = new MyRunnable();</div><div class="line">        Thread thread1 = new Thread(my);</div><div class="line">        Thread thread2 = new Thread(my);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="关于InheritableThreadLocal"><a href="#关于InheritableThreadLocal" class="headerlink" title="关于InheritableThreadLocal"></a>关于InheritableThreadLocal</h1><p>InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。</p>
<p>【注：所有子线程都会继承父线程保存的ThreadLocal值】</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>局部线程通常使用在这样的情况下，当你有一些对象并不满足线程安全，但是你想避免在使用synchronized关键字、块时产生的同步访问，那么，让每个线程拥有它自己的对象实例。</p>
<p>注意：局部变量是同步或局部线程的一个好的替代，它总是能够保证线程安全。唯一可能限制你这样做的是你的应用设计约束。</p>
<p>这个地方，是因为看到项目中有些地方都有用到，所以自己也研究一下</p>
<p>单从用法而言，还是比较简单的，没啥难度，要是研究原理的问题的话，可以考虑深入看一下源代码</p>
<p>还有就是</p>
<p>思考一下这种方式，变量对象，是放在堆里面吗？还是堆里面？</p>
<p>答案是堆。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java中的ThreadLocal&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java中的ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java中的ThreadLocal&quot;&gt;&lt;/a&gt;今天要分享的内容
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于requirejs的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/19/requirejs/"/>
    <id>http://ghohankawk.github.io/2017/06/19/requirejs/</id>
    <published>2017-06-19T11:37:48.154Z</published>
    <updated>2017-06-19T12:25:11.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是requirejs"><a href="#今天要分享的内容是requirejs" class="headerlink" title="今天要分享的内容是requirejs"></a>今天要分享的内容是requirejs</h1><h1 id="AMD-简介"><a href="#AMD-简介" class="headerlink" title="AMD 简介"></a>AMD 简介</h1><p>  前端开发在近一两年发展的非常快，JavaScript 作为主流的开发语言得到了前所未有的热捧。大量的前端框架出现了，这些框架都在尝试着解决一些前端开发中的共性问题，但是实现又不尽相同。在这个背景下，CommonJS 社区诞生了，为了让前端框架发展的更加成熟，CommonJS 鼓励开发人员一起在社区里为一些完成特定功能的框架制定规范。AMD（Asynchronous Module Definition）就是其中的一个规范。</p>
<h1 id="RequireJS-简介"><a href="#RequireJS-简介" class="headerlink" title="RequireJS 简介"></a>RequireJS 简介</h1><p>  RequireJS 是一个非常小巧的 JavaScript 模块载入框架，是 AMD 规范最好的实现者之一。最新版本的 RequireJS 压缩后只有 14K，堪称非常轻量。它还同时可以和其他的框架协同工作，使用 RequireJS 必将使您的前端代码质量得以提升。 目前最新版本的 RequireJS 1.0.8 在 IE 6+、Firefox 2+、Safari 3.2+、Chrome 3+、Opera 10+ 上都工作的很好。</p>
<h1 id="案例一：-加载-JavaScript-文件"><a href="#案例一：-加载-JavaScript-文件" class="headerlink" title="案例一： 加载 JavaScript 文件"></a>案例一： 加载 JavaScript 文件</h1><pre><code>&lt;script src=&quot;./js/require.js&quot;&gt;&lt;/script&gt; 
     &lt;script&gt; 
    require([&quot;./js/a.js&quot;, &quot;./js/b.js&quot;], function() { 
             myFunctionA(); 
             myFunctionB(); 
        }); 
     &lt;/script&gt;

     这种方式，用来加载以前的js文件，就像本地引用一样，但是没有解决全局变量的问题
</code></pre><h1 id="案例二：-页面加载后执行-JavaScript"><a href="#案例二：-页面加载后执行-JavaScript" class="headerlink" title="案例二： 页面加载后执行 JavaScript"></a>案例二： 页面加载后执行 JavaScript</h1><p>   <script src="./js/require.js"></script><br>       <script><br>      require([“domReady!”, “./js/a.js”, “./js/b.js”], function() {<br>               myFunctionA();<br>               myFunctionB();<br>          });<br>       </script><br>       这个例子domReady!，解决了，有需要保证页面加载以后执行脚本时，RequireJS 提供了一个独立的 domReady 模块，需要去 RequireJS 官方网站下载这个模块</p>
<h1 id="AMD模块的写法"><a href="#AMD模块的写法" class="headerlink" title="AMD模块的写法"></a>AMD模块的写法</h1><p>  require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p>
<p>  具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p>
<p>  假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：</p>
<pre><code>// math.js
define(function (){
　　　　var add = function (x,y){
　　　　　　return x+y;
　　　　};
　　　　return {
　　　　　　add: add
　　　　};
});
</code></pre><p>  加载方法如下：</p>
<pre><code>// main.js
　　require([&apos;math&apos;], function (math){
　　　　alert(math.add(1,1));
　　});
</code></pre><h1 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h1><p>  理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p>
<p>  回答是可以的。</p>
<p>  这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>  举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<pre><code>require.config({
　　　　shim: {

　　　　　　&apos;underscore&apos;:{
　　　　　　　　exports: &apos;_&apos;
　　　　　　},
　　　　　　&apos;backbone&apos;: {
　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],
　　　　　　　　exports: &apos;Backbone&apos;
　　　　　　}
　　　　}
});
</code></pre><p>  require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</p>
<p>  比如，jQuery的插件可以这样定义：</p>
<pre><code>shim: {
　　　　&apos;jquery.scroll&apos;: {
　　　　　　deps: [&apos;jquery&apos;],
　　　　　　exports: &apos;jQuery.fn.scroll&apos;
　　　　}
}
</code></pre><h1 id="require-js插件"><a href="#require-js插件" class="headerlink" title="require.js插件"></a>require.js插件</h1><p>  require.js还提供一系列插件，实现一些特定的功能。</p>
<p>  domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<p>  require([‘domready!’], function (doc){<br>  　　　　// called once the DOM is ready<br>  　　});<br>  text和image插件，则是允许require.js加载文本和图片文件。</p>
<p>  define([<br>  　　　　‘text!review.txt’,<br>  　　　　‘image!cat.jpg’<br>  　　　　],</p>
<p>  　　　　function(review,cat){<br>  　　　　　　console.log(review);<br>  　　　　　　document.body.appendChild(cat);<br>  　　　　}<br>  　);<br>  类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>
<h1 id="在html中引入requirejs"><a href="#在html中引入requirejs" class="headerlink" title="在html中引入requirejs"></a>在html中引入requirejs</h1><p>  在HTML中，添加这样的 &lt; script&gt; 标签：</p>
<pre><code>&lt;script src=&quot;/path/to/require.js&quot; data-main=&quot;/path/to/app/config.js&quot;&gt;&lt;/script&gt;
</code></pre><p>  通常使用requirejs的话，我们只需要导入requirejs即可，不需要显式导入其它的js库，因为这个工作会交给requirejs来做。</p>
<p>  属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块。</p>
<h1 id="依赖一个不使用requirejs方式的库"><a href="#依赖一个不使用requirejs方式的库" class="headerlink" title="依赖一个不使用requirejs方式的库"></a>依赖一个不使用requirejs方式的库</h1><p>  前面的代码是理想的情况，即依赖的js文件，里面用了 define(…) 这样的方式来组织代码的。如果没用这种方式，会出现什么情况？</p>
<p>  比如这个 hello.js :</p>
<pre><code>function hello() {
alert(&quot;hello, world~&quot;);
}
</code></pre><p>  它就按最普通的方式定义了一个函数，我们能在requirejs里使用它吗？</p>
<p>  先看下面不能正确工作的代码：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  hello: &apos;hello&apos;
}
});

requirejs([&apos;hello&apos;], function(hello) {
hello();
});
</code></pre><p>  这段代码会报错，提示：</p>
<p>  Uncaught TypeError: undefined is not a function<br>  原因是最后调用 hello() 的时候，这个 hello 是个 undefined . 这说明，虽然我们依赖了一个js库（它会被载入），但requirejs无法从中拿到代表它的对象注入进来供我们使用。</p>
<p>  在这种情况下，我们要使用 shim ，将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  hello: &apos;hello&apos;
},
shim: {
  hello: { exports: &apos;hello&apos; }
}
});

requirejs([&apos;hello&apos;], function(hello) {
hello();
});
</code></pre><p>  再运行就正常了。</p>
<p>  上面代码 exports: ‘hello’ 中的 hello ，是我们在 hello.js 中定义的 hello 函数。当我们使用 function hello() {} 的方式定义一个函数的时候，它就是全局可用的。如果我们选择了把它 export 给requirejs，那当我们的代码依赖于 hello 模块的时候，就可以拿到这个 hello 函数的引用了。</p>
<p>  所以： exports 可以把某个非requirejs方式的代码中的某一个<strong>全局变量</strong>暴露出去，当作该模块以引用。</p>
<h1 id="无主的与有主的模块"><a href="#无主的与有主的模块" class="headerlink" title="无主的与有主的模块"></a>无主的与有主的模块</h1><p>  我遇到了一个折腾我不少时间的问题：为什么我只能使用 jquery 来依赖jquery, 而不能用其它的名字？</p>
<p>  比如下面这段代码：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  myjquery: &apos;lib/jquery/jquery&apos;
}
});

requirejs([&apos;myjquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  它会提示我：</p>
<p>  jq is undefined<br>  但我仅仅改个名字：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  jquery: &apos;lib/jquery/jquery&apos;
}
});

requirejs([&apos;jquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  就一切正常了，能打印出 jq 相应的对象了。</p>
<p>  为什么？我始终没搞清楚问题在哪儿。</p>
<h1 id="有主的模块"><a href="#有主的模块" class="headerlink" title="有主的模块"></a>有主的模块</h1><p>  经常研究，发现原来在jquery中已经定义了：</p>
<pre><code>define(&apos;jquery&apos;, [], function() { ... });
</code></pre><p>  它这里的 define 跟我们前面看到的 app.js 不同，在于它多了第一个参数 ‘jquery’ ，表示给当前这个模块起了名字 jquery ，它已经是有主的了，只能属于 jquery .</p>
<p>  所以当我们使用另一个名字：</p>
<p>  myjquery: ‘lib/jquery/jquery’<br>  去引用这个库的时候，它会发现，在 jquery.js 里声明的模块名 jquery 与我自己使用的模块名 myjquery 冲突，便不会把它赋给 myjquery ，所以 myjquery 的值是 undefined 。</p>
<p>  所以我们在使用一个第三方的时候，一定要注意它是否声明了一个确定的模块名。</p>
<h1 id="无主的模块"><a href="#无主的模块" class="headerlink" title="无主的模块"></a>无主的模块</h1><p>  如果我们不指明模块名，就像这样：</p>
<pre><code>define([...], function() {
...
});
</code></pre><p>  那么它就是无主的模块。我们可以在 requirejs.config 里，使用任意一个模块名来引用它。这样的话，就让我们的命名非常自由，大部分的模块就是无主的。</p>
<h1 id="为什么有的有主，有的无主"><a href="#为什么有的有主，有的无主" class="headerlink" title="为什么有的有主，有的无主"></a>为什么有的有主，有的无主</h1><p>  可以看到，无主的模块使用起来非常自由，为什么某些库（jquery, underscore）要把自己声明为有主的呢？</p>
<p>  按某些说法，这么做是出于性能的考虑。因为像 jquery , underscore 这样的基础库，经常被其它的库依赖。如果声明为无主的，那么其它的库很可能起不同的模块名，这样当我们使用它们时，就可能会多次载入jquery/underscore。</p>
<p>  而把它们声明为有主的，那么所有的模块只能使用同一个名字引用它们，这样系统就只会载入它们一次。</p>
<h1 id="强行该名称的方法"><a href="#强行该名称的方法" class="headerlink" title="强行该名称的方法"></a>强行该名称的方法</h1><p>  对于有主的模块，我们还有一种方式可以挖墙角：不把它们当作满足requirejs规范的模块，而当作普通js库，然后在 shim 中导出它们定义的全局变量。</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  myjquery: &apos;lib/jquery/jquery&apos;
},
shim: {
  myjquery: { exports: &apos;jQuery&apos; }
}
});

requirejs([&apos;myjquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  这样通过暴露 jQuery 这个全局变量给 myjquery ，我们就能正常的使用它了。</p>
<p>  不过我们完全没有必要这么挖墙角，因为对于我们来说，似乎没有任何好处。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 关于这块部分，我是看项目里有用到这个前端的组件，而自己没有实际开发过，因此<br> 对这个部分，理解不深刻，也就是现在能看懂的阶段了，主要是参考了好几篇关于<br> requirejs的文章总结的</p>
<p> 还有就是，这个部分其实一直就有了解，因此也不是完全不懂的去学</p>
<p> 反正是先入手学一下是很有必要的，</p>
<p> 哎，最近发现那个requirejs的中文网，不知道怎么滴就访问不了，好像只能去看英文文档了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是requirejs&quot;&gt;&lt;a href=&quot;#今天要分享的内容是requirejs&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是requirejs&quot;&gt;&lt;/a&gt;今天要分享的内容是requirejs&lt;/h1&gt;&lt;h1 id=&quot;A
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gitbook的自己定制的写书模板</title>
    <link href="http://ghohankawk.github.io/2017/06/15/gitbook/"/>
    <id>http://ghohankawk.github.io/2017/06/15/gitbook/</id>
    <published>2017-06-15T12:33:25.838Z</published>
    <updated>2017-06-15T12:54:51.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是gitbook的使用"><a href="#今天要分享的内容是gitbook的使用" class="headerlink" title="今天要分享的内容是gitbook的使用"></a>今天要分享的内容是gitbook的使用</h1><p>今天本来在看js的commonJs，amd，cmd，umd这些模块内容</p>
<p>看着，看着，突然看到了gitbook的内容</p>
<p>发现很多人，都用这个，写一个类似，api或者一些列的书籍用</p>
<p>所以下午花时间，开始弄这个</p>
<p>开始也是啥不懂，慢慢总算摸清门路了</p>
<p>其实还是不会用</p>
<p>本来去掉了让人讨厌的，最下面的那个published with gitbook那个连接</p>
<p>结果和github同步了一次代码，全部丢失了</p>
<p>后来实在，是不想弄了，就留着吧，懒得弄啦</p>
<p>最后的解决方案就是</p>
<p>用gitbook的那个编辑器，直接写文章将来</p>
<p>或者像这个博客一样，全部用markdown的语法，自己写</p>
<p>显得的高大上</p>
<p>去我的github上面，可以找一下，gitbook的写作模板</p>
<p>顺便把首页的测试页链接，改为自己的书籍，将来补充一下，争取写成一个书单，或者笔记之类的东西吧</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63304470_cc053618b7d92f9794e300a7d7e3f1e2" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63304470" target="_blank">美少女で 閲覧数を取れなきゃ 幼女を出せ</a> by <a href="https://www.pixiv.net/member.php?id=1147470" target="_blank">ぎぇうす</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是gitbook的使用&quot;&gt;&lt;a href=&quot;#今天要分享的内容是gitbook的使用&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是gitbook的使用&quot;&gt;&lt;/a&gt;今天要分享的内容是gitbook的使用&lt;/h1&gt;&lt;p&gt;今天
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感四（完结篇）</title>
    <link href="http://ghohankawk.github.io/2017/06/14/tomdashu4/"/>
    <id>http://ghohankawk.github.io/2017/06/14/tomdashu4/</id>
    <published>2017-06-14T11:47:30.120Z</published>
    <updated>2017-06-14T12:31:29.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇</h1><p>花了三天的时间，终于把大叔的博客，JavaScript系列看了一遍</p>
<p>收获颇丰啊，不愧是经典，一下子很多零散的东西就串联了起来</p>
<p>先简单说一下背景吧<br>大概是13年左右的时候，就有人推荐大叔的博客，那时第一个原因是水平不够，第二个没时间，总之就是没看过，但是听说过了</p>
<p>后来，陆续又自己完完整整的学了一遍JavaScript，就是大叔最后一篇文章里面推荐的，初级书籍，那边三圣经之一，看完了总觉得学会了，其实<br>看完就忘记了，不过有个大概印象了</p>
<p>再后来，毕业工作了，去做java后端了，因为有时候需要写简单的前端页面，就开始到了真正的实际应用，开始写的过程，才慢慢对一些概念，有了自己的认识<br>但是，还是停留在最初级的阶段，写个function函数，那种，变量都是全局的，简单的子自行，this分不清的水平</p>
<p>慢慢的，有个机会让我去定制前端组件，那个时候，自己开始模仿的写一些组件，但是都是初级的，不过正是因为这个原因，才有了一次写js的锻炼，有了这种训练<br>以前很多的概念开始，慢慢用上了</p>
<p>大概自认为，初级JavaScript之上，又达不到中级的水平吧，</p>
<p>大叔的系列，看完一遍，对我来说的收获</p>
<ol>
<li>弄清了function函数这个概念，实在太多了，比如，命名，申明，函数语句，匿名，自执行，等等</li>
<li>弄清了括号的用法和含义，（），这个东西，看着简单，不懂的话，还是不理解</li>
<li>弄清了闭包这个概念，这个概念每次问，都知道有那么回事，但是又具体说不上来，那种一直认为懂，其实还是不懂的概念，这篇文章终于弄清楚了</li>
<li>弄清了prototype这个玩意，就是所谓的原型的概念，只有函数才有</li>
<li>弄清了对象创建的方法，比如，function的，还有new，含有构造函数，等等</li>
<li>弄清了执行上下文，也就是作用域的概念，这个东西，没有比大叔写的更清楚的了</li>
<li>还有就是，有了上面的概念之后的，this指针，老生常谈了，网上的其他文章，只能写一些为啥，例子分析之类的，开始写不错，大叔这种原理分析，<br>各个场景的用法，这次就不怕分不清this了</li>
<li>当然了，还有，call，apply这些的用法</li>
<li>当然了，又温故知新了一遍设计模式，主要是理解了代码为啥有时候那么写的思路</li>
<li>有了上面总总的概念之后，看起完整的代码，才不会卡主分析里面任何一个细节<br>因为基础知识已经具备了，看起来，才能理解了</li>
</ol>
<p>说了这么多，其实呢，这个东西，不实践还是没有用的，如果没有当初自己一个人开始写js的那段实践，我估计也不会有今天<br>看博客那么大的收获</p>
<p>不敢说，都看懂了大叔所写，但是我心中的疑惑对js的，那些模糊的概念突然清晰了起来</p>
<p>书不是读一遍，就完事的，等以后有时间，再返回头看看，可能有更多的收获</p>
<p>上图</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63061360_9db8a1ab6d0b20a09558ed43369658e4" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63061360" target="_blank">まとめ</a> by <a href="https://www.pixiv.net/member.php?id=15385092" target="_blank">郁</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaS
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感三（设计模式篇）</title>
    <link href="http://ghohankawk.github.io/2017/06/13/tomdashu3/"/>
    <id>http://ghohankawk.github.io/2017/06/13/tomdashu3/</id>
    <published>2017-06-13T12:02:55.051Z</published>
    <updated>2017-06-14T11:43:47.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感3"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感3" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感3"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感3</h1><p>挑选大叔里面，个人自己喜欢的设计模式实现</p>
<h1 id="第二十五部分，设计模式之单例模式"><a href="#第二十五部分，设计模式之单例模式" class="headerlink" title="第二十五部分，设计模式之单例模式"></a>第二十五部分，设计模式之单例模式</h1><p>在传统开发工程师眼里，单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 缓存的实例</div><div class="line">    var instance = this;</div><div class="line"></div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    // 重写构造函数</div><div class="line">    Universe = function () &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">uni.bang = &quot;123&quot;;</div><div class="line">console.log(uni === uni2); // true</div><div class="line">console.log(uni2.bang); // 123</div></pre></td></tr></table></figure>
<p>这个设计模式，简单明了，通过this进行缓存，剩下了去判断不存在的麻烦</p>
<h1 id="第二十六部分，设计模式之构造函数模式"><a href="#第二十六部分，设计模式之构造函数模式" class="headerlink" title="第二十六部分，设计模式之构造函数模式"></a>第二十六部分，设计模式之构造函数模式</h1><p>构造函数用于创建特定类型的对象——不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype</div><div class="line">主要是用来避免重写定义原型prototype对象</div><div class="line">*/</div><div class="line">Car.prototype.output= function () &#123;</div><div class="line">    return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var tom = new Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">var dudu = new Car(&quot;Dudu&quot;, 2010, 5000);</div><div class="line"></div><div class="line">console.log(tom.output());</div><div class="line">console.log(dudu.output());</div></pre></td></tr></table></figure></p>
<h1 id="第二十七部分，设计模式之建造者模式"><a href="#第二十七部分，设计模式之建造者模式" class="headerlink" title="第二十七部分，设计模式之建造者模式"></a>第二十七部分，设计模式之建造者模式</h1><p>建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">    // 使用ID来请求数据，然后返回数据.</div><div class="line">    asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function (resp) &#123;</div><div class="line">        // callback调用 response</div><div class="line">        callback(resp.responseText);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var el = document.querySelector(&apos;#test&apos;);</div><div class="line">el.addEventListener(&apos;click&apos;, getBeerByIdBridge, false);</div><div class="line"></div><div class="line">function getBeerByIdBridge(e) &#123;</div><div class="line">    getBeerById(this.id, function (beer) &#123;</div><div class="line">        console.log(&apos;Requested Beer: &apos; + beer);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。<br>也就是说，上面的函数中，getBeerById函数是稳定的，写了一个构建过程，而具体的构建细节由另外一个回调函数决定</p>
<p>其实，我觉得，这个部分，不属于java里面的建造者模式，更是一种模板模式，可能个人理解不同吧，反正大叔的意思，就是这种样子</p>
<h1 id="第二十八部分，设计模式之工厂模式"><a href="#第二十八部分，设计模式之工厂模式" class="headerlink" title="第二十八部分，设计模式之工厂模式"></a>第二十八部分，设计模式之工厂模式</h1><pre><code>什么时候使用工厂模式

以下几种情景下工厂模式特别有用：

对象的构建十分复杂
需要依赖具体环境创建不同实例
处理大量具有相同属性的小对象
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var productManager = &#123;&#125;;</div><div class="line"></div><div class="line">productManager.createProductA = function () &#123;</div><div class="line">    console.log(&apos;ProductA&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">productManager.createProductB = function () &#123;</div><div class="line">    console.log(&apos;ProductB&apos;);</div><div class="line">&#125;</div><div class="line">        </div><div class="line">productManager.factory = function (typeType) &#123;</div><div class="line">    return new productManager[typeType];</div><div class="line">&#125;</div><div class="line"></div><div class="line">productManager.factory(&quot;createProductA&quot;);</div></pre></td></tr></table></figure>
<p>一句话，就是根据不同的类型，调用不同的子类，进行实例化一个对象</p>
<h1 id="第二十九部分，设计模式之装饰者模式"><a href="#第二十九部分，设计模式之装饰者模式" class="headerlink" title="第二十九部分，设计模式之装饰者模式"></a>第二十九部分，设计模式之装饰者模式</h1><p>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var tree = &#123;&#125;;</div><div class="line">tree.decorate = function () &#123;</div><div class="line">    console.log(&apos;Make sure the tree won\&apos;t fall&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.getDecorator = function (deco) &#123;</div><div class="line">    tree[deco].prototype = this;</div><div class="line">    return new tree[deco];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.RedBalls = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.RedBalls.prototype.decorate(); // 第7步：先执行原型（这时候是Angel了）的decorate方法</div><div class="line">        console.log(&apos;Put on some red balls&apos;); // 第8步 再输出 red</div><div class="line">        // 将这2步作为RedBalls的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.BlueBalls = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.BlueBalls.prototype.decorate(); // 第1步：先执行原型的decorate方法，也就是tree.decorate()</div><div class="line">        console.log(&apos;Add blue balls&apos;); // 第2步 再输出blue</div><div class="line">        // 将这2步作为BlueBalls的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.Angel = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.Angel.prototype.decorate(); // 第4步：先执行原型（这时候是BlueBalls了）的decorate方法</div><div class="line">        console.log(&apos;An angel on the top&apos;); // 第5步 再输出angel</div><div class="line">        // 将这2步作为Angel的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree = tree.getDecorator(&apos;BlueBalls&apos;); // 第3步：将BlueBalls对象赋给tree，这时候父原型里的getDecorator依然可用</div><div class="line">tree = tree.getDecorator(&apos;Angel&apos;); // 第6步：将Angel对象赋给tree，这时候父原型的父原型里的getDecorator依然可用</div><div class="line">tree = tree.getDecorator(&apos;RedBalls&apos;); // 第9步：将RedBalls对象赋给tree</div><div class="line"></div><div class="line">tree.decorate(); // 第10步：执行RedBalls对象的decorate方法</div></pre></td></tr></table></figure>
<p>这段代码，主要是在于，<br>        tree.getDecorator 这段函数设计精妙<br>        他让tree接受一个新的函数，而每次都用这个新函数去替代之前的函数，并且同时让原型指向前一个，实现了一个<br>        继承关系，比如A-》B-》C，最开始tree是A，然后，放入一个，就变成B，之后为C</p>
<h1 id="第三十部分，设计模式之外观模式"><a href="#第三十部分，设计模式之外观模式" class="headerlink" title="第三十部分，设计模式之外观模式"></a>第三十部分，设计模式之外观模式</h1><p>外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。</p>
<p>外观模式经常被用于JavaScript类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。</p>
<p>外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点 外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var addMyEvent = function (el, ev, fn) &#123;</div><div class="line">    if (el.addEventListener) &#123;</div><div class="line">        el.addEventListener(ev, fn, false);</div><div class="line">    &#125; else if (el.attachEvent) &#123;</div><div class="line">        el.attachEvent(&apos;on&apos; + ev, fn);</div><div class="line">    &#125; else &#123;</div><div class="line">        el[&apos;on&apos; + ev] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;; </div><div class="line">再来一个简单的例子，说白了就是用一个接口封装其它的接口：</div><div class="line">var mobileEvent = &#123;</div><div class="line">    // ...</div><div class="line">    stop: function (e) &#123;</div><div class="line">        e.preventDefault();</div><div class="line">        e.stopPropagation();</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="第三十一部分，设计模式之代理模式"><a href="#第三十一部分，设计模式之代理模式" class="headerlink" title="第三十一部分，设计模式之代理模式"></a>第三十一部分，设计模式之代理模式</h1><p>代理，顾名思义就是帮助别人做事<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 先声明美女对象</div><div class="line">var girl = function (name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 这是dudu</div><div class="line">var dudu = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        alert(&quot;Hi &quot; + girl.name + &quot;, dudu送你一个礼物：&quot; + gift);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 大叔是代理</div><div class="line">var proxyTom = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        (new dudu(girl)).sendGift(gift); // 替dudu送花咯</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">说的简单一点，就是代理新类，必须包括被代理的对象，也就是可以主动new</div></pre></td></tr></table></figure></p>
<h1 id="第三十二部分，设计模式之观察者模式"><a href="#第三十二部分，设计模式之观察者模式" class="headerlink" title="第三十二部分，设计模式之观察者模式"></a>第三十二部分，设计模式之观察者模式</h1><p>观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">jQuery版本</div><div class="line"></div><div class="line">根据jQuery1.7版新增的on/off功能，我们也可以定义jQuery版的观察者：</div><div class="line"></div><div class="line">(function ($) &#123;</div><div class="line"></div><div class="line">    var o = $(&#123;&#125;);</div><div class="line"></div><div class="line">    $.subscribe = function () &#123;</div><div class="line">        o.on.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.unsubscribe = function () &#123;</div><div class="line">        o.off.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.publish = function () &#123;</div><div class="line">        o.trigger.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125; (jQuery));</div></pre></td></tr></table></figure>
<h1 id="第三十三部分，设计模式之策略模式"><a href="#第三十三部分，设计模式之策略模式" class="headerlink" title="第三十三部分，设计模式之策略模式"></a>第三十三部分，设计模式之策略模式</h1><p>策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">正常的模式，缺点就是，下次继续增加case进行判断</div><div class="line">        validator = &#123;</div><div class="line">            validate: function (value, type) &#123;</div><div class="line">                switch (type) &#123;</div><div class="line">                    case &apos;isNonEmpty &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // NonEmpty 验证结果</div><div class="line">                        &#125;</div><div class="line">                    case &apos;isNumber &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // Number 验证结果</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    case &apos;isAlphaNum &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // AlphaNum 验证结果</div><div class="line">                        &#125;</div><div class="line">                    default:</div><div class="line">                        &#123;</div><div class="line">                            return true;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        //  测试</div><div class="line">        alert(validator.validate(&quot;123&quot;, &quot;isNonEmpty&quot;));</div><div class="line"></div><div class="line">策略模式</div><div class="line"></div><div class="line">var validator = &#123;</div><div class="line"></div><div class="line">    // 所有可以的验证规则处理类存放的地方，后面会单独定义</div><div class="line">    types: &#123;&#125;,</div><div class="line"></div><div class="line">    // 验证类型所对应的错误消息</div><div class="line">    messages: [],</div><div class="line"></div><div class="line">    // 当然需要使用的验证类型</div><div class="line">    config: &#123;&#125;,</div><div class="line"></div><div class="line">    // 暴露的公开验证方法</div><div class="line">    // 传入的参数是 key =&gt; value对</div><div class="line">    validate: function (data) &#123;</div><div class="line"></div><div class="line">        var i, msg, type, checker, result_ok;</div><div class="line"></div><div class="line">        // 清空所有的错误信息</div><div class="line">        this.messages = [];</div><div class="line"></div><div class="line">        for (i in data) &#123;</div><div class="line">            if (data.hasOwnProperty(i)) &#123;</div><div class="line"></div><div class="line">                type = this.config[i];  // 根据key查询是否有存在的验证规则</div><div class="line">                checker = this.types[type]; // 获取验证规则的验证类</div><div class="line"></div><div class="line">                if (!type) &#123;</div><div class="line">                    continue; // 如果验证规则不存在，则不处理</div><div class="line">                &#125;</div><div class="line">                if (!checker) &#123; // 如果验证规则类不存在，抛出异常</div><div class="line">                    throw &#123;</div><div class="line">                        name: &quot;ValidationError&quot;,</div><div class="line">                        message: &quot;No handler to validate type &quot; + type</div><div class="line">                    &#125;;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                result_ok = checker.validate(data[i]); // 使用查到到的单个验证类进行验证</div><div class="line">                if (!result_ok) &#123;</div><div class="line">                    msg = &quot;Invalid value for *&quot; + i + &quot;*, &quot; + checker.instructions;</div><div class="line">                    this.messages.push(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return this.hasErrors();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // helper</div><div class="line">    hasErrors: function () &#123;</div><div class="line">        return this.messages.length !== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">然后剩下的工作，就是定义types里存放的各种验证类了，我们这里只举几个例子：</div><div class="line"></div><div class="line">// 验证给定的值是否不为空</div><div class="line">validator.types.isNonEmpty = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return value !== &quot;&quot;;</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值不能为空&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否是数字</div><div class="line">validator.types.isNumber = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !isNaN(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能是合法的数字，例如：1, 3.14 or 2010&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否只是字母或数字</div><div class="line">validator.types.isAlphaNum = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !/[^a-z0-9]/i.test(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能保护字母和数字，不能包含特殊字符&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">以配置替代之前的写死的那种方式，可以理解为开闭原则，不修改之前的代码</div></pre></td></tr></table></figure>
<h1 id="第三十四部分，设计模式之命令模式"><a href="#第三十四部分，设计模式之命令模式" class="headerlink" title="第三十四部分，设计模式之命令模式"></a>第三十四部分，设计模式之命令模式</h1><p>命令模式(Command)的定义是：用于将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理。此外，可以通过调用实现具体函数的对象来解耦命令对象与接收对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$(function () &#123;</div><div class="line"></div><div class="line">    var CarManager = &#123;</div><div class="line"></div><div class="line">        // 请求信息</div><div class="line">        requestInfo: function (model, id) &#123;</div><div class="line">            return &apos;The information for &apos; + model +</div><div class="line">        &apos; with ID &apos; + id + &apos; is foobar&apos;;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        // 购买汽车</div><div class="line">        buyVehicle: function (model, id) &#123;</div><div class="line">            return &apos;You have successfully purchased Item &apos;</div><div class="line">        + id + &apos;, a &apos; + model;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        // 组织view</div><div class="line">        arrangeViewing: function (model, id) &#123;</div><div class="line">            return &apos;You have successfully booked a viewing of &apos;</div><div class="line">        + model + &apos; ( &apos; + id + &apos; ) &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">CarManager.execute = function (command) &#123;</div><div class="line">    return CarManager[command.request](command.model, command.carID);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CarManager.execute(&#123; request: &quot;arrangeViewing&quot;, model: &apos;Ferrari&apos;, carID: &apos;145523&apos; &#125;);</div><div class="line"></div><div class="line">之前可能没明白命令模式，现在看这个例子，就很简单了，</div><div class="line">就是，我不具体的调用函数，而是改成一个命令，通过一个弄命令函数，传入不同的指令，实现方法的调用</div><div class="line">大叔的意思是说，不推荐使用，可以直接调用，就不用这么麻烦，前天是系统不复杂的时候</div></pre></td></tr></table></figure>
<h1 id="第三十五部分，设计模式之迭代器模式"><a href="#第三十五部分，设计模式之迭代器模式" class="headerlink" title="第三十五部分，设计模式之迭代器模式"></a>第三十五部分，设计模式之迭代器模式</h1><p>迭代器模式(Iterator)：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。</p>
<p>迭代器的几个特点是：</p>
<p>访问一个聚合对象的内容而无需暴露它的内部表示。<br>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。<br>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jQuery里一个非常有名的迭代器就是$.each方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：</div><div class="line"></div><div class="line">$.each([&apos;dudu&apos;, &apos;dudu&apos;, &apos;酸奶小妹&apos;, &apos;那个MM&apos;], function (index, value) &#123;</div><div class="line">    console.log(index + &apos;: &apos; + value);</div><div class="line">&#125;);</div><div class="line">//或者</div><div class="line">$(&apos;li&apos;).each(function (index) &#123;</div><div class="line">    console.log(index + &apos;: &apos; + $(this).text());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="第三十六部分，设计模式之中介者模式"><a href="#第三十六部分，设计模式之中介者模式" class="headerlink" title="第三十六部分，设计模式之中介者模式"></a>第三十六部分，设计模式之中介者模式</h1><p>软件开发中，中介者是一个行为设计模式，通过提供一个统一的接口让系统的不同部分进行通信。一般，如果系统有很多子模块需要直接沟通，都要创建一个中央控制点让其各模块通过该中央控制点进行交互。中介者模式可以让这些子模块不需要直接沟通，而达到进行解耦的目的。</p>
<p>打个比方，平时常见的机场交通控制系统，塔台就是中介者，它控制着飞机（子模块）的起飞和降落，因为所有的沟通都是从飞机向塔台汇报来完成的，而不是飞机之前相互沟通。中央控制系统就是该系统的关键，也就是软件设计中扮演的中介者角色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 如下代码是伪代码，请不要过分在意代码</div><div class="line">// 这里app命名空间就相当于扮演中介者的角色</div><div class="line">var app = app || &#123;&#125;;</div><div class="line"> </div><div class="line">// 通过app中介者来进行Ajax请求</div><div class="line">app.sendRequest = function ( options ) &#123;</div><div class="line">    return $.ajax($.extend(&#123;&#125;, options);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 请求URL以后，展示View</div><div class="line">app.populateView = function( url, view )&#123;</div><div class="line">  $.when(app.sendRequest(&#123;url: url, method: &apos;GET&apos;&#125;)</div><div class="line">     .then(function()&#123;</div><div class="line">         //显示内容</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 清空内容</div><div class="line">app.resetView = function( view )&#123;</div><div class="line">   view.html(&apos;&apos;);</div><div class="line">&#125;</div><div class="line">之前没有分清，中介和代理，其实区别是明显，中介，里面参与的是多个人，他共同维护这些人，而且还都彼此认识switch </div><div class="line">而代理，只是简单的处理一个人而已，参与者一</div></pre></td></tr></table></figure>
<p>另外，由于中介者模式把交互复杂性变成了中介者本身的复杂性，所以说中介者对象会比其它任何对象都复杂。</p>
<h1 id="第三十七部分，设计模式之享元模式"><a href="#第三十七部分，设计模式之享元模式" class="headerlink" title="第三十七部分，设计模式之享元模式"></a>第三十七部分，设计模式之享元模式</h1><p>Flyweight中有两个重要概念–内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，而外部信息可以在通过外部删除或者保存。</p>
<p>说白点,就是先捏一个的原始模型，然后随着不同场合和环境,再产生各具特征的具体模型，很显然,在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">var Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability )&#123;</div><div class="line">   this.id = id;</div><div class="line">   this.title = title;</div><div class="line">   this.author = author;</div><div class="line">   this.genre = genre;</div><div class="line">   this.pageCount = pageCount;</div><div class="line">   this.publisherID = publisherID;</div><div class="line">   this.ISBN = ISBN;</div><div class="line">   this.checkoutDate = checkoutDate;</div><div class="line">   this.checkoutMember = checkoutMember;</div><div class="line">   this.dueReturnDate = dueReturnDate;</div><div class="line">   this.availability = availability;</div><div class="line">&#125;;</div><div class="line">Book.prototype = &#123;</div><div class="line">   getTitle:function()&#123;</div><div class="line">       return this.title;</div><div class="line">   &#125;,</div><div class="line">   getAuthor: function()&#123;</div><div class="line">       return this.author;</div><div class="line">   &#125;,</div><div class="line">   getISBN: function()&#123;</div><div class="line">       return this.ISBN;</div><div class="line">   &#125;,</div><div class="line">/*其它get方法在这里就不显示了*/</div><div class="line"></div><div class="line"></div><div class="line">上面这种函数，最大的问题，就是后面的那4个参数，就算是同一本书，时间不一样，都算成是不一样的</div><div class="line">其实，你是想知道，书这个东西，而不是书*变量个，这样内存中有很多没用的例子</div><div class="line"></div><div class="line"></div><div class="line">$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line"> console.log(&apos;You clicked: &apos; + $(this).attr(&apos;id&apos;));</div><div class="line">&#125;);</div><div class="line">// 上面的代码，要避免使用，避免再次对DOM元素进行生成jQuery对象，因为这里可以直接使用DOM元素自身了。</div><div class="line">$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line"> console.log(&apos;You clicked: &apos; + this.id);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">其实，很简单，就是一个排列组合的问题</div><div class="line">比如，创建文件夹来举例吧，你是创建book1到book10,10个文件夹，还是，创建book文件夹，里面放1-10个子文件夹，一个11个文件夹</div><div class="line"></div><div class="line">第一种方案字符串是，5*9+6=51</div><div class="line">第二种方案是4+9+2=15</div><div class="line">这节省空间是明显的，别问啥意思</div></pre></td></tr></table></figure>
<h1 id="第三十八部分，设计模式之职责链模式"><a href="#第三十八部分，设计模式之职责链模式" class="headerlink" title="第三十八部分，设计模式之职责链模式"></a>第三十八部分，设计模式之职责链模式</h1><p>职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p>也就是说，请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。提交请求的对象并不明确知道哪一个对象将会处理它——也就是该请求有一个隐式的接受者（implicit receiver）。根据运行时刻，任一候选者都可以响应相应的请求，候选者的数目是任意的，你可以在运行时刻决定哪些候选者参与到链中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">var NO_TOPIC = -1;</div><div class="line">var Topic;</div><div class="line"></div><div class="line">function Handler(s, t) &#123;</div><div class="line">    this.successor = s || null;</div><div class="line">    this.topic = t || 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Handler.prototype = &#123;</div><div class="line">    handle: function () &#123;</div><div class="line">        if (this.successor) &#123;</div><div class="line">            this.successor.handle()</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    has: function () &#123;</div><div class="line">        return this.topic != NO_TOPIC;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">var app = new Handler(&#123;</div><div class="line">    handle: function () &#123;</div><div class="line">        console.log(&apos;app handle&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;, 3);</div><div class="line"></div><div class="line">var dialog = new Handler(app, 1);</div><div class="line">dialog.handle = function () &#123;</div><div class="line">    console.log(&apos;dialog before ...&apos;)</div><div class="line">    // 这里做具体的处理操作</div><div class="line">    Handler.prototype.handle.call(this); //继续往上走</div><div class="line">    console.log(&apos;dialog after ...&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var button = new Handler(dialog, 2);</div><div class="line">button.handle = function () &#123;</div><div class="line">    console.log(&apos;button before ...&apos;)</div><div class="line">    // 这里做具体的处理操作</div><div class="line">    Handler.prototype.handle.call(this);</div><div class="line">    console.log(&apos;button after ...&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">button.handle();</div><div class="line"></div><div class="line">通过代码的运行结果我们可以看出，如果想先自身处理，然后再调用继任者处理的话，就在末尾执行Handler.prototype.handle.call(this);代码，如果想先处理继任者的代码，就在开头执行Handler.prototype.handle.call(this);代码。</div><div class="line"></div><div class="line">prototype用的好，就得理解this和prototype</div></pre></td></tr></table></figure>
<h1 id="第三十九部分，设计模式之适配器模式"><a href="#第三十九部分，设计模式之适配器模式" class="headerlink" title="第三十九部分，设计模式之适配器模式"></a>第三十九部分，设计模式之适配器模式</h1><p>适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//鸭子</div><div class="line">var Duck = function()&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">Duck.prototype.fly = function()&#123;</div><div class="line">throw new Error(&quot;该方法必须被重写!&quot;);</div><div class="line">&#125;;</div><div class="line">Duck.prototype.quack = function()&#123;</div><div class="line">throw new Error(&quot;该方法必须被重写!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//火鸡</div><div class="line">var Turkey = function()&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">Turkey.prototype.fly = function()&#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;;</div><div class="line">Turkey.prototype.gobble = function()&#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//鸭子</div><div class="line">var MallardDuck = function () &#123;</div><div class="line">    Duck.apply(this);</div><div class="line">&#125;;</div><div class="line">MallardDuck.prototype = new Duck(); //原型是Duck</div><div class="line">MallardDuck.prototype.fly = function () &#123;</div><div class="line">    console.log(&quot;可以飞翔很长的距离!&quot;);</div><div class="line">&#125;;</div><div class="line">MallardDuck.prototype.quack = function () &#123;</div><div class="line">    console.log(&quot;嘎嘎！嘎嘎！&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//火鸡</div><div class="line">var WildTurkey = function () &#123;</div><div class="line">    Turkey.apply(this);</div><div class="line">&#125;;</div><div class="line">WildTurkey.prototype = new Turkey(); //原型是Turkey</div><div class="line">WildTurkey.prototype.fly = function () &#123;</div><div class="line">    console.log(&quot;飞翔的距离貌似有点短!&quot;);</div><div class="line">&#125;;</div><div class="line">WildTurkey.prototype.gobble = function () &#123;</div><div class="line">    console.log(&quot;咯咯！咯咯！&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<pre><code>那合适使用适配器模式好呢？如果有以下情况出现时，建议使用：

使用一个已经存在的对象，但其方法或属性接口不符合你的要求；
你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作；
想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性。
另外，适配器模式和其它几个模式可能容易让人迷惑，这里说一下大概的区别：

适配器和桥接模式虽然类似，但桥接的出发点不同，桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口。
装饰者模式增强了其它对象的功能而同时又不改变它的接口，因此它对应程序的透明性比适配器要好，其结果是装饰者支持递归组合，而纯粹使用适配器则是不可能的。
代理模式在不改变它的接口的条件下，为另外一个对象定义了一个代理。
</code></pre><h1 id="第四十部分，设计模式之组合模式"><a href="#第四十部分，设计模式之组合模式" class="headerlink" title="第四十部分，设计模式之组合模式"></a>第四十部分，设计模式之组合模式</h1><p>组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>常见的场景有asp.net里的控件机制（即control里可以包含子control，可以递归操作、添加、删除子control），类似的还有DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line">var MenuComponent = function () &#123;</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getName = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getDescription = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getPrice = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.isVegetarian = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.print = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.add = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.remove = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getChild = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var MenuItem = function (sName, sDescription, bVegetarian, nPrice) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.bVegetarian = bVegetarian;</div><div class="line">    this.nPrice = nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype = new MenuComponent();</div><div class="line">MenuItem.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getPrice = function () &#123;</div><div class="line">    return this.nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.isVegetarian = function () &#123;</div><div class="line">    return this.bVegetarian;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.print = function () &#123;</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription() + &quot;, &quot; + this.getPrice() + &quot;euros&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var Menu = function (sName, sDescription) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.aMenuComponents = [];</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.createIterator = function () &#123;</div><div class="line">        throw new Error(&quot;This method must be overwritten!&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">Menu.prototype = new MenuComponent();</div><div class="line">Menu.prototype.add = function (oMenuComponent) &#123;</div><div class="line">    // 添加子菜品</div><div class="line">    this.aMenuComponents.push(oMenuComponent);</div><div class="line">&#125;;</div><div class="line">Menu.prototype.remove = function (oMenuComponent) &#123;</div><div class="line">    // 删除子菜品</div><div class="line">    var aMenuItems = [];</div><div class="line">    var nMenuItem = 0;</div><div class="line">    var nLenMenuItems = this.aMenuComponents.length;</div><div class="line">    var oItem = null;</div><div class="line"></div><div class="line">    for (; nMenuItem &lt; nLenMenuItems; ) &#123;</div><div class="line">        oItem = this.aMenuComponents[nMenuItem];</div><div class="line">        if (oItem !== oMenuComponent) &#123;</div><div class="line">            aMenuItems.push(oItem);</div><div class="line">        &#125;</div><div class="line">        nMenuItem = nMenuItem + 1;</div><div class="line">    &#125;</div><div class="line">    this.aMenuComponents = aMenuItems;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getChild = function (nIndex) &#123;</div><div class="line">    //获取指定的子菜品</div><div class="line">    return this.aMenuComponents[nIndex];</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.print = function () &#123;</div><div class="line">    // 打印当前菜品以及所有的子菜品</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription());</div><div class="line">    console.log(&quot;--------------------------------------------&quot;);</div><div class="line"></div><div class="line">    var nMenuComponent = 0;</div><div class="line">    var nLenMenuComponents = this.aMenuComponents.length;</div><div class="line">    var oMenuComponent = null;</div><div class="line"></div><div class="line">    for (; nMenuComponent &lt; nLenMenuComponents; ) &#123;</div><div class="line">        oMenuComponent = this.aMenuComponents[nMenuComponent];</div><div class="line">        oMenuComponent.print();</div><div class="line">        nMenuComponent = nMenuComponent + 1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var DinnerMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">DinnerMenu.prototype = new Menu();</div><div class="line"></div><div class="line">var CafeMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">CafeMenu.prototype = new Menu();</div><div class="line"></div><div class="line">var PancakeHouseMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">PancakeHouseMenu.prototype = new Menu();</div><div class="line"></div><div class="line"></div><div class="line">var Mattress = function (aMenus) &#123;</div><div class="line">    this.aMenus = aMenus;</div><div class="line">&#125;;</div><div class="line">Mattress.prototype.printMenu = function () &#123;</div><div class="line">    this.aMenus.print();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">组合模式，特点就是抽象一个父子公用的类，比如，add，remove这些getChild之类的，必须提供</div></pre></td></tr></table></figure></p>
<h1 id="第四十一部分，设计模式之模板方法"><a href="#第四十一部分，设计模式之模板方法" class="headerlink" title="第四十一部分，设计模式之模板方法"></a>第四十一部分，设计模式之模板方法</h1><p>模板方法（TemplateMethod）定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法是一种代码复用的基本技术，在类库中尤为重要，因为他们提取了类库中的公共行为。模板方法导致一种反向的控制结构，这种结构就是传说中的“好莱坞法则”，即“别找找我们，我们找你</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">var CaffeineBeverage = function () &#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.prepareRecipe = function () &#123;</div><div class="line">    this.boilWater();</div><div class="line">    this.brew();</div><div class="line">    this.pourOnCup();</div><div class="line">    if (this.customerWantsCondiments()) &#123;</div><div class="line">        // 如果可以想加小料，就加上</div><div class="line"> this.addCondiments();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.boilWater = function () &#123;</div><div class="line">    console.log(&quot;将水烧开!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.pourOnCup = function () &#123;</div><div class="line">    console.log(&quot;将饮料到再杯子里!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.brew = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.addCondiments = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">// 默认加上小料</div><div class="line">CaffeineBeverage.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 冲咖啡</div><div class="line">var Coffee = function () &#123;</div><div class="line">    CaffeineBeverage.apply(this);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype = new CaffeineBeverage();</div><div class="line">Coffee.prototype.brew = function () &#123;</div><div class="line">    console.log(&quot;从咖啡机想咖啡倒进去!&quot;);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype.addCondiments = function () &#123;</div><div class="line">    console.log(&quot;添加糖和牛奶&quot;);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return confirm(&quot;你想添加糖和牛奶吗？&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//冲茶叶</div><div class="line">var Tea = function () &#123;</div><div class="line">    CaffeineBeverage.apply(this);</div><div class="line">&#125;;</div><div class="line">Tea.prototype = new CaffeineBeverage();</div><div class="line">Tea.prototype.brew = function () &#123;</div><div class="line">    console.log(&quot;泡茶叶!&quot;);</div><div class="line">&#125;;</div><div class="line">Tea.prototype.addCondiments = function () &#123;</div><div class="line">    console.log(&quot;添加柠檬!&quot;);</div><div class="line">&#125;;</div><div class="line">Tea.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return confirm(&quot;你想添加柠檬嘛？&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>模板方法应用于下列情况：</p>
<p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现<br>各子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复，不同之处分离为新的操作，最后，用一个钓鱼这些新操作的模板方法来替换这些不同的代码<br>控制子类扩展，模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展</p>
<h1 id="第四十二部分，设计模式之原型模式"><a href="#第四十二部分，设计模式之原型模式" class="headerlink" title="第四十二部分，设计模式之原型模式"></a>第四十二部分，设计模式之原型模式</h1><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var vehicle = &#123;</div><div class="line">    getModel: function () &#123;</div><div class="line">        console.log(&apos;车辆的模具是：&apos; + this.model);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var car = Object.create(vehicle, &#123;</div><div class="line">    &apos;id&apos;: &#123;</div><div class="line">        value: MY_GLOBAL.nextId(),</div><div class="line">        enumerable: true // 默认writable:false, configurable:false</div><div class="line"> &#125;,</div><div class="line">    &apos;model&apos;: &#123;</div><div class="line">        value: &apos;福特&apos;,</div><div class="line">        enumerable: true</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">说的简单一点，其实就是特指，JavaScript里面的原型模式</div></pre></td></tr></table></figure>
<h1 id="第四十三部分，设计模式之状态模式"><a href="#第四十三部分，设计模式之状态模式" class="headerlink" title="第四十三部分，设计模式之状态模式"></a>第四十三部分，设计模式之状态模式</h1><p>状态模式（State）允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类。<br>这个地方内容代码太长了<br>我自己理解，总结一下</p>
<ol>
<li>比如有A，B，C三种状态</li>
<li>那么每种状态必须对应了一组动作，比如开和关，那么3*2=6种状态</li>
<li>三种状态，有种转换关系，状态的改变，同样的开，代表的意思不一样</li>
<li>比如顺序，A-》B-》C-》A，那么同样的，动作，开随着状态的改变，意义发生变化<h1 id="第四十四部分，设计模式之桥接模式"><a href="#第四十四部分，设计模式之桥接模式" class="headerlink" title="第四十四部分，设计模式之桥接模式"></a>第四十四部分，设计模式之桥接模式</h1></li>
</ol>
<p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">// 通过ID发送请求，然后返回数据</div><div class="line">asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;</div><div class="line">// callback response</div><div class="line">callback(resp.responseText);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">桥接，看大叔的例子，还真是没懂，回去看了我之前写过的设计模式，才慢慢理解switch </div><div class="line">桥接=代理+策略</div><div class="line">为什么这么说？</div><div class="line">1. jdbc是桥接，怎么用，是不是每次主动输入一个mysql.jdbc这么个字符串？</div><div class="line">2. 代理模式很明白的只代理一个类，内部写死了</div><div class="line">3. 而策略模式，是有一组策略，客户端不需要具体使用了什么策略</div><div class="line">4. 那么桥接，就是你要明确的告诉这个代理，要用哪种策略</div><div class="line">5. 因此，你需要清楚，你是要给谁桥？</div><div class="line">6. 因此上面这个例子，callback，就是你自己传递尽量的，按个策略</div></pre></td></tr></table></figure>
<h1 id="第四十五部分，代码复用模式（避免篇）"><a href="#第四十五部分，代码复用模式（避免篇）" class="headerlink" title="第四十五部分，代码复用模式（避免篇）"></a>第四十五部分，代码复用模式（避免篇）</h1><p>写了6篇，应该让我们避免的模式，那么不要去话时间记忆不要用的，重点在下篇</p>
<h1 id="第四十六部分，代码复用模式（推荐篇）"><a href="#第四十六部分，代码复用模式（推荐篇）" class="headerlink" title="第四十六部分，代码复用模式（推荐篇）"></a>第四十六部分，代码复用模式（推荐篇）</h1><p>只需记住，大叔推荐，让我们记住的模式，就可以了</p>
<pre><code>模式1：原型继承

原型继承是让父对象作为子对象的原型，从而达到继承的目的：
function object(o) {
    function F() {
    }

    F.prototype = o;
    return new F();
}

// 要继承的父对象
var parent = {
    name: &quot;Papa&quot;
};

// 新对象
var child = object(parent);

// 测试
console.log(child.name); // &quot;Papa&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 创建新person
var papa = new Person();
// 继承
var kid = object(papa);
console.log(kid.getName()); // &quot;Adam&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 继承
var kid = object(Person.prototype);
console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的
console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型
记住一句话，prototype是一个对象

function object(o) {
    function F() {
    }

    F.prototype = o;
    return new F();
}

// 要继承的父对象
var parent = {
    name: &quot;Papa&quot;
};

// 新对象
var child = object(parent);

// 测试
console.log(child.name); // &quot;Papa&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 创建新person
var papa = new Person();
// 继承
var kid = object(papa);
console.log(kid.getName()); // &quot;Adam&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 继承
var kid = object(Person.prototype);
console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的
console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型

模式2：复制所有属性进行继承

这种方式的继承就是将父对象里所有的属性都复制到子对象上，一般子对象可以使用父对象的数据。

先来看一个浅拷贝的例子：

/* 浅拷贝 */
function extend(parent, child) {
    var i;
    child = child || {};
    for (i in parent) {
        if (parent.hasOwnProperty(i)) {
            child[i] = parent[i];
        }
    }
    return child;
}

var dad = { name: &quot;Adam&quot; };
var kid = extend(dad);
console.log(kid.name); // &quot;Adam&quot;

var dad = {
    counts: [1, 2, 3],
    reads: { paper: true }
};
var kid = extend(dad);
kid.counts.push(4);
console.log(dad.counts.toString()); // &quot;1,2,3,4&quot;
console.log(dad.reads === kid.reads); // true
代码的最后一行，你可以发现dad和kid的reads是一样的，也就是他们使用的是同一个引用，这也就是浅拷贝带来的问题。


/* 深拷贝 */
function extendDeep(parent, child) {
    var i,
        toStr = Object.prototype.toString,
        astr = &quot;[object Array]&quot;;

    child = child || {};

    for (i in parent) {
        if (parent.hasOwnProperty(i)) {
            if (typeof parent[i] === &apos;object&apos;) {
                child[i] = (toStr.call(parent[i]) === astr) ? [] : {};
                extendDeep(parent[i], child[i]);
            } else {
                child[i] = parent[i];
            }
        }
    }
    return child;
}

var dad = {
    counts: [1, 2, 3],
    reads: { paper: true }
};
var kid = extendDeep(dad);

kid.counts.push(4);
console.log(kid.counts.toString()); // &quot;1,2,3,4&quot;
console.log(dad.counts.toString()); // &quot;1,2,3&quot;

console.log(dad.reads === kid.reads); // false
kid.reads.paper = false;

这个地方就是厉害在，上面的递归那部分，当包含复合部分就会重新递归调用一次 


模式3：混合（mix-in）

混入就是将一个对象的一个或多个（或全部）属性（或方法）复制到另外一个对象，我们举一个例子：

function mix() {
    var arg, prop, child = {};
    for (arg = 0; arg &lt; arguments.length; arg += 1) {
        for (prop in arguments[arg]) {
            if (arguments[arg].hasOwnProperty(prop)) {
                child[prop] = arguments[arg][prop];
            }
        }
    }
    return child;
}

var cake = mix(
                { eggs: 2, large: true },
                { butter: 1, salted: true },
                { flour: &apos;3 cups&apos; },
                { sugar: &apos;sure!&apos; }
                );

console.dir(cake);


模式4：借用方法

一个对象借用另外一个对象的一个或两个方法，而这两个对象之间不会有什么直接联系。不用多解释，直接用代码解释吧：

var one = {
    name: &apos;object&apos;,
    say: function (greet) {
        return greet + &apos;, &apos; + this.name;
    }
};

// 测试
console.log(one.say(&apos;hi&apos;)); // &quot;hi, object&quot;

var two = {
    name: &apos;another object&apos;
};

console.log(one.say.apply(two, [&apos;hello&apos;])); // &quot;hello, another object&quot;

// 将say赋值给一个变量，this将指向到全局变量
var say = one.say;
console.log(say(&apos;hoho&apos;)); // &quot;hoho, undefined&quot;

// 传入一个回调函数callback
var yetanother = {
    name: &apos;Yet another object&apos;,
    method: function (callback) {
        return callback(&apos;Hola&apos;);
    }
};
console.log(yetanother.method(one.say)); // &quot;Holla, undefined&quot;

function bind(o, m) {
    return function () {
        return m.apply(o, [].slice.call(arguments));
    };
}

var twosay = bind(two, one.say);
console.log(twosay(&apos;yo&apos;)); // &quot;yo, another object&quot;


// ECMAScript 5给Function.prototype添加了一个bind()方法，以便很容易使用apply()和call()。

if (typeof Function.prototype.bind === &apos;undefined&apos;) {
    Function.prototype.bind = function (thisArg) {
        var fn = this,
slice = Array.prototype.slice,
args = slice.call(arguments, 1);
        return function () {
            return fn.apply(thisArg, args.concat(slice.call(arguments)));
        };
    };
}

var twosay2 = one.say.bind(two);
console.log(twosay2(&apos;Bonjour&apos;)); // &quot;Bonjour, another object&quot;

var twosay3 = one.say.bind(two, &apos;Enchanté&apos;);
console.log(twosay3()); // &quot;Enchanté, another object&quot;
</code></pre><h1 id="第四十七部分，对象创建模式（上篇）"><a href="#第四十七部分，对象创建模式（上篇）" class="headerlink" title="第四十七部分，对象创建模式（上篇）"></a>第四十七部分，对象创建模式（上篇）</h1><pre><code>模式1：命名空间（namespace）

命名空间可以减少全局命名所需的数量，避免命名冲突或过度。一般我们在进行对象层级定义的时候，经常是这样的：

var app = app || {};
app.moduleA = app.moduleA || {};

// 更简洁的方式
var MYAPP = MYAPP || {};


模式2：定义依赖

有时候你的一个模块或者函数可能要引用第三方的一些模块或者工具，这时候最好将这些依赖模块在刚开始的时候就定义好，以便以后可以很方便地替换掉。

var myFunction = function () {
    // 依赖模块
    var event = YAHOO.util.Event,
        dom = YAHOO.util.dom;

    // 其它函数后面的代码里使用局部变量event和dom
};

};
模式3：私有属性和私有方法

JavaScript本书不提供特定的语法来支持私有属性和私有方法，但是我们可以通过闭包来实现，代码如下：


function Gadget() {
    // 私有对象
    var name = &apos;iPod&apos;;
    // 公有函数
    this.getName = function () {
        return name;
    };
}

模式4：Revelation模式

也是关于隐藏私有方法的模式，和《深入理解JavaScript系列（3）：全面解析Module模式》里的Module模式有点类似，但是不是return的方式，而是在外部先声明一个变量，然后在内部给变量赋值公有方法。代码如下：

var myarray;

(function () {
    var astr = &quot;[object Array]&quot;,
        toString = Object.prototype.toString;

    function isArray(a) {
        return toString.call(a) === astr;
    }

    function indexOf(haystack, needle) {
        var i = 0,
            max = haystack.length;
        for (; i &lt; max; i += 1) {
            if (haystack[i] === needle) {
                return i;
            }
        }
        return -1;
    }

    //通过赋值的方式，将上面所有的细节都隐藏了
    myarray = {
        isArray: isArray,
        indexOf: indexOf,
        inArray: indexOf
    };
} ());

模式5：链模式

链模式可以你连续可以调用一个对象的方法，比如obj.add(1).remove(2).delete(4).add(2)这样的形式，其实现思路非常简单，就是将this原样返回。代码如下：

var obj = {
    value: 1,
    increment: function () {
        this.value += 1;
        return this;
    },
    add: function (v) {
        this.value += v;
        return this;
    },
    shout: function () {
        console.log(this.value);
    }
};
</code></pre><h1 id="第四十八部分，对象创建模式（下篇）"><a href="#第四十八部分，对象创建模式（下篇）" class="headerlink" title="第四十八部分，对象创建模式（下篇）"></a>第四十八部分，对象创建模式（下篇）</h1><pre><code>模式6：函数语法糖

函数语法糖是为一个对象快速添加方法（函数）的扩展，这个主要是利用prototype的特性，代码比较简单，我们先来看一下实现代码：

if (typeof Function.prototype.method !== &quot;function&quot;) {
    Function.prototype.method = function (name, implementation) {
        this.prototype[name] = implementation;
        return this;
    };
}
模式7：对象常量

对象常量是在一个对象提供set,get,ifDefined各种方法的体现，而且对于set的方法只会保留最先设置的对象，后期再设置都是无效的，已达到别人无法重载的目的。实现代码如下：

var constant = (function () {
    var constants = {},
        ownProp = Object.prototype.hasOwnProperty,
    // 只允许设置这三种类型的值
        allowed = {
            string: 1,
            number: 1,
            boolean: 1
        },


模式8：沙盒模式

沙盒（Sandbox）模式即时为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个Sandbox里有3个方法event,dom,ajax，在调用其中2个组成一个环境的话，和调用三个组成的环境完全没有干扰。

模式9：静态成员

静态成员（Static Members）只是一个函数或对象提供的静态属性，可分为私有的和公有的，就像C#或Java里的public static和private static一样。

我们先来看一下公有成员，公有成员非常简单，我们平时声明的方法，函数都是公有的，比如：

// 构造函数
var Gadget = function () {
};

// 公有静态方法
Gadget.isShiny = function () {
    return &quot;you bet&quot;;
};

// 原型上添加的正常方法
Gadget.prototype.setPrice = function (price) {
    this.price = price;
};

// 调用静态方法
console.log(Gadget.isShiny()); // &quot;you bet&quot;

// 创建实例，然后调用方法
var iphone = new Gadget();
iphone.setPrice(500);


而私有静态成员，我们可以利用其闭包特性去实现，以下是两种实现方式。

第一种实现方式：

var Gadget = (function () {
    // 静态变量/属性
    var counter = 0;

    // 闭包返回构造函数的新实现
    return function () {
        console.log(counter += 1);
    };
} ()); // 立即执行

var g1 = new Gadget(); // logs 1
var g2 = new Gadget(); // logs 2
var g3 = new Gadget(); // logs 3
</code></pre><h1 id="第四十九部分，Function模式（上篇）"><a href="#第四十九部分，Function模式（上篇）" class="headerlink" title="第四十九部分，Function模式（上篇）"></a>第四十九部分，Function模式（上篇）</h1><pre><code>回调函数

在JavaScript中，当一个函数A作为另外一个函数B的其中一个参数时，则函数A称为回调函数，即A可以在函数B的周期内执行（开始、中间、结束时均可）。


配置对象

如果一个函数（或方法）的参数只有一个参数，并且参数为对象字面量，我们则称这种模式为配置对象模式。例如，如下代码：

var conf = {
    username:&quot;shichuan&quot;,
    first:&quot;Chuan&quot;,
    last:&quot;Shi&quot;
};


返回函数

返回函数，则是指在一个函数的返回值为另外一个函数，或者根据特定的条件灵活创建的新函数，示例代码如下：

var setup = function () {
    console.log(1);
    return function () {
        console.log(2);
    };
};
// 调用setup 函数
var my = setup(); // 输出 1
my(); // 输出 2
// 或者直接调用也可
setup()();

强调一句，这种形式的this，认为是ao，激活对象，也可以认为是null，因此是global


偏应用

忽略

Currying

Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。

忽略
</code></pre><h1 id="第五十部分，Function模式（下篇）"><a href="#第五十部分，Function模式（下篇）" class="headerlink" title="第五十部分，Function模式（下篇）"></a>第五十部分，Function模式（下篇）</h1><pre><code>立即执行的对象初始化

该模式的意思是指在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作，通常该模式可以用在一次性执行的代码上。

({
    // 这里你可以定义常量，设置其它值
    maxwidth: 600,
    maxheight: 400,

    //  当然也可以定义utility方法
    gimmeMax: function () {
        return this.maxwidth + &quot;x&quot; + this.maxheight;
    },

    // 初始化
    init: function () {
        console.log(this.gimmeMax());
        // 更多代码...
    }
}).init();  // 这样就开始初始化咯


分支初始化

分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。之前我们在做事件处理的时候，通常使用类似下面的代码：

var utils = {
    addListener: function (el, type, fn) {
        if (typeof window.addEventListener === &apos;function&apos;) {
            el.addEventListener(type, fn, false);
        } else if (typeof document.attachEvent !== &apos;undefined&apos;) {
            el.attachEvent(&apos;on&apos; + type, fn);
        } else {
            el[&apos;on&apos; + type] = fn;
        }
    },
    removeListener: function (el, type, fn) {
    }
};

内存优化

该模式主要是利用函数的属性特性来避免大量的重复计算。通常代码形式如下：

var myFunc = function (param) {
    if (!myFunc.cache[param]) {
        var result = {};
        // ... 复杂操作 ...
        myFunc.cache[param] = result;
    }
    return myFunc.cache[param];
};

// cache 存储
myFunc.cache = {};
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感3&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感3&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaScrip
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感二（17——24节）</title>
    <link href="http://ghohankawk.github.io/2017/06/13/tomdashu2/"/>
    <id>http://ghohankawk.github.io/2017/06/13/tomdashu2/</id>
    <published>2017-06-13T03:23:16.482Z</published>
    <updated>2017-06-13T11:44:04.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感2"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感2" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感2"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感2</h1><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=527602&auto=1&height=66"></iframe></p>
<h1 id="第十七部分，面向对象编程之概论"><a href="#第十七部分，面向对象编程之概论" class="headerlink" title="第十七部分，面向对象编程之概论"></a>第十七部分，面向对象编程之概论</h1><p>我们有必要掌握一些OOP基本的特征，并澄清概论中的主要概念。主要讨论封装，继承，多态，接口，那些传统的面向对象概念，可以忽略不看，不影响</p>
<h1 id="第十八部分，面向对象编程之ECMAScript实现（推荐）"><a href="#第十八部分，面向对象编程之ECMAScript实现（推荐）" class="headerlink" title="第十八部分，面向对象编程之ECMAScript实现（推荐）"></a>第十八部分，面向对象编程之ECMAScript实现（推荐）</h1><p>总结如下：</p>
<pre><code>1. 原始值类型
   回头来看6中用于ECMAScript程序的数据类型，前5种是原始值类型，包括Undefined、Null、Boolean、String、Number、Object。
2. 有必要需要注意的是规范还区分了这内置对象、元素对象和宿主对象。
所有ECMAScript实现的对象都是原生对象（其中一些是内置对象、一些在程序执行的时候创建，例如用户自定义对象）。内置对象是原生对象的一个子集、是在程序开始之前内置到ECMAScript里的（例如，parseInt, Match等）。所有的宿主对象是由宿主环境提供的，通常是浏览器，并可能包括如window、alert等。
也有对象是由特殊的内置构造函数创建： Function（函数对象构造器）、Array（数组构造器） RegExp（正则表达式构造器）、Math（数学模块）、 Date（日期的构造器）等等，这些对象也是Object对象类型的值
3. 字面量Literal

   对于三个对象的值：对象（object）,数组（array）和正则表达式（regular expression）
4. 然而，如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：
function A() {}
A.prototype = {
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // false!
因此，对函数的原型引用需要手工恢复：

function A() {}
A.prototype = {
  constructor: A,
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // true
5. a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype

   此外， 实例的[[Prototype]]值确实是在构造函数的prototype属性上获取的。

   然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。
  对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。

  这个地方，原型链，特别难理解，详细的看第一篇，观后感的，原型链的，链接，那个是非常详细的说明 
6. 有误解：

   if (foo instanceof Foo) {
     ...
   }
   这不是用来检测对象foo是否是用Foo构造函数创建的，
所有instanceof运算符只需要一个对象属性——foo.[[Prototype]]，在原型链中从Foo.prototype开始检查其是否存在。

7. alert(1..toString()); // &quot;1&quot;，不是语法错误
   大部分程序里使用原型是用来存储对象的方法、默认状态和共享对象的属性。
</code></pre><h1 id="第十九部分，求值策略-Evaluation-strategy"><a href="#第十九部分，求值策略-Evaluation-strategy" class="headerlink" title="第十九部分，求值策略(Evaluation strategy)"></a>第十九部分，求值策略(Evaluation strategy)</h1><p>很多程序员都确信在JavaScript中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参</p>
<pre><code>1. 按值传递
   按值传递，很多开发人员都很了解了，参数的值是调用者传递的对象值的拷贝(copy of value），函数内部改变参数的值不会影响到外面的对象（该参数在外面的值），一般来说，是重新分配了新内存(我们不关注分配内存是怎么实现的——也是是栈也许是动态内存分配），该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。
2. 按引用传递
   另外一个众所周知的按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。
3. 按共享传递（Call by sharing）
最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象（例如外部的该对象不是想按值传递一样完全的拷贝),改变该参数对象的属性值将会影响到外部的对象。
4. 现在我们知道了ECMAScript中将对象作为参数传递的策略了——按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象
传递的是引用的拷贝（地址副本）

再强调一下，这里所说对象的值是地址（address），而不是对象结构本身，将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。
</code></pre><h1 id="第二十部分，《你真懂JavaScript吗？》答案详解"><a href="#第二十部分，《你真懂JavaScript吗？》答案详解" class="headerlink" title="第二十部分，《你真懂JavaScript吗？》答案详解"></a>第二十部分，《你真懂JavaScript吗？》答案详解</h1><p>总结如下：</p>
<pre><code>1.  题目1

    if (!(&quot;a&quot; in window)) {
        var a = 1;
    }
    alert(a);
   答案是undefined
2. var a = 1,
       b = function a(x) {
           x &amp;&amp; a(--x);
       };
   alert(a);
   答案1
3. function a(x) {
       return x * 2;
   }
   var a;
   alert(a);
   答案 a函数
4. function b(x, y, a) {
       arguments[2] = 10;
       alert(a);
   }
   b(1, 2, 3);
   答案是10
5. function a() {
       alert(this);
   }
   a.call(null);
    答案是window
</code></pre><h1 id="第二十一部分，S-O-L-I-D五大原则之接口隔离原则ISP"><a href="#第二十一部分，S-O-L-I-D五大原则之接口隔离原则ISP" class="headerlink" title="第二十一部分，S.O.L.I.D五大原则之接口隔离原则ISP"></a>第二十一部分，S.O.L.I.D五大原则之接口隔离原则ISP</h1><p>没看懂，基本不用看</p>
<h1 id="第二十二部分，S-O-L-I-D五大原则之依赖倒置原则DIP"><a href="#第二十二部分，S-O-L-I-D五大原则之依赖倒置原则DIP" class="headerlink" title="第二十二部分，S.O.L.I.D五大原则之依赖倒置原则DIP]"></a>第二十二部分，S.O.L.I.D五大原则之依赖倒置原则DIP]</h1><p>稍微看懂了，估计是因为java看多了，ioc，基本不用看</p>
<h1 id="第二十三部分，JavaScript与DOM（上）——也适用于新手"><a href="#第二十三部分，JavaScript与DOM（上）——也适用于新手" class="headerlink" title="第二十三部分，JavaScript与DOM（上）——也适用于新手"></a>第二十三部分，JavaScript与DOM（上）——也适用于新手</h1><pre><code>最重要的是Element, Text, Document。

 Element节点在页面里展示的是一个元素，所以如果你有段落元素(&lt;p&gt;)，你可以通过这个DOM节点来访问。
 Text节点在页面里展示的所有文本相关的元素，所以如果你的段落有文本在里面的话，你可以直接通过DOM的Text节点来访问这个文本
 Document节点代表是整个文档，它是DOM的根节点。

nodeType类型，1是元素，2是属性，3是text节点，详细的type类型可以通过此地址：

    Node.ELEMENT_NODE == 1
    Node.ATTRIBUTE_NODE == 2
    Node.TEXT_NODE == 3
    Node.CDATA_SECTION_NODE == 4
    Node.ENTITY_REFERENCE_NODE == 5
    Node.ENTITY_NODE == 6
    Node.PROCESSING_INSTRUCTION_NODE == 7
    Node.COMMENT_NODE == 8
    Node.DOCUMENT_NODE == 9
    Node.DOCUMENT_TYPE_NODE == 10
    Node.DOCUMENT_FRAGMENT_NODE == 11
    Node.NOTATION_NODE == 12
</code></pre><h1 id="第二十四部分，JavaScript与DOM（下）"><a href="#第二十四部分，JavaScript与DOM（下）" class="headerlink" title="第二十四部分，JavaScript与DOM（下）"></a>第二十四部分，JavaScript与DOM（下）</h1><pre><code>node节点的2种类型，一种是元素节点，一种是text节点，上一章节已经列出了所有的节点类型，这两种需要我们现在特别注意。创建元素可以通过createElement方法，而创建text节点可以使用createTextNode，相应代码如下：
正如我们上章所说的，DOM和JavaScript语言是2个单独的东西，浏览器事件是DOM API的一部分，而不是JavaScript的一部分。

‘mouseover’ – 鼠标移动到某元素上的时候触发mouseover事件。
 ‘mouseout’ – 鼠标从某元素离开的时候触发mouseout事件。
 ‘mousemove’ – 鼠标在某元素上移动但未离开的时候触发mousemove事件。
 ‘change’ – 控件失去input焦点的时候触发该事件（或者值被改变的时候）。

 ‘load’ – 页面加载完毕（包括内容、图片、frame、object）的时候触发该事件。
 ‘resize’ – 页面大小改变的时候触发该事件（例如浏览器缩放）。
 ‘scroll’ – 页面滚动的时候触发该事件。
 ‘unload’ – 从页面或frame删除所有内容的时候触发该事件（例如离开一个页面）。

 严格来说，有2中不同的模型：W3C模型和微软模型，除IE之外W3C模型支持所有的现代浏览器，而微软模型只支持IE

 使用W3C模型的代码如下：

 // 格式：target.addEventListener( type, function, useCapture );  
 // 例子:  
 var myIntro = document.getElementById(&apos;intro&apos;);
 myIntro.addEventListener(&apos;click&apos;, introClick, false);
 使用IE模型的代码如下：

 // 格式: target.attachEvent ( &apos;on&apos; + type, function );  
 // 例子:  
 var myIntro = document.getElementById(&apos;intro&apos;);
 myIntro.attachEvent(&apos;onclick&apos;, introClick);

 一个非常重要的内容是Event对象，当事件发生的时候出发某个函数，该Event对象将自动在函数内可用，该对象包含了很多事件触发时候的信息，但IE却没有这么实现，而是自己实现的，IE浏览器是通过全局对象window下的event属性来包含这些信息

 例如当你想取消默认的行为的时候你可以使用Event对象里的preventDefault()方法，但IE里不得不使用对象的returnValue属性值来控制


 事件冒泡，就是事件触发的时候通过DOM向上冒泡，首先要知道不是所有的事件都有冒泡。事件在一个目标元素上触发的时候，该事件将触发一一触发祖先节点元素，直到最顶层的元素：
 如图所示，如果a连接被点击，触发触发连接的click事件，然后触发p的click事件，以此再触发div和body的click事件。顺序不变，而且不一定是在同时触发的。
 举例来说，如果你有一个很多行的大表格，在每个&lt;tr&gt;上绑定点击事件是个非常危险的想法，因为性能是个大问题。流行的做法是使用事件委托。事件委托描述的是将事件绑定在容器元素上，然后通过判断点击的target子元素的类型来触发相应的事件。
 事件委托依赖于事件冒泡，如果事件冒泡到table之前被禁用的话，那上面的代码就无法工作了。

 经典的事件处理模型，微软的冒泡，以及网景的捕获模型，w3c的两者兼容，网上例子很多，去看解释
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感2&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感2&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaScrip
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感一（1——16节）</title>
    <link href="http://ghohankawk.github.io/2017/06/12/tomdashu/"/>
    <id>http://ghohankawk.github.io/2017/06/12/tomdashu/</id>
    <published>2017-06-12T04:07:39.341Z</published>
    <updated>2017-06-13T03:12:08.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感</h1><h1 id="第一部分，编写高质量JavaScript代码的基本要点"><a href="#第一部分，编写高质量JavaScript代码的基本要点" class="headerlink" title="第一部分，编写高质量JavaScript代码的基本要点"></a>第一部分，编写高质量JavaScript代码的基本要点</h1><p>内容不多，但是作为从头规范开始，值得遵循，现在看来，才更能明白里面的道理。<br>总结一下：</p>
<pre><code>1. 避免全局变量，为啥？自己去看，以及隐式全局变量的副作用，那怎么办？命名空间
2. 推荐单一的单var形式，如  var a = 1,b = 2,myobject = {};形式
3. for循环，预存缓存变量，for-in遍历对象用hasOwnProperty，去掉原型链的属性
4. 避免使用eval，记住该咒语“eval()是魔鬼”，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免                     
5. 编码规范，缩进，空格，花括号，分号
6. 命名函数，啥时候大写，啥时候小写，推荐驼峰命名
7. 关于注解，通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。
</code></pre><h1 id="第二部分，揭秘命名函数表达式"><a href="#第二部分，揭秘命名函数表达式" class="headerlink" title="第二部分，揭秘命名函数表达式"></a>第二部分，揭秘命名函数表达式</h1><p>总结如下：</p>
<pre><code>1. 什么是申明函数？
2. 什么是表达式函数？
3. 什么是函数语句？
4. 什么是命名函数？
5. 主要是区别的地方，很细微，然后又很多浏览器的怪异行为，坑比较多
6. 还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式
7. 后面的部分，如果第一次看，肯定看不懂，是啥意思，建议先忽略掉
</code></pre><h1 id="第三部分，全面解析Module模式"><a href="#第三部分，全面解析Module模式" class="headerlink" title="第三部分，全面解析Module模式"></a>第三部分，全面解析Module模式</h1><p>总结如下：</p>
<pre><code>1. 正常的module模式，缺点就是，每次都必须new，每个实例都是单独的
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Calculator = function (eq) &#123;</div><div class="line">       //这里可以声明私有成员</div><div class="line">   </div><div class="line">       var eqCtl = document.getElementById(eq);</div><div class="line">   </div><div class="line">       return &#123;</div><div class="line">           // 暴露公开的成员</div><div class="line">           add: function (x, y) &#123;</div><div class="line">               var val = x + y;</div><div class="line">               eqCtl.innerHTML = val;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<pre><code>2. 改进过后的，利用函数自执行，可以直接使用
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;, privateName = &quot;博客园&quot;;</div><div class="line"></div><div class="line">    function privateAddTopic(data) &#123;</div><div class="line">        // 这里是内部处理代码</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my.Name = privateName;</div><div class="line">    my.AddTopic = function (data) &#123;</div><div class="line">        privateAddTopic(data);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<pre><code>3. 改進松耦合
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (my) &#123;</div><div class="line"></div><div class="line">    // 添加一些功能   </div><div class="line">    </div><div class="line">    return my;</div><div class="line">&#125; (blogModule || &#123;&#125;));</div></pre></td></tr></table></figure>
<pre><code>4. 克隆
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  var blogModule = (function (old) &#123;</div><div class="line">       var my = &#123;&#125;,</div><div class="line">           key;</div><div class="line">    for (key in old) &#123;</div><div class="line">        if (old.hasOwnProperty(key)) &#123;</div><div class="line">            my[key] = old[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var oldAddPhotoMethod = old.AddPhoto;</div><div class="line">    my.AddPhoto = function () &#123;</div><div class="line">        // 克隆以后，进行了重写，当然也可以继续调用oldAddPhotoMethod</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<pre><code>5. 子模块
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">blogModule.CommentSubModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;;</div><div class="line">    // ...</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<h1 id="第四部分，立即调用的函数表达式"><a href="#第四部分，立即调用的函数表达式" class="headerlink" title="第四部分，立即调用的函数表达式"></a>第四部分，立即调用的函数表达式</h1><pre><code>1. 自動執行
(function () { /* code */ } ()); // 推荐使用这个
2. (function () { /* code */ })(); // 但是这个也是可以用的，括號
3.在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。
4. 闭包的经典例子
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">   错误的：</div><div class="line">   var elems = document.getElementsByTagName(&apos;a&apos;);</div><div class="line">   </div><div class="line">   for (var i = 0; i &lt; elems.length; i++) &#123;</div><div class="line">   </div><div class="line">       elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</div><div class="line">           e.preventDefault();</div><div class="line">           alert(&apos;I am link #&apos; + i);</div><div class="line">       &#125;, &apos;false&apos;);</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">正确的：会锁住对应的index的值，虽然i最后为10，但是之前的值，已经记录好了</div><div class="line">var elems = document.getElementsByTagName(&apos;a&apos;);</div><div class="line"></div><div class="line">for (var i = 0; i &lt; elems.length; i++) &#123;</div><div class="line"></div><div class="line">    (function (lockedInIndex) &#123;</div><div class="line"></div><div class="line">        elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</div><div class="line">            e.preventDefault();</div><div class="line">            alert(&apos;I am link #&apos; + lockedInIndex);</div><div class="line">        &#125;, &apos;false&apos;);</div><div class="line"></div><div class="line">    &#125;)(i);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">   ``` </div><div class="line">       5. 不管什么是自执行，还是立即调用，不用分那么清楚，只需知道立即执行一次匿名函数就够了</div><div class="line">       </div><div class="line"># 第五部分，强大的原型和原型链</div><div class="line"></div><div class="line">    1. 原型关键词，prototype</div><div class="line">    2. 说白了，原型就是一个对象</div><div class="line">    3. 通过hasOwnProperty，区分属性从哪里来的</div><div class="line">    4. 默认还有一个原型的链条，一直到Object.prototype为止</div><div class="line">    5. 所有的对象都有&quot;[[prototype]]&quot;属性（通过__proto__访问），该属性对应对象的原型</div><div class="line">    6. 所有的函数对象都有&quot;prototype&quot;属性，该属性的值会被赋值给该函数创建的对象的&quot;__proto__&quot;属性</div><div class="line">    7. 所有的原型对象都有&quot;constructor&quot;属性，该属性对应创建所有指向该原型的实例的构造函数</div><div class="line">    8. 函数对象和原型对象通过&quot;prototype&quot;和&quot;constructor&quot;属性进行相互关联</div><div class="line">    9. 最简单易懂的看下边</div><div class="line">   [原型链介绍](https://www.talkingcoder.com/article/6360227501704156372)</div><div class="line"></div><div class="line"># 第六七八部分，S.O.L.I.D五大原则之单一职责SRP（忽略）</div><div class="line"></div><div class="line">    The Single Responsibility Principle（单一职责SRP）</div><div class="line">    The Open/Closed Principle（开闭原则OCP）</div><div class="line">    The Liskov Substitution Principle（里氏替换原则LSP）</div><div class="line">    The Interface Segregation Principle（接口分离原则ISP）</div><div class="line">    The Dependency Inversion Principle（依赖反转原则DIP）</div><div class="line"># 第九部分，根本没有“JSON对象”这回事！</div><div class="line"></div><div class="line">    简单的说</div><div class="line">    1. // 这是JSON字符串</div><div class="line">       var foo = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;;</div><div class="line">    2. // 这是对象字面量</div><div class="line">       var bar = &#123; &quot;prop&quot;: &quot;val&quot; &#125;;</div><div class="line">    3. // 将字符串反序列化成json对象</div><div class="line">       var my_obj = JSON.parse( foo );</div><div class="line">    4. json对象，和字面量对象，明显的区别，前者必须有引号，后者去掉引号可以</div><div class="line">           var bar = &#123; prop: &quot;val&quot; &#125;;合法的</div><div class="line">    </div><div class="line"># 第十部分，JavaScript核心（晋级高手必读篇）</div><div class="line">    1. 执行上下文栈(Execution Context Stack)，有三种类型：global, function和eval。</div><div class="line">    2. 执行上下文(Execution Context)，变量对象(variable object)，this指针(this value)，作用域链(scope chain)</div><div class="line">    函数表达式[function expression]（而不是函数声明[function declarations，区别请参考本系列第2章]）是不包含在VO[variable object]里面的</div><div class="line">    3. 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。</div><div class="line">       它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</div><div class="line">    4. 当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了</div><div class="line">    5. 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</div><div class="line">    6. 这表示，在我们去搜寻__parent__之前，首先会去__proto__的链接中。</div><div class="line">    7. 闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</div><div class="line">    8. 在ECMAScript中，是不可以给this赋值的，因为，还是那句话，this不是变量。</div><div class="line">    9. this是执行上下文环境的一个属性，而不是某个变量对象的属性</div><div class="line"># 第十一部分，执行上下文（Execution Contexts）</div><div class="line">可以把调用上下文作为第二个参数传递给eval。那么，如果这个上下文存在，就有可能影响“私有”(有人喜欢这样叫它)变量。</div><div class="line"># 第十二部分，变量对象（Variable Object）</div><div class="line">```angularjs</div><div class="line">    if (true) &#123;</div><div class="line">        var a = 1;</div><div class="line">        &#125; else &#123;</div><div class="line">        var b = 2;</div><div class="line">        &#125;</div><div class="line">    alert(a); // 1</div><div class="line">    alert(b); // undefined,不是b没有声明，而是b的值是undefined</div></pre></td></tr></table></figure>
<p>变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">a = 10;</div><div class="line">alert(window.a); // 10</div><div class="line"> </div><div class="line">alert(delete a); // true</div><div class="line"> </div><div class="line">alert(window.a); // undefined</div><div class="line"> </div><div class="line">var b = 20;</div><div class="line">alert(window.b); // 20</div><div class="line"> </div><div class="line">alert(delete b); // false</div><div class="line"> </div><div class="line">alert(window.b); // still 20</div></pre></td></tr></table></figure></p>
<p>但是这个规则在有个上下文里不起走样，那就是eval上下文，变量没有{DontDelete}特性。</p>
<h1 id="第十三部分，This-Yes-this"><a href="#第十三部分，This-Yes-this" class="headerlink" title="第十三部分，This? Yes,this!"></a>第十三部分，This? Yes,this!</h1><pre><code>1，一个函数上下文中确定this值的通用规则如下：
2. 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。
3. 我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的this值，答案在于引用类型（type Reference）不同的中间值。
4. 标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名
5. (function () {
     alert(this); // null =&gt; global
   })();
6. 函数调用中手动设置this，apply,call
7. 作为构造器调用的函数中的this,都将this的值设置为新创建的对象。
8. 引用类型和this为null,默认为golbal
</code></pre><h1 id="第十四部分，作用域链-Scope-Chain"><a href="#第十四部分，作用域链-Scope-Chain" class="headerlink" title="第十四部分，作用域链(Scope Chain)"></a>第十四部分，作用域链(Scope Chain)</h1><pre><code>1. 函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。
2. 注意这重要的一点－－[[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁 
3. 闭包理解
var x = 10;

function foo() {
  alert(x);
}

(function () {
  var x = 20;
  foo(); // 10, but not 20
})();
[[Scope]]包括在函数内创建的词法作用域（父变量对象）。当函数进一步激活时，在变量对象的这个词法链（静态的存储于创建时）中，来自较高作用域的变量将被搜寻。
此外，这个例子也清晰的表明，一个函数（这个例子中为从函数“foo”返回的匿名函数）的[[scope]]持续存在，即使是在函数创建的作用域已经完成之后。
4. 通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象
5. 源于ECMAScript 的原型特性。如果一个属性在对象中没有直接找到，查询将在原型链中继续。即常说的二维链查找。（1）作用域链环节；（2）每个作用域链－－深入到原型链环节
6. 全局和eval上下文中的作用域链,全局上下文的作用域链仅包含全局对象
7. 在代码执行阶段有两个声明能修改作用域链。这就是with声明和catch语句。它们添加到作用域链的最前端，对象须在这些声明中出现的标识符中查找。
</code></pre><h1 id="第十五部分，函数（Functions）"><a href="#第十五部分，函数（Functions）" class="headerlink" title="第十五部分，函数（Functions）"></a>第十五部分，函数（Functions）</h1><pre><code>1。 只有这2个位置可以声明函数，也就是说:不可能在表达式位置或一个代码块中定义它。
2. // 函数可以在如下地方声明：
   // 1) 直接在全局上下文中
   function globalFD() {
     // 2) 或者在一个函数的函数体内
     function innerFD() {}
   }
3. 相当一部分问题出现了，我们为什么需要函数表达式？答案很明显——在表达式中使用它们，”不会污染”变量对象。最简单的例子是将一个函数作为参数传递给其它函数。
4. 这种模式中，初始化的FE的名称通常被忽略：
(function () {
   // 初始化作用域 
})();
5. ”为何在函数创建后的立即调用中必须用圆括号来包围它？”，答案就是：表达式句子的限制就是这样的。
6. function () {
     ...
   }();

   // 即便有名称

   function foo() {
     ...
   }();
如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。

第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。
</code></pre><h1 id="第十六部分，闭包（Closures）"><a href="#第十六部分，闭包（Closures）" class="headerlink" title="第十六部分，闭包（Closures）"></a>第十六部分，闭包（Closures）</h1><pre><code>var z = 10;

function foo() {
  alert(z);
}

foo(); // 10 – 使用静态和动态作用域的时候

(function () {

  var z = 20;
  foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域

})();

// 将foo作为参数的时候是一样的
(function (funArg) {

  var z = 30;
  funArg(); // 10 – 静态作用域, 30 – 动态作用域

})(foo);
上述描述的就是两类funarg问题 —— 取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。

为了解决上述问题，就引入了 闭包的概念。

这里说明一下，开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，甚至理解成只有匿名函数才能是闭包。

再说一下，因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。
ECMAScript中，闭包指的是：

从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
从实践角度：以下函数才算是闭包：
即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
在代码中引用了自由变量

顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：

闭包还有另外一个非常重要的应用 —— 延迟调用：

var a = 10;
setTimeout(function () {
  alert(a); // 10, after one second
}, 1000);

还可以创建封装的作用域来隐藏辅助对象：

var foo = {};

// 初始化
(function (object) {

  var x = 10;

  object.getX = function _getX() {
    return x;
  };

})(foo);

alert(foo.getX()); // 获得闭包 &quot;x&quot; – 10
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaScript系
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>adSense试试看</title>
    <link href="http://ghohankawk.github.io/2017/06/09/adSense/"/>
    <id>http://ghohankawk.github.io/2017/06/09/adSense/</id>
    <published>2017-06-09T04:13:09.827Z</published>
    <updated>2017-06-09T04:18:04.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是adSense"><a href="#今天要分享的内容是adSense" class="headerlink" title="今天要分享的内容是adSense"></a>今天要分享的内容是adSense</h1><h1 id="最近老大让弄广告"><a href="#最近老大让弄广告" class="headerlink" title="最近老大让弄广告"></a>最近老大让弄广告</h1><p>既然自己都在做这个东西，何不在自己的网站里面引进一下，试试看，效果如何</p>
<h1 id="后续再加统计"><a href="#后续再加统计" class="headerlink" title="后续再加统计"></a>后续再加统计</h1><p>暂时留个坑</p>
<h1 id="高考终于结束了，老弟也解放了，-｡･∀･-ﾉﾞ嗨的和同学聚会去了"><a href="#高考终于结束了，老弟也解放了，-｡･∀･-ﾉﾞ嗨的和同学聚会去了" class="headerlink" title="高考终于结束了，老弟也解放了，(｡･∀･)ﾉﾞ嗨的和同学聚会去了"></a>高考终于结束了，老弟也解放了，(｡･∀･)ﾉﾞ嗨的和同学聚会去了</h1><h1 id="晚上又能回家了，离得近，就是这点方便"><a href="#晚上又能回家了，离得近，就是这点方便" class="headerlink" title="晚上又能回家了，离得近，就是这点方便"></a>晚上又能回家了，离得近，就是这点方便</h1><p>为天下的学子庆祝一下，一图胜前言<br><img src="http://img1.gtimg.com/gamezone/pics/hv1/56/203/1857/120803246.jpg" alt=""></p>
<h1 id="恭喜表哥要订婚了"><a href="#恭喜表哥要订婚了" class="headerlink" title="恭喜表哥要订婚了"></a>恭喜表哥要订婚了</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是adSense&quot;&gt;&lt;a href=&quot;#今天要分享的内容是adSense&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是adSense&quot;&gt;&lt;/a&gt;今天要分享的内容是adSense&lt;/h1&gt;&lt;h1 id=&quot;最近老大让弄广告&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写在高考前，对弟弟的祝福</title>
    <link href="http://ghohankawk.github.io/2017/06/06/before-gaokao/"/>
    <id>http://ghohankawk.github.io/2017/06/06/before-gaokao/</id>
    <published>2017-06-06T11:49:16.524Z</published>
    <updated>2017-06-06T12:04:47.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随便写点"><a href="#随便写点" class="headerlink" title="随便写点"></a>随便写点</h1><p>记得十年前，这个时候，已经进入了考场，转眼，十年都过去了</p>
<h1 id="有首歌叫十年"><a href="#有首歌叫十年" class="headerlink" title="有首歌叫十年"></a>有首歌叫十年</h1><p>确实，十年之前，你不认识我，我不认识你</p>
<h1 id="每个人都需要经历这个坎"><a href="#每个人都需要经历这个坎" class="headerlink" title="每个人都需要经历这个坎"></a>每个人都需要经历这个坎</h1><p>谁都替代不了，可能有些人比较顺利的迈过去了，而有些人很难</p>
<p>这个事情，说重要，它确认重要，足以改变人的一生命运</p>
<p>不重要，也不过是一场考试而已，在人生的旅途中，只是一个章节而已</p>
<h1 id="我只想说，"><a href="#我只想说，" class="headerlink" title="我只想说，"></a>我只想说，</h1><p>认真对待，在正确的年龄做正确的事情，就足矣了</p>
<p>不过结果如何，你老爸老妈，都在等你回家吃饭</p>
<p>老哥，也祝福你，十年寒窗，加油，上图吧</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63198678_d0361387025dac92a6181c21104178c2" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63198678" target="_blank">米娜桑~高考加油！  (<em>ﾟ▽ﾟ</em>)</a> by <a href="https://www.pixiv.net/member.php?id=14531483" target="_blank">KoinKoni</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;随便写点&quot;&gt;&lt;a href=&quot;#随便写点&quot; class=&quot;headerlink&quot; title=&quot;随便写点&quot;&gt;&lt;/a&gt;随便写点&lt;/h1&gt;&lt;p&gt;记得十年前，这个时候，已经进入了考场，转眼，十年都过去了&lt;/p&gt;
&lt;h1 id=&quot;有首歌叫十年&quot;&gt;&lt;a href=&quot;#有首歌
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于log4j的使用说明</title>
    <link href="http://ghohankawk.github.io/2017/06/06/log4j/"/>
    <id>http://ghohankawk.github.io/2017/06/06/log4j/</id>
    <published>2017-06-06T10:58:35.396Z</published>
    <updated>2017-06-06T11:40:08.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是log4j的使用。"><a href="#今天要分享的内容是log4j的使用。" class="headerlink" title="今天要分享的内容是log4j的使用。"></a>今天要分享的内容是log4j的使用。</h1><p>每个系统都有日志记录，而多数都是用的log4j，以为会配置了，懂了，发现还是有些细节的问题，要问，说不上来</p>
<h1 id="先来直接看配置吧和测试用例吧"><a href="#先来直接看配置吧和测试用例吧" class="headerlink" title="先来直接看配置吧和测试用例吧"></a>先来直接看配置吧和测试用例吧</h1><p>jar包的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- log4j support --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2.17&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>log4j.properties文件如下，放在你的web的resource下面，推荐maven标准工程来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">### 设置###</div><div class="line">log4j.rootLogger = DEBUG,stdout,D,E</div><div class="line"></div><div class="line">log4j.logger.A=DEBUG, stdout</div><div class="line">log4j.logger.A.B=INFO, stdout  </div><div class="line"></div><div class="line">### 输出信息到控制抬 ###</div><div class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.stdout.Target = System.out</div><div class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div><div class="line"></div><div class="line">### 输出DEBUG 级别以上的日志到=D://logs/error.log ###</div><div class="line">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</div><div class="line">log4j.appender.D.File = D://logs/log.log</div><div class="line">log4j.appender.D.Append = true</div><div class="line">log4j.appender.D.Threshold = DEBUG</div><div class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</div><div class="line"></div><div class="line">### 输出ERROR 级别以上的日志到=D://logs/error.log ###</div><div class="line">log4j.appender.E = org.apache.log4j.DailyRollingFileAppender</div><div class="line">log4j.appender.E.File =D://logs/error.log</div><div class="line">log4j.appender.E.Append = true</div><div class="line">log4j.appender.E.Threshold = ERROR</div><div class="line">log4j.appender.E.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</div></pre></td></tr></table></figure></p>
<p>测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import org.apache.log4j.Logger;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-06 18:32</div><div class="line"> */</div><div class="line">public class log4jTtest &#123;</div><div class="line">    private static Logger logger = Logger.getLogger(log4jTtest.class);</div><div class="line">    private static Logger loggerA = Logger.getLogger(&quot;A&quot;);</div><div class="line">    private static Logger loggerA_B = Logger.getLogger(&quot;A.B&quot;);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        // 记录debug级别的信息</div><div class="line">        logger.debug(&quot;This is debug message.&quot;);</div><div class="line">        // 记录info级别的信息</div><div class="line">        logger.info(&quot;This is info message.&quot;);</div><div class="line">        // 记录error级别的信息</div><div class="line">        logger.error(&quot;This is error message.&quot;);</div><div class="line"></div><div class="line">        loggerA_B.info(&quot;repeat three times in console&quot;);</div><div class="line">        loggerA.info(&quot;repeat two times in console&quot;);</div><div class="line">        logger.info(&quot;repeat one times in console&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="注意上面的输出结果，你知道输出啥内容，则，就真正理解了"><a href="#注意上面的输出结果，你知道输出啥内容，则，就真正理解了" class="headerlink" title="注意上面的输出结果，你知道输出啥内容，则，就真正理解了"></a>注意上面的输出结果，你知道输出啥内容，则，就真正理解了</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[DEBUG] 2017-06-06 19:05:03,477 method:log4jTtest.main(log4jTtest.java:18)</div><div class="line">This is debug message.</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:20)</div><div class="line">This is info message.</div><div class="line">[ERROR] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:22)</div><div class="line">This is error message.</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)</div><div class="line">repeat three times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)</div><div class="line">repeat three times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)</div><div class="line">repeat three times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:25)</div><div class="line">repeat two times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:25)</div><div class="line">repeat two times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:26)</div><div class="line">repeat one times in console</div></pre></td></tr></table></figure>
<h1 id="问题如下"><a href="#问题如下" class="headerlink" title="问题如下"></a>问题如下</h1><ol>
<li>前面的三个输出，不用解释，都明白为啥</li>
<li>为啥那个loggerA_B，输出了三次，而loggerA输出了二次，logger输出了一次？</li>
</ol>
<h1 id="log4j几个重要的概念"><a href="#log4j几个重要的概念" class="headerlink" title="log4j几个重要的概念"></a>log4j几个重要的概念</h1><ul>
<li>logger组件<ol>
<li>简单的说，它就是决定了应用程序中，哪些代码哪些地方，有可能输出日志</li>
<li>这也就是为什么，每个类里面上来，就是，logger的初始化，它决定了这个类有资格输出日志</li>
<li>首先Log4J中总是存在一个rootLogger，即使没有显示配置也是存在的，并且默认输出级别为DEBUG。</li>
<li>Log4J中的层次是用’.’来分隔的，如log4j.logger.com.example.test，这里并不是说log4j.logger后面一定是具体的包名乃至类名，</li>
</ol>
</li>
<li>appender组件<ol>
<li>输出地，也就是你的日志想输出到哪里，把上面的logger里面的日志</li>
<li>再简单点，就是输出到控制台和文件里面，也就是上面的配置stdout和D和E</li>
<li>这个需要和下面的这个概念配合</li>
</ol>
</li>
<li>输出控制的概念<ol>
<li>Log4j默认把日志信息分为五个等级  all&lt;debug &lt; info &lt; warn &lt; error &lt; fatal&lt;off</li>
<li>只有大于设置的级别，才会打印日志，低于则忽略</li>
<li>log4j.appender.threshold=ERROR，这种配置用于控制，一个appender的输出级别</li>
</ol>
</li>
<li>继承的概念<ol>
<li>log4j.rootLogger=DEBUG, Console</li>
<li>log4j.logger.A=DEBUG, Console</li>
<li>log4j.logger.A.B=INFO, Console</li>
<li>A.B继承A，再继承最顶级的root</li>
<li>Log4j是根据Log的名字来判断继承关系的</li>
</ol>
</li>
</ul>
<h1 id="来解释一下，上面的输出结果"><a href="#来解释一下，上面的输出结果" class="headerlink" title="来解释一下，上面的输出结果"></a>来解释一下，上面的输出结果</h1><ol>
<li>首先是，debug，info和error前三个日志输出，它们的logger是log4jTtest.class初始化的，继承根logger，因此就是debug级别，同时因为还有D和E的两个appender，所以你在d盘可以看到，有一个info的文件还有一个error的文件，这个日志输出没问题</li>
<li>然后就是解释那重复的三个，因为loggerA_B，它是根据A.B这个参数初始化的，是有继承的，满足A.B的info级别的日志输出，必然满足A的logger的日志输出，当然还有默认的根输出，因此三次</li>
<li>而那个两次的，它的logger是loggerA，继承于根，因此，info的时候，它本身输出一次，根也输出一次，就是两次了。</li>
<li>最后一个，用的是默认的根，当然，只能输出一次了</li>
</ol>
<h1 id="问题来了，怎么避免重复，因为继承父的logger？"><a href="#问题来了，怎么避免重复，因为继承父的logger？" class="headerlink" title="问题来了，怎么避免重复，因为继承父的logger？"></a>问题来了，怎么避免重复，因为继承父的logger？</h1><pre><code>log4j.additivity.A.B=false
logger A.B的日志仅会输出到自己Console中，不会继承任何父logger的appender。
</code></pre><p> 就加上面的这句，就解决了问题</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前反反复复看了很多次，关于日志log4j的配置，每次看完以为会了，但是到了项目里面，总是不知道，自己有时候打印的日志到底跑哪里去了，或者去哪里看？<br>总结其原因就是，对于细节没有掌握理解到位，比如就是这个logger的概念，如果你真正的明白了，就知道了</p>
<p>谁能产生日志？logger</p>
<p>日志放哪里？appender</p>
<p>什么级别的日志才会输出？日志级别</p>
<p>他们是相互独立的组件，单独配置，又是相互配合，一起使用的，n*m的这种概念</p>
<p>因此上面的配置文件，一个logger可以对应多个appender，而appender之间又是彼此独立的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是log4j的使用。&quot;&gt;&lt;a href=&quot;#今天要分享的内容是log4j的使用。&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是log4j的使用。&quot;&gt;&lt;/a&gt;今天要分享的内容是log4j的使用。&lt;/h1&gt;&lt;p&gt;每个系统都有
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>六一儿童节快乐（补）</title>
    <link href="http://ghohankawk.github.io/2017/06/02/liuyi/"/>
    <id>http://ghohankawk.github.io/2017/06/02/liuyi/</id>
    <published>2017-06-02T09:45:21.639Z</published>
    <updated>2017-06-02T09:47:39.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="昨天这么重要的节日忘记了"><a href="#昨天这么重要的节日忘记了" class="headerlink" title="昨天这么重要的节日忘记了"></a>昨天这么重要的节日忘记了</h1><p>今天专程来补图，喵帕斯~<br>祝天下所有的大小朋友，儿童节快乐~<br><img src="http://img.ngacn.cc/attachments/mon_201706/01/-9lddQ13m-9na1KxT1kSgl-d8.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;昨天这么重要的节日忘记了&quot;&gt;&lt;a href=&quot;#昨天这么重要的节日忘记了&quot; class=&quot;headerlink&quot; title=&quot;昨天这么重要的节日忘记了&quot;&gt;&lt;/a&gt;昨天这么重要的节日忘记了&lt;/h1&gt;&lt;p&gt;今天专程来补图，喵帕斯~&lt;br&gt;祝天下所有的大小朋友，儿童节
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中的pattern和matcher的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/02/java-match/"/>
    <id>http://ghohankawk.github.io/2017/06/02/java-match/</id>
    <published>2017-06-02T08:53:23.377Z</published>
    <updated>2017-06-02T09:24:24.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java语言中的pattern和matcher的用法"><a href="#今天要分享的内容是java语言中的pattern和matcher的用法" class="headerlink" title="今天要分享的内容是java语言中的pattern和matcher的用法"></a>今天要分享的内容是java语言中的pattern和matcher的用法</h1><p>java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。<br>它包括两个类：Pattern和Matcher Pattern 一个Pattern是一个正则表达式经编译后的表现模式。<br>Matcher 一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。<br>首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，<br>然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。</p>
<h1 id="先理解捕获组的概念"><a href="#先理解捕获组的概念" class="headerlink" title="先理解捕获组的概念"></a>先理解捕获组的概念</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">捕获组可以通过从左到右计算其开括号来编号，编号是从1 开始的。</div><div class="line">例如，在表达式 ((A)(B(C)))中，存在四个这样的组：</div><div class="line">1        ((A)(B(C)))</div><div class="line">2        (A)</div><div class="line">3        (B(C))</div><div class="line">4        (C)</div><div class="line"></div><div class="line">组0始终代表整个表达式。</div></pre></td></tr></table></figure>
<h1 id="详解Pattern类"><a href="#详解Pattern类" class="headerlink" title="详解Pattern类"></a>详解Pattern类</h1><pre><code>Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, 
Java代码示例: 
Pattern p=Pattern.compile(&quot;\\w+&quot;); 
p.pattern();//返回 \w+ 
</code></pre><h1 id="详解Matcher类"><a href="#详解Matcher类" class="headerlink" title="详解Matcher类"></a>详解Matcher类</h1><pre><code>说了这么多,终于轮到Matcher类登场了,Pattern.matcher(CharSequence input)返回一个Matcher对象.
Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例. 
Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持. 
Java代码示例: 

Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;22bb23&quot;); 
m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 
</code></pre><h1 id="注意看下面这个例子，pattern方法返回的值"><a href="#注意看下面这个例子，pattern方法返回的值" class="headerlink" title="注意看下面这个例子，pattern方法返回的值"></a>注意看下面这个例子，pattern方法返回的值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import java.util.regex.Matcher;</div><div class="line">import java.util.regex.Pattern;</div><div class="line"></div><div class="line">public class StringPattern &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Pattern p = Pattern.compile(&quot;\\d+&quot;);</div><div class="line">        Matcher m = p.matcher(&quot;22bb23&quot;);</div><div class="line">        Pattern pattern = m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的</div><div class="line">        String pattern1 = pattern.pattern();</div><div class="line">        System.out.println(pattern1);//\d+</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Matcher-matches-Matcher-lookingAt-Matcher-find-区别"><a href="#Matcher-matches-Matcher-lookingAt-Matcher-find-区别" class="headerlink" title="Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()区别"></a>Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()区别</h1><ol>
<li>Matcher类提供三个匹配操作方法,三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回false<br>matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true </li>
<li>lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true </li>
<li>find()对字符串进行匹配,匹配到的字符串可以在任何位置. </li>
</ol>
<h1 id="Mathcer-start-Matcher-end-Matcher-group"><a href="#Mathcer-start-Matcher-end-Matcher-group" class="headerlink" title="Mathcer.start()/ Matcher.end()/ Matcher.group()"></a>Mathcer.start()/ Matcher.end()/ Matcher.group()</h1><ol>
<li>当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息. </li>
<li>start()返回匹配到的子字符串在字符串中的索引位置. </li>
<li>end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. </li>
<li>group()返回匹配到的子字符串 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.regex.Matcher;</div><div class="line">import java.util.regex.Pattern;</div><div class="line"></div><div class="line">public class StringPattern &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Pattern p=Pattern.compile(&quot;([a-z]+)(\\d+)&quot;);</div><div class="line">        Matcher m=p.matcher(&quot;aaa2223bb&quot;);</div><div class="line">        System.out.println(m.find());   //匹配aaa2223</div><div class="line"></div><div class="line">        System.out.println(m.groupCount());  //返回2,因为有2组</div><div class="line">        System.out.println(m.start(1));   //返回0 返回第一组匹配到的子字符串在字符串中的索引号</div><div class="line">        System.out.println(m.start(2));   //返回3</div><div class="line">        System.out.println(m.end(1));   //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置.</div><div class="line">        System.out.println(m.end(2));   //返回7</div><div class="line">        System.out.println(m.group(1));   //返回aaa,返回第一组匹配到的子字符串</div><div class="line">        System.out.println(m.group(2));;   //返回2223,返回第二组匹配到的子字符串</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="find比较特殊，特此说明"><a href="#find比较特殊，特此说明" class="headerlink" title="find比较特殊，特此说明"></a>find比较特殊，特此说明</h1><p>find</p>
<ol>
<li>public boolean find()尝试查找与该模式匹配的输入序列的下一个子序列。<br>此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。<br>如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。  </li>
<li>返回：<br>当且仅当输入序列的子序列匹配此匹配器的模式时才返回 true。</li>
</ol>
<p>因此有下面这种，循环find的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import java.util.regex.Matcher;</div><div class="line">import java.util.regex.Pattern;</div><div class="line"></div><div class="line">public class StringPattern &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Pattern p=Pattern.compile(&quot;\\d+&quot;);</div><div class="line">        Matcher m=p.matcher(&quot;我的QQ是:123 我的电话是:456 我的邮箱是:789@aaa.com&quot;);</div><div class="line">        while(m.find()) &#123;</div><div class="line">            System.out.println(m.group());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="最后强调"><a href="#最后强调" class="headerlink" title="最后强调"></a>最后强调</h1><p>现在大家应该知道,每次执行匹配操作后start(),end(),group()三个方法的值都会改变,改变成匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息.<br>注意:只有当匹配操作成功,才可以使用start(),end(),group()三个方法,否则会抛出java.lang.IllegalStateException,也就是当matches(),lookingAt(),find()其中任意一个方法返回true时,才可以使用.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java语言中的pattern和matcher的用法&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java语言中的pattern和matcher的用法&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java语言中的patte
    
    </summary>
    
    
  </entry>
  
</feed>
