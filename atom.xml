<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闻道</title>
  <subtitle>闻道有先后，术业有专攻，如是而已</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ghohankawk.github.io/"/>
  <updated>2017-06-27T12:38:31.331Z</updated>
  <id>http://ghohankawk.github.io/</id>
  
  <author>
    <name>韩坤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java中string的不可不知的编码知识</title>
    <link href="http://ghohankawk.github.io/2017/06/27/java-encode/"/>
    <id>http://ghohankawk.github.io/2017/06/27/java-encode/</id>
    <published>2017-06-27T12:00:21.421Z</published>
    <updated>2017-06-27T12:38:31.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java的string的字符串编码"><a href="#今天要分享的内容是java的string的字符串编码" class="headerlink" title="今天要分享的内容是java的string的字符串编码"></a>今天要分享的内容是java的string的字符串编码</h1><h1 id="首先记住一句话，字符串在-java-内存中总是按-unicode-编码存储的"><a href="#首先记住一句话，字符串在-java-内存中总是按-unicode-编码存储的" class="headerlink" title="首先记住一句话，字符串在 java 内存中总是按 unicode 编码存储的"></a>首先记住一句话，字符串在 java 内存中总是按 unicode 编码存储的</h1><h1 id="先看一个测试用例"><a href="#先看一个测试用例" class="headerlink" title="先看一个测试用例"></a>先看一个测试用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-27 14:24</div><div class="line"> */</div><div class="line">public class unicode &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 字符串转换unicode</div><div class="line">     */</div><div class="line">    public static String string2Unicode(String string) &#123;</div><div class="line"></div><div class="line">        StringBuffer unicode = new StringBuffer();</div><div class="line">        for (int i = 0; i &lt; string.length(); i++) &#123;</div><div class="line"></div><div class="line">            // 取出每一个字符</div><div class="line">            char c = string.charAt(i);</div><div class="line"></div><div class="line">            // 转换为unicode</div><div class="line">            unicode.append(&quot;\\u&quot; + Integer.toHexString(c));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return unicode.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * unicode 转字符串</div><div class="line">     */</div><div class="line">    public static String unicode2String(String unicode) &#123;</div><div class="line"></div><div class="line">        StringBuffer string = new StringBuffer();</div><div class="line"></div><div class="line">        String[] hex = unicode.split(&quot;\\\\u&quot;);</div><div class="line"></div><div class="line">        for (int i = 1; i &lt; hex.length; i++) &#123;</div><div class="line"></div><div class="line">            // 转换出每一个代码点</div><div class="line">            int data = Integer.parseInt(hex[i], 16);</div><div class="line"></div><div class="line">            // 追加成string</div><div class="line">            string.append((char) data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return string.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 测试字符串长度</div><div class="line">     */</div><div class="line">    public static void stringLength(String string) &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;String is = &quot; + string+&quot; ,default length = &quot;+ string.length());</div><div class="line">        System.out.println(&quot;String is = &quot; + string+&quot; ,getBytes length = &quot;+ string.getBytes().length);</div><div class="line">        System.out.println(&quot;String 中包含 &quot; + (string.getBytes().length-string.length())+&quot; 个中文&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String test = &quot;中文ab&quot;;</div><div class="line"></div><div class="line">        String unicode = string2Unicode(test);</div><div class="line"></div><div class="line">        String string = unicode2String(unicode) ;</div><div class="line"></div><div class="line">        System.out.println(unicode);</div><div class="line"></div><div class="line">        System.out.println(string);</div><div class="line">        String test1 = &quot;中文&quot;;</div><div class="line">        String test2 = &quot;ab&quot;;</div><div class="line">        stringLength(test);</div><div class="line">        stringLength(test1);</div><div class="line">        stringLength(test2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子里面，还提供了一个，快速判断，字符串中，包含的中文个数方法</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>首先，Java中的一个char是2个字节。java采用unicode，2个字节来表示一个字符，这点与C语言中不同，c语言中采用ASCII，在大多数系统中，一个char通常占1个字节，但是在0~127整数之间的字符映射，unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节，但如果采用其他编码方式，一个字符占用的字节数则各不相同。</p>
<p>在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。</p>
<pre><code>我的系统的默认编码方式为GBK，因此对于字符串 “中文ab”，
 如果调用length（）方法返回其长度，得到的结果将为：4。该方法返回的是字符串的字符数，无论是中文字符还是英文字符，都被看做是一个字符。
 如果将其转换为byte数组，而后返回byte数组的长度，得到的结果将为：6。因为在GBK编码中，中文占2个字节，而英文字符占1个字节。
</code></pre><h1 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h1><p>  字符：人们使用的记号，抽象意义上的一个符号。比如：‘1’,‘中’,‘a’</p>
<p>  字节：计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间</p>
<p>  字符集：使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。</p>
<p>  编码：规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码” </p>
<p>  平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p>
<h1 id="iso8859－1"><a href="#iso8859－1" class="headerlink" title="iso8859－1"></a>iso8859－1</h1><p>属于单字节编码，最多能表示的字符范围是 0-255，应用于英文系列。比如，字母 ‘a’ 的编码为0x61=97。 很明显，iso8859-1 编码表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用 iso8859-1 编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在 iso8859-1 编码，以 gb2312 编码为例，应该是”d6d0 cec4” 两个字符，使用 iso8859-1 编码的时候则将它拆开为 4 个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是 UTF 编码，则是 6 个字节 “e4 b8 ad e6 96 87”。很明显，这种表示方法还需要以另一种编码为基础。（unicode）</p>
<h1 id="GB2312-GBK"><a href="#GB2312-GBK" class="headerlink" title="GB2312/GBK"></a>GB2312/GBK</h1><p>这是汉字的国标码，专门用来表示汉字，是双字节编码，而英文字母和 iso8859-1 一致（兼容iso8859-1 编码）。其中 gbk 编码能够用来同时表示繁体字和简体字，而 gb2312 只能表示简体字，gbk是兼容gb2312 编码的。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>这是最统一的编码，可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容 iso8859-1 编码的，也不兼容任何编码。不过，相对于iso8859-1 编码来说，unicode 编码只是在前面增加了一个 0 字节，比如字母 ‘a’ 为 “00 61”。 需要说明的是，定长编码便于计算机处理（注意 GB2312/GBK 不是定长编码），而 unicode 又可以用来表示所有字符，所以在很多软件内部是使用 unicode 编码来处理的，比如 java。</p>
<h1 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h1><p>考虑到 unicode 编码不兼容 iso8859-1 编码，而且容易占用更多的空间：因为对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便于传输和存储。因此而产生了 utf 编码，utf 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符，不过，utf 编码是不定长编码，每一个字符的长度从1-6个字节不等。另外，utf 编码自带简单的校验功能。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节。注意，虽然说utf是为了使用更少的空间而使用的，但那只是相对于 unicode编码来说，如果已经知道是汉字，则使用 GB2312/GBK 无疑是最节省的。不过另一方面，值得说明的是，虽然 utf 编码对汉字使用3个字节，但即使对于汉字网页，utf 编码也会比 unicode 编码节省，因为网页中包含了很多的英文字符。</p>
<h1 id="getBytes-charset"><a href="#getBytes-charset" class="headerlink" title="getBytes(charset)"></a>getBytes(charset)</h1><pre><code>这是 java 字符串处理的一个标准函数，其作用是将字符串所表示的字符按照 charset 编码，并以字节方式表示。
注意字符串在 java 内存中总是按 unicode 编码存储的。
当Java程序从输入流、文件或字符文字量等途径获得字符串时，均会做字符编码的转换，例如InputStreamReader 的构造函数中就需要指定编码方式，而对于从文件和字符文字量中获得字符串时，均采用系统默认的编码方式对字符数据进行解码。
</code></pre><p>考虑下面一段代码： </p>
<pre><code>String str=”中”;
① byte[] bytes = str.getBytes();
② bytes = str.getBytes(“ISO-8859-1”);
</code></pre><p> 语句①：将一个只含有一个字符“中”的字符串文字量赋给 String 类的一个对象 str，字符文字量“中”是按照操作系统默认编码方式进行编码，在中文 windows 系统中通常是“GBK”，“中”在GBK编码中是0xD6D0，在将该字符赋给str时，Java会对该字符串进行编码转换，即将GBK编码方式的“中”转换成Unicode编码方式的“中”，Unicode编码方式“中”的编码是0x4E2D，所以str在程序运行期间在内存中的二进制表示成16进制就是0x4E2D。</p>
<p> 语句②：获得str字符串的二进制形式。getBytes(String encoding)方法需要指定编码方式，表示获得该字符串在何种编码方式中的二进制形式。此语句中没有设置参数，表示采用操作系统默认的编码方式，即此处获得的bytes是“中”在GBK编码中的二进制形式，即bytes[0]=0xD6, bytes[1]=0xD0。</p>
<p> 语句③：该语句与语句②的区别就是指定了编码方式，此处指定的是ISO-8859-1，即通常所说的Latin-1，该编码采用8bit对字符编码，所以编码空间中只有256个字符。该编码中只包含了基本的ASCII码和一些扩展的其它西欧字符，所以该字符集中不可能包含中文的“中”字，也就是说Java虚拟机无法在ISO-8859-1编码集中找到“中”字对应的编码，针对这种情况，就只返回一个问号(?,0x3f)字符，所以此时bytes.length只有1，且bytes[0]=0x3f。</p>
<h1 id="new-String-byte-bytes-String-encoding"><a href="#new-String-byte-bytes-String-encoding" class="headerlink" title="new String(byte[] bytes, String encoding)"></a>new String(byte[] bytes, String encoding)</h1><pre><code>getBytes()方法从字符串获得二进制的字节数组。如果要从二进制的字节数组获得字符串，则就需要使用new String(byte[] bytes, String encoding)方法，该方法按照encoding编码方法对字节数组bytes中的二进制数组进行解析，生成一个新的字符串对象。

  byte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};
  ① String str = new String(bytes);
  ② str = new String(bytes,”ISO-8859-1”);
</code></pre><p>语句①：定义一个字节数组。</p>
<p>语句②：将该字节数组中的二进制数据按照默认的编码方式（GBK）编码成字符串，我们知道GBK中0xD6 0xD0表示“中”，0x31表示字符“1”（GBK兼容ASCII，但不兼容ISO-8859-1除ASCII之外的部分），所以str得到的值是“中1”。</p>
<p>语句③：该句用ISO-8859-1编码方式对该字节数据进行编码，由于在ISO-8859-1编码方式中一个字节会被解析成一个字符，所以该字节数组会被解释成包含三个字符的字符串，但由于在ISO-8859-1编码方式中没有对应0xD6和0xD0的字符，所以前两个字符会产生两个问号，由于0x31在ISO-8859-1编码中对应字符“1”（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我相信看了，上面这么些背景知识，是不是以前，不清楚的东西，都有写明白了？多看几次，就更能理解了 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java的string的字符串编码&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java的string的字符串编码&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java的string的字符串编码&quot;&gt;&lt;/a&gt;今天要分享的内容
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中String的getBytes的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/26/java-getBytes/"/>
    <id>http://ghohankawk.github.io/2017/06/26/java-getBytes/</id>
    <published>2017-06-26T12:30:03.233Z</published>
    <updated>2017-06-26T12:37:59.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java的string方法getBytes"><a href="#今天要分享的内容是java的string方法getBytes" class="headerlink" title="今天要分享的内容是java的string方法getBytes"></a>今天要分享的内容是java的string方法getBytes</h1><h1 id="先看一个测试用例"><a href="#先看一个测试用例" class="headerlink" title="先看一个测试用例"></a>先看一个测试用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-26 20:28</div><div class="line"> */</div><div class="line">public class testGetBytes &#123;</div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * 1、Unicode是一种编码规范，是为解决全球字符通用编码而设计的，而rUTF-8,UTF-16等是这种规范的一种实现。</div><div class="line"></div><div class="line">     2、java内部采用Unicode编码规范，也就是支持多语言的，具体采用的UTF-16编码方式。</div><div class="line"></div><div class="line">     3、不管程序过程中用到了gbk,iso8859-1等格式，在存储与传递的过程中实际传递的都是Unicode编码的数据，要想接收到的值不出现乱码，就要保证传过去的时候用的是A编码，接收的时候也用A编码来转换接收。</div><div class="line"></div><div class="line">     4、如果双方的file.encoding确保都相同，那就省事了，都默认转了，但往往在不同项目交互时很多时候是不一致的，这个时候是必须要进行编码转换的。</div><div class="line"></div><div class="line">     5、无论如论转换，java程序的数据都是要先和Unicode做转换，这样也就是能处理多语言字符集的原因了。底层保持了一致，只要在传值和接值的时候也一致就肯定不会出现乱码了。</div><div class="line">     * */</div><div class="line"></div><div class="line">    public static void main(String[] args) throws UnsupportedEncodingException &#123;</div><div class="line"></div><div class="line"></div><div class="line">        String str = &quot;中文字符&quot;;</div><div class="line"></div><div class="line">        System.out.println(&quot;original string---&quot; + str);// 会正常输出原始串</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         * str.getBytes();  如果括号中不写charset，则采用的是Sytem.getProperty(&quot;file.encoding&quot;),即当前文件的编码方式，</div><div class="line">         *</div><div class="line">         * 很多人写的是系统的默认编码，通过代码测试并非如此，实际得到的是文件的编码方式*</div><div class="line">         *</div><div class="line">         * str.getBytes(&quot;charset&quot;);//指定charset，即将底层存储的Unicode码解析为charset编码格式的字节数组方式</div><div class="line">         *</div><div class="line">         * String new_str=new String(str.getBytes(&quot;utf-8&quot;),&quot;gbk&quot;));</div><div class="line">         *</div><div class="line">         * //将已经解析出来的字节数据转化为gbk编码格式的字符串，在内存中即为gbk格式的字节数组转为Unicode去交互传递</div><div class="line">         */</div><div class="line"></div><div class="line">        String new_str = new String(str.getBytes(&quot;utf-8&quot;), &quot;gbk&quot;);</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         * 此时的输出是乱码，在UTF-8的file.encoding下输出gbk格式的数据肯定是乱码,但是new_str的确是gbk编码式的</div><div class="line">         *</div><div class="line">         * 此时的乱码源于encoding不符，但gbk格式的new_str本身数据并没有问题,通过下面的转换也可以看得出来</div><div class="line">         */</div><div class="line"></div><div class="line">        System.out.println(&quot;new string----&quot; + new_str);</div><div class="line"></div><div class="line">        String final_str = new String(new_str.getBytes(&quot;gbk&quot;), &quot;utf-8&quot;);// 此处的含意与最上边的注释是一致的参数含意</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         *输出是正常的，此时将gbk编码格式的new_str字符串，用gbk这个charset去解析它，然后用utf-8再转码一次，</div><div class="line">         *</div><div class="line">         * 因为new_str确实是gbk格式的，才能经过utf-8编码得到正常的数据显示。</div><div class="line">         */</div><div class="line"></div><div class="line">        System.out.println(&quot;final string---&quot; + final_str);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常说明，要干什么，再加一个链接按钮 <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">xxx</a>. </p>
<h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><pre><code>1. 首先，你要明白，什么是uinicode，她和utf-8，以及utf-16，是什么关系
2. 其实，你要知道，java中是用了，utf-16
3. 再深入一点，就是，你也必须知道byte这个类型，就是所谓的字节数组了
4. 他和int的区别，怎么转换
5. byte数组里面存储的内容，怎么转换成对应的中文字符的？什么编码映射关系，转过去的？
6. 还有就是，你会经常看到0xff，这种，还有&amp;，按位于的这种操作，具体是什么含义
7. 大小端的问题，是什么意思？在网络里面如何区分？
</code></pre><p>这个地方，之前其实就一直看过，每次看完一遍，以为真的懂了，但是，过后，还是不知道，啥原理</p>
<p>这次，写过了，可能过一段时间又忘记了，但是，如果真正的理解了原理的话，就难忘记了</p>
<p>这个地方，不管前后端，都必须掌握</p>
<p>去看ruan大神的，那片，unicode文章，绝对有收获。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java的string方法getBytes&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java的string方法getBytes&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java的string方法getBytes&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Java中的ThreadLocal用法</title>
    <link href="http://ghohankawk.github.io/2017/06/20/java-threadlocal/"/>
    <id>http://ghohankawk.github.io/2017/06/20/java-threadlocal/</id>
    <published>2017-06-20T12:24:34.672Z</published>
    <updated>2017-06-20T12:43:18.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java中的ThreadLocal"><a href="#今天要分享的内容是java中的ThreadLocal" class="headerlink" title="今天要分享的内容是java中的ThreadLocal"></a>今天要分享的内容是java中的ThreadLocal</h1><p>并发编程中，一个重要的内容是数据共享。当你创建了实现Runnable接口的线程，然后开启使用相同Runnable实例的各种Thread对象，所有 的线程便共享定义在Runnable对象中的属性。也就是说，当你在一个线程中改变任意属性时，所有的线程都会因此受到影响，同时会看到第一个线程修改后的值。有时我们希望如此，比如：多个线程增大或减小同一个计数器变量；但是，有时我们希望确保每个线程，只能工作在它自己的线程实例的拷贝上，同时不会影 响其他线程的数据。</p>
<h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>  ThreadLocal是一个关于创建线程局部变量的类。</p>
<p>  通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。</p>
<ul>
<li>在当前线程中，任何一个点都可以访问到ThreadLocal的值。</li>
<li>该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。</li>
</ul>
<h1 id="如何创建ThreadLocal变量"><a href="#如何创建ThreadLocal变量" class="headerlink" title="如何创建ThreadLocal变量"></a>如何创建ThreadLocal变量</h1><pre><code>private ThreadLocal myThreadLocal = new ThreadLocal();
</code></pre><p>  通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。</p>
<h1 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h1><ol>
<li><p>创建，支持泛型</p>
<p>ThreadLocal<string> mStringThreadLocal = new ThreadLocal&lt;&gt;();</string></p>
</li>
<li><p>set方法</p>
<p>mStringThreadLocal.set(“hank”);</p>
</li>
<li><p>get方法</p>
<p>mStringThreadLocal.get();</p>
</li>
<li>initialValue()：返回当前线程赋予局部线程变量的初始值。<h1 id="具体用例"><a href="#具体用例" class="headerlink" title="具体用例"></a>具体用例</h1></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-20 20:33</div><div class="line"> */</div><div class="line">public class threadlocal &#123;</div><div class="line">    public static class MyRunnable implements Runnable &#123;</div><div class="line"></div><div class="line">        private ThreadLocal threadLocal = new ThreadLocal();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            threadLocal.set((int) (Math.random() * 100D));</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;  ==  &quot; + threadLocal.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyRunnable my = new MyRunnable();</div><div class="line">        Thread thread1 = new Thread(my);</div><div class="line">        Thread thread2 = new Thread(my);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="关于InheritableThreadLocal"><a href="#关于InheritableThreadLocal" class="headerlink" title="关于InheritableThreadLocal"></a>关于InheritableThreadLocal</h1><p>InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。</p>
<p>【注：所有子线程都会继承父线程保存的ThreadLocal值】</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>局部线程通常使用在这样的情况下，当你有一些对象并不满足线程安全，但是你想避免在使用synchronized关键字、块时产生的同步访问，那么，让每个线程拥有它自己的对象实例。</p>
<p>注意：局部变量是同步或局部线程的一个好的替代，它总是能够保证线程安全。唯一可能限制你这样做的是你的应用设计约束。</p>
<p>这个地方，是因为看到项目中有些地方都有用到，所以自己也研究一下</p>
<p>单从用法而言，还是比较简单的，没啥难度，要是研究原理的问题的话，可以考虑深入看一下源代码</p>
<p>还有就是</p>
<p>思考一下这种方式，变量对象，是放在堆里面吗？还是堆里面？</p>
<p>答案是堆。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java中的ThreadLocal&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java中的ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java中的ThreadLocal&quot;&gt;&lt;/a&gt;今天要分享的内容
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于requirejs的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/19/requirejs/"/>
    <id>http://ghohankawk.github.io/2017/06/19/requirejs/</id>
    <published>2017-06-19T11:37:48.154Z</published>
    <updated>2017-06-19T12:25:11.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是requirejs"><a href="#今天要分享的内容是requirejs" class="headerlink" title="今天要分享的内容是requirejs"></a>今天要分享的内容是requirejs</h1><h1 id="AMD-简介"><a href="#AMD-简介" class="headerlink" title="AMD 简介"></a>AMD 简介</h1><p>  前端开发在近一两年发展的非常快，JavaScript 作为主流的开发语言得到了前所未有的热捧。大量的前端框架出现了，这些框架都在尝试着解决一些前端开发中的共性问题，但是实现又不尽相同。在这个背景下，CommonJS 社区诞生了，为了让前端框架发展的更加成熟，CommonJS 鼓励开发人员一起在社区里为一些完成特定功能的框架制定规范。AMD（Asynchronous Module Definition）就是其中的一个规范。</p>
<h1 id="RequireJS-简介"><a href="#RequireJS-简介" class="headerlink" title="RequireJS 简介"></a>RequireJS 简介</h1><p>  RequireJS 是一个非常小巧的 JavaScript 模块载入框架，是 AMD 规范最好的实现者之一。最新版本的 RequireJS 压缩后只有 14K，堪称非常轻量。它还同时可以和其他的框架协同工作，使用 RequireJS 必将使您的前端代码质量得以提升。 目前最新版本的 RequireJS 1.0.8 在 IE 6+、Firefox 2+、Safari 3.2+、Chrome 3+、Opera 10+ 上都工作的很好。</p>
<h1 id="案例一：-加载-JavaScript-文件"><a href="#案例一：-加载-JavaScript-文件" class="headerlink" title="案例一： 加载 JavaScript 文件"></a>案例一： 加载 JavaScript 文件</h1><pre><code>&lt;script src=&quot;./js/require.js&quot;&gt;&lt;/script&gt; 
     &lt;script&gt; 
    require([&quot;./js/a.js&quot;, &quot;./js/b.js&quot;], function() { 
             myFunctionA(); 
             myFunctionB(); 
        }); 
     &lt;/script&gt;

     这种方式，用来加载以前的js文件，就像本地引用一样，但是没有解决全局变量的问题
</code></pre><h1 id="案例二：-页面加载后执行-JavaScript"><a href="#案例二：-页面加载后执行-JavaScript" class="headerlink" title="案例二： 页面加载后执行 JavaScript"></a>案例二： 页面加载后执行 JavaScript</h1><p>   <script src="./js/require.js"></script><br>       <script><br>      require([“domReady!”, “./js/a.js”, “./js/b.js”], function() {<br>               myFunctionA();<br>               myFunctionB();<br>          });<br>       </script><br>       这个例子domReady!，解决了，有需要保证页面加载以后执行脚本时，RequireJS 提供了一个独立的 domReady 模块，需要去 RequireJS 官方网站下载这个模块</p>
<h1 id="AMD模块的写法"><a href="#AMD模块的写法" class="headerlink" title="AMD模块的写法"></a>AMD模块的写法</h1><p>  require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p>
<p>  具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p>
<p>  假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：</p>
<pre><code>// math.js
define(function (){
　　　　var add = function (x,y){
　　　　　　return x+y;
　　　　};
　　　　return {
　　　　　　add: add
　　　　};
});
</code></pre><p>  加载方法如下：</p>
<pre><code>// main.js
　　require([&apos;math&apos;], function (math){
　　　　alert(math.add(1,1));
　　});
</code></pre><h1 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h1><p>  理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p>
<p>  回答是可以的。</p>
<p>  这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>  举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<pre><code>require.config({
　　　　shim: {

　　　　　　&apos;underscore&apos;:{
　　　　　　　　exports: &apos;_&apos;
　　　　　　},
　　　　　　&apos;backbone&apos;: {
　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],
　　　　　　　　exports: &apos;Backbone&apos;
　　　　　　}
　　　　}
});
</code></pre><p>  require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</p>
<p>  比如，jQuery的插件可以这样定义：</p>
<pre><code>shim: {
　　　　&apos;jquery.scroll&apos;: {
　　　　　　deps: [&apos;jquery&apos;],
　　　　　　exports: &apos;jQuery.fn.scroll&apos;
　　　　}
}
</code></pre><h1 id="require-js插件"><a href="#require-js插件" class="headerlink" title="require.js插件"></a>require.js插件</h1><p>  require.js还提供一系列插件，实现一些特定的功能。</p>
<p>  domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<p>  require([‘domready!’], function (doc){<br>  　　　　// called once the DOM is ready<br>  　　});<br>  text和image插件，则是允许require.js加载文本和图片文件。</p>
<p>  define([<br>  　　　　‘text!review.txt’,<br>  　　　　‘image!cat.jpg’<br>  　　　　],</p>
<p>  　　　　function(review,cat){<br>  　　　　　　console.log(review);<br>  　　　　　　document.body.appendChild(cat);<br>  　　　　}<br>  　);<br>  类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>
<h1 id="在html中引入requirejs"><a href="#在html中引入requirejs" class="headerlink" title="在html中引入requirejs"></a>在html中引入requirejs</h1><p>  在HTML中，添加这样的 &lt; script&gt; 标签：</p>
<pre><code>&lt;script src=&quot;/path/to/require.js&quot; data-main=&quot;/path/to/app/config.js&quot;&gt;&lt;/script&gt;
</code></pre><p>  通常使用requirejs的话，我们只需要导入requirejs即可，不需要显式导入其它的js库，因为这个工作会交给requirejs来做。</p>
<p>  属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块。</p>
<h1 id="依赖一个不使用requirejs方式的库"><a href="#依赖一个不使用requirejs方式的库" class="headerlink" title="依赖一个不使用requirejs方式的库"></a>依赖一个不使用requirejs方式的库</h1><p>  前面的代码是理想的情况，即依赖的js文件，里面用了 define(…) 这样的方式来组织代码的。如果没用这种方式，会出现什么情况？</p>
<p>  比如这个 hello.js :</p>
<pre><code>function hello() {
alert(&quot;hello, world~&quot;);
}
</code></pre><p>  它就按最普通的方式定义了一个函数，我们能在requirejs里使用它吗？</p>
<p>  先看下面不能正确工作的代码：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  hello: &apos;hello&apos;
}
});

requirejs([&apos;hello&apos;], function(hello) {
hello();
});
</code></pre><p>  这段代码会报错，提示：</p>
<p>  Uncaught TypeError: undefined is not a function<br>  原因是最后调用 hello() 的时候，这个 hello 是个 undefined . 这说明，虽然我们依赖了一个js库（它会被载入），但requirejs无法从中拿到代表它的对象注入进来供我们使用。</p>
<p>  在这种情况下，我们要使用 shim ，将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  hello: &apos;hello&apos;
},
shim: {
  hello: { exports: &apos;hello&apos; }
}
});

requirejs([&apos;hello&apos;], function(hello) {
hello();
});
</code></pre><p>  再运行就正常了。</p>
<p>  上面代码 exports: ‘hello’ 中的 hello ，是我们在 hello.js 中定义的 hello 函数。当我们使用 function hello() {} 的方式定义一个函数的时候，它就是全局可用的。如果我们选择了把它 export 给requirejs，那当我们的代码依赖于 hello 模块的时候，就可以拿到这个 hello 函数的引用了。</p>
<p>  所以： exports 可以把某个非requirejs方式的代码中的某一个<strong>全局变量</strong>暴露出去，当作该模块以引用。</p>
<h1 id="无主的与有主的模块"><a href="#无主的与有主的模块" class="headerlink" title="无主的与有主的模块"></a>无主的与有主的模块</h1><p>  我遇到了一个折腾我不少时间的问题：为什么我只能使用 jquery 来依赖jquery, 而不能用其它的名字？</p>
<p>  比如下面这段代码：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  myjquery: &apos;lib/jquery/jquery&apos;
}
});

requirejs([&apos;myjquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  它会提示我：</p>
<p>  jq is undefined<br>  但我仅仅改个名字：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  jquery: &apos;lib/jquery/jquery&apos;
}
});

requirejs([&apos;jquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  就一切正常了，能打印出 jq 相应的对象了。</p>
<p>  为什么？我始终没搞清楚问题在哪儿。</p>
<h1 id="有主的模块"><a href="#有主的模块" class="headerlink" title="有主的模块"></a>有主的模块</h1><p>  经常研究，发现原来在jquery中已经定义了：</p>
<pre><code>define(&apos;jquery&apos;, [], function() { ... });
</code></pre><p>  它这里的 define 跟我们前面看到的 app.js 不同，在于它多了第一个参数 ‘jquery’ ，表示给当前这个模块起了名字 jquery ，它已经是有主的了，只能属于 jquery .</p>
<p>  所以当我们使用另一个名字：</p>
<p>  myjquery: ‘lib/jquery/jquery’<br>  去引用这个库的时候，它会发现，在 jquery.js 里声明的模块名 jquery 与我自己使用的模块名 myjquery 冲突，便不会把它赋给 myjquery ，所以 myjquery 的值是 undefined 。</p>
<p>  所以我们在使用一个第三方的时候，一定要注意它是否声明了一个确定的模块名。</p>
<h1 id="无主的模块"><a href="#无主的模块" class="headerlink" title="无主的模块"></a>无主的模块</h1><p>  如果我们不指明模块名，就像这样：</p>
<pre><code>define([...], function() {
...
});
</code></pre><p>  那么它就是无主的模块。我们可以在 requirejs.config 里，使用任意一个模块名来引用它。这样的话，就让我们的命名非常自由，大部分的模块就是无主的。</p>
<h1 id="为什么有的有主，有的无主"><a href="#为什么有的有主，有的无主" class="headerlink" title="为什么有的有主，有的无主"></a>为什么有的有主，有的无主</h1><p>  可以看到，无主的模块使用起来非常自由，为什么某些库（jquery, underscore）要把自己声明为有主的呢？</p>
<p>  按某些说法，这么做是出于性能的考虑。因为像 jquery , underscore 这样的基础库，经常被其它的库依赖。如果声明为无主的，那么其它的库很可能起不同的模块名，这样当我们使用它们时，就可能会多次载入jquery/underscore。</p>
<p>  而把它们声明为有主的，那么所有的模块只能使用同一个名字引用它们，这样系统就只会载入它们一次。</p>
<h1 id="强行该名称的方法"><a href="#强行该名称的方法" class="headerlink" title="强行该名称的方法"></a>强行该名称的方法</h1><p>  对于有主的模块，我们还有一种方式可以挖墙角：不把它们当作满足requirejs规范的模块，而当作普通js库，然后在 shim 中导出它们定义的全局变量。</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  myjquery: &apos;lib/jquery/jquery&apos;
},
shim: {
  myjquery: { exports: &apos;jQuery&apos; }
}
});

requirejs([&apos;myjquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  这样通过暴露 jQuery 这个全局变量给 myjquery ，我们就能正常的使用它了。</p>
<p>  不过我们完全没有必要这么挖墙角，因为对于我们来说，似乎没有任何好处。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 关于这块部分，我是看项目里有用到这个前端的组件，而自己没有实际开发过，因此<br> 对这个部分，理解不深刻，也就是现在能看懂的阶段了，主要是参考了好几篇关于<br> requirejs的文章总结的</p>
<p> 还有就是，这个部分其实一直就有了解，因此也不是完全不懂的去学</p>
<p> 反正是先入手学一下是很有必要的，</p>
<p> 哎，最近发现那个requirejs的中文网，不知道怎么滴就访问不了，好像只能去看英文文档了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是requirejs&quot;&gt;&lt;a href=&quot;#今天要分享的内容是requirejs&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是requirejs&quot;&gt;&lt;/a&gt;今天要分享的内容是requirejs&lt;/h1&gt;&lt;h1 id=&quot;A
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gitbook的自己定制的写书模板</title>
    <link href="http://ghohankawk.github.io/2017/06/15/gitbook/"/>
    <id>http://ghohankawk.github.io/2017/06/15/gitbook/</id>
    <published>2017-06-15T12:33:25.838Z</published>
    <updated>2017-06-15T12:54:51.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是gitbook的使用"><a href="#今天要分享的内容是gitbook的使用" class="headerlink" title="今天要分享的内容是gitbook的使用"></a>今天要分享的内容是gitbook的使用</h1><p>今天本来在看js的commonJs，amd，cmd，umd这些模块内容</p>
<p>看着，看着，突然看到了gitbook的内容</p>
<p>发现很多人，都用这个，写一个类似，api或者一些列的书籍用</p>
<p>所以下午花时间，开始弄这个</p>
<p>开始也是啥不懂，慢慢总算摸清门路了</p>
<p>其实还是不会用</p>
<p>本来去掉了让人讨厌的，最下面的那个published with gitbook那个连接</p>
<p>结果和github同步了一次代码，全部丢失了</p>
<p>后来实在，是不想弄了，就留着吧，懒得弄啦</p>
<p>最后的解决方案就是</p>
<p>用gitbook的那个编辑器，直接写文章将来</p>
<p>或者像这个博客一样，全部用markdown的语法，自己写</p>
<p>显得的高大上</p>
<p>去我的github上面，可以找一下，gitbook的写作模板</p>
<p>顺便把首页的测试页链接，改为自己的书籍，将来补充一下，争取写成一个书单，或者笔记之类的东西吧</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63304470_cc053618b7d92f9794e300a7d7e3f1e2" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63304470" target="_blank">美少女で 閲覧数を取れなきゃ 幼女を出せ</a> by <a href="https://www.pixiv.net/member.php?id=1147470" target="_blank">ぎぇうす</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是gitbook的使用&quot;&gt;&lt;a href=&quot;#今天要分享的内容是gitbook的使用&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是gitbook的使用&quot;&gt;&lt;/a&gt;今天要分享的内容是gitbook的使用&lt;/h1&gt;&lt;p&gt;今天
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感四（完结篇）</title>
    <link href="http://ghohankawk.github.io/2017/06/14/tomdashu4/"/>
    <id>http://ghohankawk.github.io/2017/06/14/tomdashu4/</id>
    <published>2017-06-14T11:47:30.120Z</published>
    <updated>2017-06-14T12:31:29.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇</h1><p>花了三天的时间，终于把大叔的博客，JavaScript系列看了一遍</p>
<p>收获颇丰啊，不愧是经典，一下子很多零散的东西就串联了起来</p>
<p>先简单说一下背景吧<br>大概是13年左右的时候，就有人推荐大叔的博客，那时第一个原因是水平不够，第二个没时间，总之就是没看过，但是听说过了</p>
<p>后来，陆续又自己完完整整的学了一遍JavaScript，就是大叔最后一篇文章里面推荐的，初级书籍，那边三圣经之一，看完了总觉得学会了，其实<br>看完就忘记了，不过有个大概印象了</p>
<p>再后来，毕业工作了，去做java后端了，因为有时候需要写简单的前端页面，就开始到了真正的实际应用，开始写的过程，才慢慢对一些概念，有了自己的认识<br>但是，还是停留在最初级的阶段，写个function函数，那种，变量都是全局的，简单的子自行，this分不清的水平</p>
<p>慢慢的，有个机会让我去定制前端组件，那个时候，自己开始模仿的写一些组件，但是都是初级的，不过正是因为这个原因，才有了一次写js的锻炼，有了这种训练<br>以前很多的概念开始，慢慢用上了</p>
<p>大概自认为，初级JavaScript之上，又达不到中级的水平吧，</p>
<p>大叔的系列，看完一遍，对我来说的收获</p>
<ol>
<li>弄清了function函数这个概念，实在太多了，比如，命名，申明，函数语句，匿名，自执行，等等</li>
<li>弄清了括号的用法和含义，（），这个东西，看着简单，不懂的话，还是不理解</li>
<li>弄清了闭包这个概念，这个概念每次问，都知道有那么回事，但是又具体说不上来，那种一直认为懂，其实还是不懂的概念，这篇文章终于弄清楚了</li>
<li>弄清了prototype这个玩意，就是所谓的原型的概念，只有函数才有</li>
<li>弄清了对象创建的方法，比如，function的，还有new，含有构造函数，等等</li>
<li>弄清了执行上下文，也就是作用域的概念，这个东西，没有比大叔写的更清楚的了</li>
<li>还有就是，有了上面的概念之后的，this指针，老生常谈了，网上的其他文章，只能写一些为啥，例子分析之类的，开始写不错，大叔这种原理分析，<br>各个场景的用法，这次就不怕分不清this了</li>
<li>当然了，还有，call，apply这些的用法</li>
<li>当然了，又温故知新了一遍设计模式，主要是理解了代码为啥有时候那么写的思路</li>
<li>有了上面总总的概念之后，看起完整的代码，才不会卡主分析里面任何一个细节<br>因为基础知识已经具备了，看起来，才能理解了</li>
</ol>
<p>说了这么多，其实呢，这个东西，不实践还是没有用的，如果没有当初自己一个人开始写js的那段实践，我估计也不会有今天<br>看博客那么大的收获</p>
<p>不敢说，都看懂了大叔所写，但是我心中的疑惑对js的，那些模糊的概念突然清晰了起来</p>
<p>书不是读一遍，就完事的，等以后有时间，再返回头看看，可能有更多的收获</p>
<p>上图</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63061360_9db8a1ab6d0b20a09558ed43369658e4" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63061360" target="_blank">まとめ</a> by <a href="https://www.pixiv.net/member.php?id=15385092" target="_blank">郁</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感完结篇&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaS
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感三（设计模式篇）</title>
    <link href="http://ghohankawk.github.io/2017/06/13/tomdashu3/"/>
    <id>http://ghohankawk.github.io/2017/06/13/tomdashu3/</id>
    <published>2017-06-13T12:02:55.051Z</published>
    <updated>2017-06-14T11:43:47.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感3"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感3" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感3"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感3</h1><p>挑选大叔里面，个人自己喜欢的设计模式实现</p>
<h1 id="第二十五部分，设计模式之单例模式"><a href="#第二十五部分，设计模式之单例模式" class="headerlink" title="第二十五部分，设计模式之单例模式"></a>第二十五部分，设计模式之单例模式</h1><p>在传统开发工程师眼里，单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 缓存的实例</div><div class="line">    var instance = this;</div><div class="line"></div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    // 重写构造函数</div><div class="line">    Universe = function () &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">uni.bang = &quot;123&quot;;</div><div class="line">console.log(uni === uni2); // true</div><div class="line">console.log(uni2.bang); // 123</div></pre></td></tr></table></figure>
<p>这个设计模式，简单明了，通过this进行缓存，剩下了去判断不存在的麻烦</p>
<h1 id="第二十六部分，设计模式之构造函数模式"><a href="#第二十六部分，设计模式之构造函数模式" class="headerlink" title="第二十六部分，设计模式之构造函数模式"></a>第二十六部分，设计模式之构造函数模式</h1><p>构造函数用于创建特定类型的对象——不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype</div><div class="line">主要是用来避免重写定义原型prototype对象</div><div class="line">*/</div><div class="line">Car.prototype.output= function () &#123;</div><div class="line">    return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var tom = new Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">var dudu = new Car(&quot;Dudu&quot;, 2010, 5000);</div><div class="line"></div><div class="line">console.log(tom.output());</div><div class="line">console.log(dudu.output());</div></pre></td></tr></table></figure></p>
<h1 id="第二十七部分，设计模式之建造者模式"><a href="#第二十七部分，设计模式之建造者模式" class="headerlink" title="第二十七部分，设计模式之建造者模式"></a>第二十七部分，设计模式之建造者模式</h1><p>建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">    // 使用ID来请求数据，然后返回数据.</div><div class="line">    asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function (resp) &#123;</div><div class="line">        // callback调用 response</div><div class="line">        callback(resp.responseText);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var el = document.querySelector(&apos;#test&apos;);</div><div class="line">el.addEventListener(&apos;click&apos;, getBeerByIdBridge, false);</div><div class="line"></div><div class="line">function getBeerByIdBridge(e) &#123;</div><div class="line">    getBeerById(this.id, function (beer) &#123;</div><div class="line">        console.log(&apos;Requested Beer: &apos; + beer);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。<br>也就是说，上面的函数中，getBeerById函数是稳定的，写了一个构建过程，而具体的构建细节由另外一个回调函数决定</p>
<p>其实，我觉得，这个部分，不属于java里面的建造者模式，更是一种模板模式，可能个人理解不同吧，反正大叔的意思，就是这种样子</p>
<h1 id="第二十八部分，设计模式之工厂模式"><a href="#第二十八部分，设计模式之工厂模式" class="headerlink" title="第二十八部分，设计模式之工厂模式"></a>第二十八部分，设计模式之工厂模式</h1><pre><code>什么时候使用工厂模式

以下几种情景下工厂模式特别有用：

对象的构建十分复杂
需要依赖具体环境创建不同实例
处理大量具有相同属性的小对象
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var productManager = &#123;&#125;;</div><div class="line"></div><div class="line">productManager.createProductA = function () &#123;</div><div class="line">    console.log(&apos;ProductA&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">productManager.createProductB = function () &#123;</div><div class="line">    console.log(&apos;ProductB&apos;);</div><div class="line">&#125;</div><div class="line">        </div><div class="line">productManager.factory = function (typeType) &#123;</div><div class="line">    return new productManager[typeType];</div><div class="line">&#125;</div><div class="line"></div><div class="line">productManager.factory(&quot;createProductA&quot;);</div></pre></td></tr></table></figure>
<p>一句话，就是根据不同的类型，调用不同的子类，进行实例化一个对象</p>
<h1 id="第二十九部分，设计模式之装饰者模式"><a href="#第二十九部分，设计模式之装饰者模式" class="headerlink" title="第二十九部分，设计模式之装饰者模式"></a>第二十九部分，设计模式之装饰者模式</h1><p>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var tree = &#123;&#125;;</div><div class="line">tree.decorate = function () &#123;</div><div class="line">    console.log(&apos;Make sure the tree won\&apos;t fall&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.getDecorator = function (deco) &#123;</div><div class="line">    tree[deco].prototype = this;</div><div class="line">    return new tree[deco];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.RedBalls = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.RedBalls.prototype.decorate(); // 第7步：先执行原型（这时候是Angel了）的decorate方法</div><div class="line">        console.log(&apos;Put on some red balls&apos;); // 第8步 再输出 red</div><div class="line">        // 将这2步作为RedBalls的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.BlueBalls = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.BlueBalls.prototype.decorate(); // 第1步：先执行原型的decorate方法，也就是tree.decorate()</div><div class="line">        console.log(&apos;Add blue balls&apos;); // 第2步 再输出blue</div><div class="line">        // 将这2步作为BlueBalls的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree.Angel = function () &#123;</div><div class="line">    this.decorate = function () &#123;</div><div class="line">        this.Angel.prototype.decorate(); // 第4步：先执行原型（这时候是BlueBalls了）的decorate方法</div><div class="line">        console.log(&apos;An angel on the top&apos;); // 第5步 再输出angel</div><div class="line">        // 将这2步作为Angel的decorate方法</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">tree = tree.getDecorator(&apos;BlueBalls&apos;); // 第3步：将BlueBalls对象赋给tree，这时候父原型里的getDecorator依然可用</div><div class="line">tree = tree.getDecorator(&apos;Angel&apos;); // 第6步：将Angel对象赋给tree，这时候父原型的父原型里的getDecorator依然可用</div><div class="line">tree = tree.getDecorator(&apos;RedBalls&apos;); // 第9步：将RedBalls对象赋给tree</div><div class="line"></div><div class="line">tree.decorate(); // 第10步：执行RedBalls对象的decorate方法</div></pre></td></tr></table></figure>
<p>这段代码，主要是在于，<br>        tree.getDecorator 这段函数设计精妙<br>        他让tree接受一个新的函数，而每次都用这个新函数去替代之前的函数，并且同时让原型指向前一个，实现了一个<br>        继承关系，比如A-》B-》C，最开始tree是A，然后，放入一个，就变成B，之后为C</p>
<h1 id="第三十部分，设计模式之外观模式"><a href="#第三十部分，设计模式之外观模式" class="headerlink" title="第三十部分，设计模式之外观模式"></a>第三十部分，设计模式之外观模式</h1><p>外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。</p>
<p>外观模式经常被用于JavaScript类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。</p>
<p>外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点 外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var addMyEvent = function (el, ev, fn) &#123;</div><div class="line">    if (el.addEventListener) &#123;</div><div class="line">        el.addEventListener(ev, fn, false);</div><div class="line">    &#125; else if (el.attachEvent) &#123;</div><div class="line">        el.attachEvent(&apos;on&apos; + ev, fn);</div><div class="line">    &#125; else &#123;</div><div class="line">        el[&apos;on&apos; + ev] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;; </div><div class="line">再来一个简单的例子，说白了就是用一个接口封装其它的接口：</div><div class="line">var mobileEvent = &#123;</div><div class="line">    // ...</div><div class="line">    stop: function (e) &#123;</div><div class="line">        e.preventDefault();</div><div class="line">        e.stopPropagation();</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="第三十一部分，设计模式之代理模式"><a href="#第三十一部分，设计模式之代理模式" class="headerlink" title="第三十一部分，设计模式之代理模式"></a>第三十一部分，设计模式之代理模式</h1><p>代理，顾名思义就是帮助别人做事<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 先声明美女对象</div><div class="line">var girl = function (name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 这是dudu</div><div class="line">var dudu = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        alert(&quot;Hi &quot; + girl.name + &quot;, dudu送你一个礼物：&quot; + gift);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 大叔是代理</div><div class="line">var proxyTom = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        (new dudu(girl)).sendGift(gift); // 替dudu送花咯</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">说的简单一点，就是代理新类，必须包括被代理的对象，也就是可以主动new</div></pre></td></tr></table></figure></p>
<h1 id="第三十二部分，设计模式之观察者模式"><a href="#第三十二部分，设计模式之观察者模式" class="headerlink" title="第三十二部分，设计模式之观察者模式"></a>第三十二部分，设计模式之观察者模式</h1><p>观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">jQuery版本</div><div class="line"></div><div class="line">根据jQuery1.7版新增的on/off功能，我们也可以定义jQuery版的观察者：</div><div class="line"></div><div class="line">(function ($) &#123;</div><div class="line"></div><div class="line">    var o = $(&#123;&#125;);</div><div class="line"></div><div class="line">    $.subscribe = function () &#123;</div><div class="line">        o.on.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.unsubscribe = function () &#123;</div><div class="line">        o.off.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.publish = function () &#123;</div><div class="line">        o.trigger.apply(o, arguments);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125; (jQuery));</div></pre></td></tr></table></figure>
<h1 id="第三十三部分，设计模式之策略模式"><a href="#第三十三部分，设计模式之策略模式" class="headerlink" title="第三十三部分，设计模式之策略模式"></a>第三十三部分，设计模式之策略模式</h1><p>策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">正常的模式，缺点就是，下次继续增加case进行判断</div><div class="line">        validator = &#123;</div><div class="line">            validate: function (value, type) &#123;</div><div class="line">                switch (type) &#123;</div><div class="line">                    case &apos;isNonEmpty &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // NonEmpty 验证结果</div><div class="line">                        &#125;</div><div class="line">                    case &apos;isNumber &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // Number 验证结果</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    case &apos;isAlphaNum &apos;:</div><div class="line">                        &#123;</div><div class="line">                            return true; // AlphaNum 验证结果</div><div class="line">                        &#125;</div><div class="line">                    default:</div><div class="line">                        &#123;</div><div class="line">                            return true;</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        //  测试</div><div class="line">        alert(validator.validate(&quot;123&quot;, &quot;isNonEmpty&quot;));</div><div class="line"></div><div class="line">策略模式</div><div class="line"></div><div class="line">var validator = &#123;</div><div class="line"></div><div class="line">    // 所有可以的验证规则处理类存放的地方，后面会单独定义</div><div class="line">    types: &#123;&#125;,</div><div class="line"></div><div class="line">    // 验证类型所对应的错误消息</div><div class="line">    messages: [],</div><div class="line"></div><div class="line">    // 当然需要使用的验证类型</div><div class="line">    config: &#123;&#125;,</div><div class="line"></div><div class="line">    // 暴露的公开验证方法</div><div class="line">    // 传入的参数是 key =&gt; value对</div><div class="line">    validate: function (data) &#123;</div><div class="line"></div><div class="line">        var i, msg, type, checker, result_ok;</div><div class="line"></div><div class="line">        // 清空所有的错误信息</div><div class="line">        this.messages = [];</div><div class="line"></div><div class="line">        for (i in data) &#123;</div><div class="line">            if (data.hasOwnProperty(i)) &#123;</div><div class="line"></div><div class="line">                type = this.config[i];  // 根据key查询是否有存在的验证规则</div><div class="line">                checker = this.types[type]; // 获取验证规则的验证类</div><div class="line"></div><div class="line">                if (!type) &#123;</div><div class="line">                    continue; // 如果验证规则不存在，则不处理</div><div class="line">                &#125;</div><div class="line">                if (!checker) &#123; // 如果验证规则类不存在，抛出异常</div><div class="line">                    throw &#123;</div><div class="line">                        name: &quot;ValidationError&quot;,</div><div class="line">                        message: &quot;No handler to validate type &quot; + type</div><div class="line">                    &#125;;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                result_ok = checker.validate(data[i]); // 使用查到到的单个验证类进行验证</div><div class="line">                if (!result_ok) &#123;</div><div class="line">                    msg = &quot;Invalid value for *&quot; + i + &quot;*, &quot; + checker.instructions;</div><div class="line">                    this.messages.push(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return this.hasErrors();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // helper</div><div class="line">    hasErrors: function () &#123;</div><div class="line">        return this.messages.length !== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">然后剩下的工作，就是定义types里存放的各种验证类了，我们这里只举几个例子：</div><div class="line"></div><div class="line">// 验证给定的值是否不为空</div><div class="line">validator.types.isNonEmpty = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return value !== &quot;&quot;;</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值不能为空&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否是数字</div><div class="line">validator.types.isNumber = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !isNaN(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能是合法的数字，例如：1, 3.14 or 2010&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否只是字母或数字</div><div class="line">validator.types.isAlphaNum = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !/[^a-z0-9]/i.test(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能保护字母和数字，不能包含特殊字符&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">以配置替代之前的写死的那种方式，可以理解为开闭原则，不修改之前的代码</div></pre></td></tr></table></figure>
<h1 id="第三十四部分，设计模式之命令模式"><a href="#第三十四部分，设计模式之命令模式" class="headerlink" title="第三十四部分，设计模式之命令模式"></a>第三十四部分，设计模式之命令模式</h1><p>命令模式(Command)的定义是：用于将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理。此外，可以通过调用实现具体函数的对象来解耦命令对象与接收对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$(function () &#123;</div><div class="line"></div><div class="line">    var CarManager = &#123;</div><div class="line"></div><div class="line">        // 请求信息</div><div class="line">        requestInfo: function (model, id) &#123;</div><div class="line">            return &apos;The information for &apos; + model +</div><div class="line">        &apos; with ID &apos; + id + &apos; is foobar&apos;;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        // 购买汽车</div><div class="line">        buyVehicle: function (model, id) &#123;</div><div class="line">            return &apos;You have successfully purchased Item &apos;</div><div class="line">        + id + &apos;, a &apos; + model;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        // 组织view</div><div class="line">        arrangeViewing: function (model, id) &#123;</div><div class="line">            return &apos;You have successfully booked a viewing of &apos;</div><div class="line">        + model + &apos; ( &apos; + id + &apos; ) &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">CarManager.execute = function (command) &#123;</div><div class="line">    return CarManager[command.request](command.model, command.carID);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CarManager.execute(&#123; request: &quot;arrangeViewing&quot;, model: &apos;Ferrari&apos;, carID: &apos;145523&apos; &#125;);</div><div class="line"></div><div class="line">之前可能没明白命令模式，现在看这个例子，就很简单了，</div><div class="line">就是，我不具体的调用函数，而是改成一个命令，通过一个弄命令函数，传入不同的指令，实现方法的调用</div><div class="line">大叔的意思是说，不推荐使用，可以直接调用，就不用这么麻烦，前天是系统不复杂的时候</div></pre></td></tr></table></figure>
<h1 id="第三十五部分，设计模式之迭代器模式"><a href="#第三十五部分，设计模式之迭代器模式" class="headerlink" title="第三十五部分，设计模式之迭代器模式"></a>第三十五部分，设计模式之迭代器模式</h1><p>迭代器模式(Iterator)：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。</p>
<p>迭代器的几个特点是：</p>
<p>访问一个聚合对象的内容而无需暴露它的内部表示。<br>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。<br>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jQuery里一个非常有名的迭代器就是$.each方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：</div><div class="line"></div><div class="line">$.each([&apos;dudu&apos;, &apos;dudu&apos;, &apos;酸奶小妹&apos;, &apos;那个MM&apos;], function (index, value) &#123;</div><div class="line">    console.log(index + &apos;: &apos; + value);</div><div class="line">&#125;);</div><div class="line">//或者</div><div class="line">$(&apos;li&apos;).each(function (index) &#123;</div><div class="line">    console.log(index + &apos;: &apos; + $(this).text());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="第三十六部分，设计模式之中介者模式"><a href="#第三十六部分，设计模式之中介者模式" class="headerlink" title="第三十六部分，设计模式之中介者模式"></a>第三十六部分，设计模式之中介者模式</h1><p>软件开发中，中介者是一个行为设计模式，通过提供一个统一的接口让系统的不同部分进行通信。一般，如果系统有很多子模块需要直接沟通，都要创建一个中央控制点让其各模块通过该中央控制点进行交互。中介者模式可以让这些子模块不需要直接沟通，而达到进行解耦的目的。</p>
<p>打个比方，平时常见的机场交通控制系统，塔台就是中介者，它控制着飞机（子模块）的起飞和降落，因为所有的沟通都是从飞机向塔台汇报来完成的，而不是飞机之前相互沟通。中央控制系统就是该系统的关键，也就是软件设计中扮演的中介者角色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 如下代码是伪代码，请不要过分在意代码</div><div class="line">// 这里app命名空间就相当于扮演中介者的角色</div><div class="line">var app = app || &#123;&#125;;</div><div class="line"> </div><div class="line">// 通过app中介者来进行Ajax请求</div><div class="line">app.sendRequest = function ( options ) &#123;</div><div class="line">    return $.ajax($.extend(&#123;&#125;, options);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 请求URL以后，展示View</div><div class="line">app.populateView = function( url, view )&#123;</div><div class="line">  $.when(app.sendRequest(&#123;url: url, method: &apos;GET&apos;&#125;)</div><div class="line">     .then(function()&#123;</div><div class="line">         //显示内容</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 清空内容</div><div class="line">app.resetView = function( view )&#123;</div><div class="line">   view.html(&apos;&apos;);</div><div class="line">&#125;</div><div class="line">之前没有分清，中介和代理，其实区别是明显，中介，里面参与的是多个人，他共同维护这些人，而且还都彼此认识switch </div><div class="line">而代理，只是简单的处理一个人而已，参与者一</div></pre></td></tr></table></figure>
<p>另外，由于中介者模式把交互复杂性变成了中介者本身的复杂性，所以说中介者对象会比其它任何对象都复杂。</p>
<h1 id="第三十七部分，设计模式之享元模式"><a href="#第三十七部分，设计模式之享元模式" class="headerlink" title="第三十七部分，设计模式之享元模式"></a>第三十七部分，设计模式之享元模式</h1><p>Flyweight中有两个重要概念–内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，而外部信息可以在通过外部删除或者保存。</p>
<p>说白点,就是先捏一个的原始模型，然后随着不同场合和环境,再产生各具特征的具体模型，很显然,在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">var Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability )&#123;</div><div class="line">   this.id = id;</div><div class="line">   this.title = title;</div><div class="line">   this.author = author;</div><div class="line">   this.genre = genre;</div><div class="line">   this.pageCount = pageCount;</div><div class="line">   this.publisherID = publisherID;</div><div class="line">   this.ISBN = ISBN;</div><div class="line">   this.checkoutDate = checkoutDate;</div><div class="line">   this.checkoutMember = checkoutMember;</div><div class="line">   this.dueReturnDate = dueReturnDate;</div><div class="line">   this.availability = availability;</div><div class="line">&#125;;</div><div class="line">Book.prototype = &#123;</div><div class="line">   getTitle:function()&#123;</div><div class="line">       return this.title;</div><div class="line">   &#125;,</div><div class="line">   getAuthor: function()&#123;</div><div class="line">       return this.author;</div><div class="line">   &#125;,</div><div class="line">   getISBN: function()&#123;</div><div class="line">       return this.ISBN;</div><div class="line">   &#125;,</div><div class="line">/*其它get方法在这里就不显示了*/</div><div class="line"></div><div class="line"></div><div class="line">上面这种函数，最大的问题，就是后面的那4个参数，就算是同一本书，时间不一样，都算成是不一样的</div><div class="line">其实，你是想知道，书这个东西，而不是书*变量个，这样内存中有很多没用的例子</div><div class="line"></div><div class="line"></div><div class="line">$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line"> console.log(&apos;You clicked: &apos; + $(this).attr(&apos;id&apos;));</div><div class="line">&#125;);</div><div class="line">// 上面的代码，要避免使用，避免再次对DOM元素进行生成jQuery对象，因为这里可以直接使用DOM元素自身了。</div><div class="line">$(&apos;div&apos;).bind(&apos;click&apos;, function()&#123;</div><div class="line"> console.log(&apos;You clicked: &apos; + this.id);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">其实，很简单，就是一个排列组合的问题</div><div class="line">比如，创建文件夹来举例吧，你是创建book1到book10,10个文件夹，还是，创建book文件夹，里面放1-10个子文件夹，一个11个文件夹</div><div class="line"></div><div class="line">第一种方案字符串是，5*9+6=51</div><div class="line">第二种方案是4+9+2=15</div><div class="line">这节省空间是明显的，别问啥意思</div></pre></td></tr></table></figure>
<h1 id="第三十八部分，设计模式之职责链模式"><a href="#第三十八部分，设计模式之职责链模式" class="headerlink" title="第三十八部分，设计模式之职责链模式"></a>第三十八部分，设计模式之职责链模式</h1><p>职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p>也就是说，请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。提交请求的对象并不明确知道哪一个对象将会处理它——也就是该请求有一个隐式的接受者（implicit receiver）。根据运行时刻，任一候选者都可以响应相应的请求，候选者的数目是任意的，你可以在运行时刻决定哪些候选者参与到链中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">var NO_TOPIC = -1;</div><div class="line">var Topic;</div><div class="line"></div><div class="line">function Handler(s, t) &#123;</div><div class="line">    this.successor = s || null;</div><div class="line">    this.topic = t || 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Handler.prototype = &#123;</div><div class="line">    handle: function () &#123;</div><div class="line">        if (this.successor) &#123;</div><div class="line">            this.successor.handle()</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    has: function () &#123;</div><div class="line">        return this.topic != NO_TOPIC;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">var app = new Handler(&#123;</div><div class="line">    handle: function () &#123;</div><div class="line">        console.log(&apos;app handle&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;, 3);</div><div class="line"></div><div class="line">var dialog = new Handler(app, 1);</div><div class="line">dialog.handle = function () &#123;</div><div class="line">    console.log(&apos;dialog before ...&apos;)</div><div class="line">    // 这里做具体的处理操作</div><div class="line">    Handler.prototype.handle.call(this); //继续往上走</div><div class="line">    console.log(&apos;dialog after ...&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var button = new Handler(dialog, 2);</div><div class="line">button.handle = function () &#123;</div><div class="line">    console.log(&apos;button before ...&apos;)</div><div class="line">    // 这里做具体的处理操作</div><div class="line">    Handler.prototype.handle.call(this);</div><div class="line">    console.log(&apos;button after ...&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">button.handle();</div><div class="line"></div><div class="line">通过代码的运行结果我们可以看出，如果想先自身处理，然后再调用继任者处理的话，就在末尾执行Handler.prototype.handle.call(this);代码，如果想先处理继任者的代码，就在开头执行Handler.prototype.handle.call(this);代码。</div><div class="line"></div><div class="line">prototype用的好，就得理解this和prototype</div></pre></td></tr></table></figure>
<h1 id="第三十九部分，设计模式之适配器模式"><a href="#第三十九部分，设计模式之适配器模式" class="headerlink" title="第三十九部分，设计模式之适配器模式"></a>第三十九部分，设计模式之适配器模式</h1><p>适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//鸭子</div><div class="line">var Duck = function()&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">Duck.prototype.fly = function()&#123;</div><div class="line">throw new Error(&quot;该方法必须被重写!&quot;);</div><div class="line">&#125;;</div><div class="line">Duck.prototype.quack = function()&#123;</div><div class="line">throw new Error(&quot;该方法必须被重写!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//火鸡</div><div class="line">var Turkey = function()&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">Turkey.prototype.fly = function()&#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;;</div><div class="line">Turkey.prototype.gobble = function()&#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//鸭子</div><div class="line">var MallardDuck = function () &#123;</div><div class="line">    Duck.apply(this);</div><div class="line">&#125;;</div><div class="line">MallardDuck.prototype = new Duck(); //原型是Duck</div><div class="line">MallardDuck.prototype.fly = function () &#123;</div><div class="line">    console.log(&quot;可以飞翔很长的距离!&quot;);</div><div class="line">&#125;;</div><div class="line">MallardDuck.prototype.quack = function () &#123;</div><div class="line">    console.log(&quot;嘎嘎！嘎嘎！&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//火鸡</div><div class="line">var WildTurkey = function () &#123;</div><div class="line">    Turkey.apply(this);</div><div class="line">&#125;;</div><div class="line">WildTurkey.prototype = new Turkey(); //原型是Turkey</div><div class="line">WildTurkey.prototype.fly = function () &#123;</div><div class="line">    console.log(&quot;飞翔的距离貌似有点短!&quot;);</div><div class="line">&#125;;</div><div class="line">WildTurkey.prototype.gobble = function () &#123;</div><div class="line">    console.log(&quot;咯咯！咯咯！&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<pre><code>那合适使用适配器模式好呢？如果有以下情况出现时，建议使用：

使用一个已经存在的对象，但其方法或属性接口不符合你的要求；
你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作；
想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性。
另外，适配器模式和其它几个模式可能容易让人迷惑，这里说一下大概的区别：

适配器和桥接模式虽然类似，但桥接的出发点不同，桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口。
装饰者模式增强了其它对象的功能而同时又不改变它的接口，因此它对应程序的透明性比适配器要好，其结果是装饰者支持递归组合，而纯粹使用适配器则是不可能的。
代理模式在不改变它的接口的条件下，为另外一个对象定义了一个代理。
</code></pre><h1 id="第四十部分，设计模式之组合模式"><a href="#第四十部分，设计模式之组合模式" class="headerlink" title="第四十部分，设计模式之组合模式"></a>第四十部分，设计模式之组合模式</h1><p>组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>常见的场景有asp.net里的控件机制（即control里可以包含子control，可以递归操作、添加、删除子control），类似的还有DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line">var MenuComponent = function () &#123;</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getName = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getDescription = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getPrice = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.isVegetarian = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.print = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.add = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.remove = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getChild = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var MenuItem = function (sName, sDescription, bVegetarian, nPrice) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.bVegetarian = bVegetarian;</div><div class="line">    this.nPrice = nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype = new MenuComponent();</div><div class="line">MenuItem.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getPrice = function () &#123;</div><div class="line">    return this.nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.isVegetarian = function () &#123;</div><div class="line">    return this.bVegetarian;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.print = function () &#123;</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription() + &quot;, &quot; + this.getPrice() + &quot;euros&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var Menu = function (sName, sDescription) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.aMenuComponents = [];</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.createIterator = function () &#123;</div><div class="line">        throw new Error(&quot;This method must be overwritten!&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">Menu.prototype = new MenuComponent();</div><div class="line">Menu.prototype.add = function (oMenuComponent) &#123;</div><div class="line">    // 添加子菜品</div><div class="line">    this.aMenuComponents.push(oMenuComponent);</div><div class="line">&#125;;</div><div class="line">Menu.prototype.remove = function (oMenuComponent) &#123;</div><div class="line">    // 删除子菜品</div><div class="line">    var aMenuItems = [];</div><div class="line">    var nMenuItem = 0;</div><div class="line">    var nLenMenuItems = this.aMenuComponents.length;</div><div class="line">    var oItem = null;</div><div class="line"></div><div class="line">    for (; nMenuItem &lt; nLenMenuItems; ) &#123;</div><div class="line">        oItem = this.aMenuComponents[nMenuItem];</div><div class="line">        if (oItem !== oMenuComponent) &#123;</div><div class="line">            aMenuItems.push(oItem);</div><div class="line">        &#125;</div><div class="line">        nMenuItem = nMenuItem + 1;</div><div class="line">    &#125;</div><div class="line">    this.aMenuComponents = aMenuItems;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getChild = function (nIndex) &#123;</div><div class="line">    //获取指定的子菜品</div><div class="line">    return this.aMenuComponents[nIndex];</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.print = function () &#123;</div><div class="line">    // 打印当前菜品以及所有的子菜品</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription());</div><div class="line">    console.log(&quot;--------------------------------------------&quot;);</div><div class="line"></div><div class="line">    var nMenuComponent = 0;</div><div class="line">    var nLenMenuComponents = this.aMenuComponents.length;</div><div class="line">    var oMenuComponent = null;</div><div class="line"></div><div class="line">    for (; nMenuComponent &lt; nLenMenuComponents; ) &#123;</div><div class="line">        oMenuComponent = this.aMenuComponents[nMenuComponent];</div><div class="line">        oMenuComponent.print();</div><div class="line">        nMenuComponent = nMenuComponent + 1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var DinnerMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">DinnerMenu.prototype = new Menu();</div><div class="line"></div><div class="line">var CafeMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">CafeMenu.prototype = new Menu();</div><div class="line"></div><div class="line">var PancakeHouseMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">PancakeHouseMenu.prototype = new Menu();</div><div class="line"></div><div class="line"></div><div class="line">var Mattress = function (aMenus) &#123;</div><div class="line">    this.aMenus = aMenus;</div><div class="line">&#125;;</div><div class="line">Mattress.prototype.printMenu = function () &#123;</div><div class="line">    this.aMenus.print();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">组合模式，特点就是抽象一个父子公用的类，比如，add，remove这些getChild之类的，必须提供</div></pre></td></tr></table></figure></p>
<h1 id="第四十一部分，设计模式之模板方法"><a href="#第四十一部分，设计模式之模板方法" class="headerlink" title="第四十一部分，设计模式之模板方法"></a>第四十一部分，设计模式之模板方法</h1><p>模板方法（TemplateMethod）定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法是一种代码复用的基本技术，在类库中尤为重要，因为他们提取了类库中的公共行为。模板方法导致一种反向的控制结构，这种结构就是传说中的“好莱坞法则”，即“别找找我们，我们找你</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">var CaffeineBeverage = function () &#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.prepareRecipe = function () &#123;</div><div class="line">    this.boilWater();</div><div class="line">    this.brew();</div><div class="line">    this.pourOnCup();</div><div class="line">    if (this.customerWantsCondiments()) &#123;</div><div class="line">        // 如果可以想加小料，就加上</div><div class="line"> this.addCondiments();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.boilWater = function () &#123;</div><div class="line">    console.log(&quot;将水烧开!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.pourOnCup = function () &#123;</div><div class="line">    console.log(&quot;将饮料到再杯子里!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.brew = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">CaffeineBeverage.prototype.addCondiments = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">// 默认加上小料</div><div class="line">CaffeineBeverage.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return true;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">// 冲咖啡</div><div class="line">var Coffee = function () &#123;</div><div class="line">    CaffeineBeverage.apply(this);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype = new CaffeineBeverage();</div><div class="line">Coffee.prototype.brew = function () &#123;</div><div class="line">    console.log(&quot;从咖啡机想咖啡倒进去!&quot;);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype.addCondiments = function () &#123;</div><div class="line">    console.log(&quot;添加糖和牛奶&quot;);</div><div class="line">&#125;;</div><div class="line">Coffee.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return confirm(&quot;你想添加糖和牛奶吗？&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//冲茶叶</div><div class="line">var Tea = function () &#123;</div><div class="line">    CaffeineBeverage.apply(this);</div><div class="line">&#125;;</div><div class="line">Tea.prototype = new CaffeineBeverage();</div><div class="line">Tea.prototype.brew = function () &#123;</div><div class="line">    console.log(&quot;泡茶叶!&quot;);</div><div class="line">&#125;;</div><div class="line">Tea.prototype.addCondiments = function () &#123;</div><div class="line">    console.log(&quot;添加柠檬!&quot;);</div><div class="line">&#125;;</div><div class="line">Tea.prototype.customerWantsCondiments = function () &#123;</div><div class="line">    return confirm(&quot;你想添加柠檬嘛？&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>模板方法应用于下列情况：</p>
<p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现<br>各子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复，不同之处分离为新的操作，最后，用一个钓鱼这些新操作的模板方法来替换这些不同的代码<br>控制子类扩展，模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展</p>
<h1 id="第四十二部分，设计模式之原型模式"><a href="#第四十二部分，设计模式之原型模式" class="headerlink" title="第四十二部分，设计模式之原型模式"></a>第四十二部分，设计模式之原型模式</h1><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var vehicle = &#123;</div><div class="line">    getModel: function () &#123;</div><div class="line">        console.log(&apos;车辆的模具是：&apos; + this.model);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var car = Object.create(vehicle, &#123;</div><div class="line">    &apos;id&apos;: &#123;</div><div class="line">        value: MY_GLOBAL.nextId(),</div><div class="line">        enumerable: true // 默认writable:false, configurable:false</div><div class="line"> &#125;,</div><div class="line">    &apos;model&apos;: &#123;</div><div class="line">        value: &apos;福特&apos;,</div><div class="line">        enumerable: true</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">说的简单一点，其实就是特指，JavaScript里面的原型模式</div></pre></td></tr></table></figure>
<h1 id="第四十三部分，设计模式之状态模式"><a href="#第四十三部分，设计模式之状态模式" class="headerlink" title="第四十三部分，设计模式之状态模式"></a>第四十三部分，设计模式之状态模式</h1><p>状态模式（State）允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类。<br>这个地方内容代码太长了<br>我自己理解，总结一下</p>
<ol>
<li>比如有A，B，C三种状态</li>
<li>那么每种状态必须对应了一组动作，比如开和关，那么3*2=6种状态</li>
<li>三种状态，有种转换关系，状态的改变，同样的开，代表的意思不一样</li>
<li>比如顺序，A-》B-》C-》A，那么同样的，动作，开随着状态的改变，意义发生变化<h1 id="第四十四部分，设计模式之桥接模式"><a href="#第四十四部分，设计模式之桥接模式" class="headerlink" title="第四十四部分，设计模式之桥接模式"></a>第四十四部分，设计模式之桥接模式</h1></li>
</ol>
<p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">// 通过ID发送请求，然后返回数据</div><div class="line">asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;</div><div class="line">// callback response</div><div class="line">callback(resp.responseText);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">桥接，看大叔的例子，还真是没懂，回去看了我之前写过的设计模式，才慢慢理解switch </div><div class="line">桥接=代理+策略</div><div class="line">为什么这么说？</div><div class="line">1. jdbc是桥接，怎么用，是不是每次主动输入一个mysql.jdbc这么个字符串？</div><div class="line">2. 代理模式很明白的只代理一个类，内部写死了</div><div class="line">3. 而策略模式，是有一组策略，客户端不需要具体使用了什么策略</div><div class="line">4. 那么桥接，就是你要明确的告诉这个代理，要用哪种策略</div><div class="line">5. 因此，你需要清楚，你是要给谁桥？</div><div class="line">6. 因此上面这个例子，callback，就是你自己传递尽量的，按个策略</div></pre></td></tr></table></figure>
<h1 id="第四十五部分，代码复用模式（避免篇）"><a href="#第四十五部分，代码复用模式（避免篇）" class="headerlink" title="第四十五部分，代码复用模式（避免篇）"></a>第四十五部分，代码复用模式（避免篇）</h1><p>写了6篇，应该让我们避免的模式，那么不要去话时间记忆不要用的，重点在下篇</p>
<h1 id="第四十六部分，代码复用模式（推荐篇）"><a href="#第四十六部分，代码复用模式（推荐篇）" class="headerlink" title="第四十六部分，代码复用模式（推荐篇）"></a>第四十六部分，代码复用模式（推荐篇）</h1><p>只需记住，大叔推荐，让我们记住的模式，就可以了</p>
<pre><code>模式1：原型继承

原型继承是让父对象作为子对象的原型，从而达到继承的目的：
function object(o) {
    function F() {
    }

    F.prototype = o;
    return new F();
}

// 要继承的父对象
var parent = {
    name: &quot;Papa&quot;
};

// 新对象
var child = object(parent);

// 测试
console.log(child.name); // &quot;Papa&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 创建新person
var papa = new Person();
// 继承
var kid = object(papa);
console.log(kid.getName()); // &quot;Adam&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 继承
var kid = object(Person.prototype);
console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的
console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型
记住一句话，prototype是一个对象

function object(o) {
    function F() {
    }

    F.prototype = o;
    return new F();
}

// 要继承的父对象
var parent = {
    name: &quot;Papa&quot;
};

// 新对象
var child = object(parent);

// 测试
console.log(child.name); // &quot;Papa&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 创建新person
var papa = new Person();
// 继承
var kid = object(papa);
console.log(kid.getName()); // &quot;Adam&quot;


// 父构造函数
function Person() {
    // an &quot;own&quot; property
    this.name = &quot;Adam&quot;;
}
// 给原型添加新属性
Person.prototype.getName = function () {
    return this.name;
};
// 继承
var kid = object(Person.prototype);
console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的
console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型

模式2：复制所有属性进行继承

这种方式的继承就是将父对象里所有的属性都复制到子对象上，一般子对象可以使用父对象的数据。

先来看一个浅拷贝的例子：

/* 浅拷贝 */
function extend(parent, child) {
    var i;
    child = child || {};
    for (i in parent) {
        if (parent.hasOwnProperty(i)) {
            child[i] = parent[i];
        }
    }
    return child;
}

var dad = { name: &quot;Adam&quot; };
var kid = extend(dad);
console.log(kid.name); // &quot;Adam&quot;

var dad = {
    counts: [1, 2, 3],
    reads: { paper: true }
};
var kid = extend(dad);
kid.counts.push(4);
console.log(dad.counts.toString()); // &quot;1,2,3,4&quot;
console.log(dad.reads === kid.reads); // true
代码的最后一行，你可以发现dad和kid的reads是一样的，也就是他们使用的是同一个引用，这也就是浅拷贝带来的问题。


/* 深拷贝 */
function extendDeep(parent, child) {
    var i,
        toStr = Object.prototype.toString,
        astr = &quot;[object Array]&quot;;

    child = child || {};

    for (i in parent) {
        if (parent.hasOwnProperty(i)) {
            if (typeof parent[i] === &apos;object&apos;) {
                child[i] = (toStr.call(parent[i]) === astr) ? [] : {};
                extendDeep(parent[i], child[i]);
            } else {
                child[i] = parent[i];
            }
        }
    }
    return child;
}

var dad = {
    counts: [1, 2, 3],
    reads: { paper: true }
};
var kid = extendDeep(dad);

kid.counts.push(4);
console.log(kid.counts.toString()); // &quot;1,2,3,4&quot;
console.log(dad.counts.toString()); // &quot;1,2,3&quot;

console.log(dad.reads === kid.reads); // false
kid.reads.paper = false;

这个地方就是厉害在，上面的递归那部分，当包含复合部分就会重新递归调用一次 


模式3：混合（mix-in）

混入就是将一个对象的一个或多个（或全部）属性（或方法）复制到另外一个对象，我们举一个例子：

function mix() {
    var arg, prop, child = {};
    for (arg = 0; arg &lt; arguments.length; arg += 1) {
        for (prop in arguments[arg]) {
            if (arguments[arg].hasOwnProperty(prop)) {
                child[prop] = arguments[arg][prop];
            }
        }
    }
    return child;
}

var cake = mix(
                { eggs: 2, large: true },
                { butter: 1, salted: true },
                { flour: &apos;3 cups&apos; },
                { sugar: &apos;sure!&apos; }
                );

console.dir(cake);


模式4：借用方法

一个对象借用另外一个对象的一个或两个方法，而这两个对象之间不会有什么直接联系。不用多解释，直接用代码解释吧：

var one = {
    name: &apos;object&apos;,
    say: function (greet) {
        return greet + &apos;, &apos; + this.name;
    }
};

// 测试
console.log(one.say(&apos;hi&apos;)); // &quot;hi, object&quot;

var two = {
    name: &apos;another object&apos;
};

console.log(one.say.apply(two, [&apos;hello&apos;])); // &quot;hello, another object&quot;

// 将say赋值给一个变量，this将指向到全局变量
var say = one.say;
console.log(say(&apos;hoho&apos;)); // &quot;hoho, undefined&quot;

// 传入一个回调函数callback
var yetanother = {
    name: &apos;Yet another object&apos;,
    method: function (callback) {
        return callback(&apos;Hola&apos;);
    }
};
console.log(yetanother.method(one.say)); // &quot;Holla, undefined&quot;

function bind(o, m) {
    return function () {
        return m.apply(o, [].slice.call(arguments));
    };
}

var twosay = bind(two, one.say);
console.log(twosay(&apos;yo&apos;)); // &quot;yo, another object&quot;


// ECMAScript 5给Function.prototype添加了一个bind()方法，以便很容易使用apply()和call()。

if (typeof Function.prototype.bind === &apos;undefined&apos;) {
    Function.prototype.bind = function (thisArg) {
        var fn = this,
slice = Array.prototype.slice,
args = slice.call(arguments, 1);
        return function () {
            return fn.apply(thisArg, args.concat(slice.call(arguments)));
        };
    };
}

var twosay2 = one.say.bind(two);
console.log(twosay2(&apos;Bonjour&apos;)); // &quot;Bonjour, another object&quot;

var twosay3 = one.say.bind(two, &apos;Enchanté&apos;);
console.log(twosay3()); // &quot;Enchanté, another object&quot;
</code></pre><h1 id="第四十七部分，对象创建模式（上篇）"><a href="#第四十七部分，对象创建模式（上篇）" class="headerlink" title="第四十七部分，对象创建模式（上篇）"></a>第四十七部分，对象创建模式（上篇）</h1><pre><code>模式1：命名空间（namespace）

命名空间可以减少全局命名所需的数量，避免命名冲突或过度。一般我们在进行对象层级定义的时候，经常是这样的：

var app = app || {};
app.moduleA = app.moduleA || {};

// 更简洁的方式
var MYAPP = MYAPP || {};


模式2：定义依赖

有时候你的一个模块或者函数可能要引用第三方的一些模块或者工具，这时候最好将这些依赖模块在刚开始的时候就定义好，以便以后可以很方便地替换掉。

var myFunction = function () {
    // 依赖模块
    var event = YAHOO.util.Event,
        dom = YAHOO.util.dom;

    // 其它函数后面的代码里使用局部变量event和dom
};

};
模式3：私有属性和私有方法

JavaScript本书不提供特定的语法来支持私有属性和私有方法，但是我们可以通过闭包来实现，代码如下：


function Gadget() {
    // 私有对象
    var name = &apos;iPod&apos;;
    // 公有函数
    this.getName = function () {
        return name;
    };
}

模式4：Revelation模式

也是关于隐藏私有方法的模式，和《深入理解JavaScript系列（3）：全面解析Module模式》里的Module模式有点类似，但是不是return的方式，而是在外部先声明一个变量，然后在内部给变量赋值公有方法。代码如下：

var myarray;

(function () {
    var astr = &quot;[object Array]&quot;,
        toString = Object.prototype.toString;

    function isArray(a) {
        return toString.call(a) === astr;
    }

    function indexOf(haystack, needle) {
        var i = 0,
            max = haystack.length;
        for (; i &lt; max; i += 1) {
            if (haystack[i] === needle) {
                return i;
            }
        }
        return -1;
    }

    //通过赋值的方式，将上面所有的细节都隐藏了
    myarray = {
        isArray: isArray,
        indexOf: indexOf,
        inArray: indexOf
    };
} ());

模式5：链模式

链模式可以你连续可以调用一个对象的方法，比如obj.add(1).remove(2).delete(4).add(2)这样的形式，其实现思路非常简单，就是将this原样返回。代码如下：

var obj = {
    value: 1,
    increment: function () {
        this.value += 1;
        return this;
    },
    add: function (v) {
        this.value += v;
        return this;
    },
    shout: function () {
        console.log(this.value);
    }
};
</code></pre><h1 id="第四十八部分，对象创建模式（下篇）"><a href="#第四十八部分，对象创建模式（下篇）" class="headerlink" title="第四十八部分，对象创建模式（下篇）"></a>第四十八部分，对象创建模式（下篇）</h1><pre><code>模式6：函数语法糖

函数语法糖是为一个对象快速添加方法（函数）的扩展，这个主要是利用prototype的特性，代码比较简单，我们先来看一下实现代码：

if (typeof Function.prototype.method !== &quot;function&quot;) {
    Function.prototype.method = function (name, implementation) {
        this.prototype[name] = implementation;
        return this;
    };
}
模式7：对象常量

对象常量是在一个对象提供set,get,ifDefined各种方法的体现，而且对于set的方法只会保留最先设置的对象，后期再设置都是无效的，已达到别人无法重载的目的。实现代码如下：

var constant = (function () {
    var constants = {},
        ownProp = Object.prototype.hasOwnProperty,
    // 只允许设置这三种类型的值
        allowed = {
            string: 1,
            number: 1,
            boolean: 1
        },


模式8：沙盒模式

沙盒（Sandbox）模式即时为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个Sandbox里有3个方法event,dom,ajax，在调用其中2个组成一个环境的话，和调用三个组成的环境完全没有干扰。

模式9：静态成员

静态成员（Static Members）只是一个函数或对象提供的静态属性，可分为私有的和公有的，就像C#或Java里的public static和private static一样。

我们先来看一下公有成员，公有成员非常简单，我们平时声明的方法，函数都是公有的，比如：

// 构造函数
var Gadget = function () {
};

// 公有静态方法
Gadget.isShiny = function () {
    return &quot;you bet&quot;;
};

// 原型上添加的正常方法
Gadget.prototype.setPrice = function (price) {
    this.price = price;
};

// 调用静态方法
console.log(Gadget.isShiny()); // &quot;you bet&quot;

// 创建实例，然后调用方法
var iphone = new Gadget();
iphone.setPrice(500);


而私有静态成员，我们可以利用其闭包特性去实现，以下是两种实现方式。

第一种实现方式：

var Gadget = (function () {
    // 静态变量/属性
    var counter = 0;

    // 闭包返回构造函数的新实现
    return function () {
        console.log(counter += 1);
    };
} ()); // 立即执行

var g1 = new Gadget(); // logs 1
var g2 = new Gadget(); // logs 2
var g3 = new Gadget(); // logs 3
</code></pre><h1 id="第四十九部分，Function模式（上篇）"><a href="#第四十九部分，Function模式（上篇）" class="headerlink" title="第四十九部分，Function模式（上篇）"></a>第四十九部分，Function模式（上篇）</h1><pre><code>回调函数

在JavaScript中，当一个函数A作为另外一个函数B的其中一个参数时，则函数A称为回调函数，即A可以在函数B的周期内执行（开始、中间、结束时均可）。


配置对象

如果一个函数（或方法）的参数只有一个参数，并且参数为对象字面量，我们则称这种模式为配置对象模式。例如，如下代码：

var conf = {
    username:&quot;shichuan&quot;,
    first:&quot;Chuan&quot;,
    last:&quot;Shi&quot;
};


返回函数

返回函数，则是指在一个函数的返回值为另外一个函数，或者根据特定的条件灵活创建的新函数，示例代码如下：

var setup = function () {
    console.log(1);
    return function () {
        console.log(2);
    };
};
// 调用setup 函数
var my = setup(); // 输出 1
my(); // 输出 2
// 或者直接调用也可
setup()();

强调一句，这种形式的this，认为是ao，激活对象，也可以认为是null，因此是global


偏应用

忽略

Currying

Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。

忽略
</code></pre><h1 id="第五十部分，Function模式（下篇）"><a href="#第五十部分，Function模式（下篇）" class="headerlink" title="第五十部分，Function模式（下篇）"></a>第五十部分，Function模式（下篇）</h1><pre><code>立即执行的对象初始化

该模式的意思是指在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作，通常该模式可以用在一次性执行的代码上。

({
    // 这里你可以定义常量，设置其它值
    maxwidth: 600,
    maxheight: 400,

    //  当然也可以定义utility方法
    gimmeMax: function () {
        return this.maxwidth + &quot;x&quot; + this.maxheight;
    },

    // 初始化
    init: function () {
        console.log(this.gimmeMax());
        // 更多代码...
    }
}).init();  // 这样就开始初始化咯


分支初始化

分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。之前我们在做事件处理的时候，通常使用类似下面的代码：

var utils = {
    addListener: function (el, type, fn) {
        if (typeof window.addEventListener === &apos;function&apos;) {
            el.addEventListener(type, fn, false);
        } else if (typeof document.attachEvent !== &apos;undefined&apos;) {
            el.attachEvent(&apos;on&apos; + type, fn);
        } else {
            el[&apos;on&apos; + type] = fn;
        }
    },
    removeListener: function (el, type, fn) {
    }
};

内存优化

该模式主要是利用函数的属性特性来避免大量的重复计算。通常代码形式如下：

var myFunc = function (param) {
    if (!myFunc.cache[param]) {
        var result = {};
        // ... 复杂操作 ...
        myFunc.cache[param] = result;
    }
    return myFunc.cache[param];
};

// cache 存储
myFunc.cache = {};
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感3&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感3&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaScrip
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感二（17——24节）</title>
    <link href="http://ghohankawk.github.io/2017/06/13/tomdashu2/"/>
    <id>http://ghohankawk.github.io/2017/06/13/tomdashu2/</id>
    <published>2017-06-13T03:23:16.482Z</published>
    <updated>2017-06-13T11:44:04.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感2"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感2" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感2"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感2</h1><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=527602&auto=1&height=66"></iframe></p>
<h1 id="第十七部分，面向对象编程之概论"><a href="#第十七部分，面向对象编程之概论" class="headerlink" title="第十七部分，面向对象编程之概论"></a>第十七部分，面向对象编程之概论</h1><p>我们有必要掌握一些OOP基本的特征，并澄清概论中的主要概念。主要讨论封装，继承，多态，接口，那些传统的面向对象概念，可以忽略不看，不影响</p>
<h1 id="第十八部分，面向对象编程之ECMAScript实现（推荐）"><a href="#第十八部分，面向对象编程之ECMAScript实现（推荐）" class="headerlink" title="第十八部分，面向对象编程之ECMAScript实现（推荐）"></a>第十八部分，面向对象编程之ECMAScript实现（推荐）</h1><p>总结如下：</p>
<pre><code>1. 原始值类型
   回头来看6中用于ECMAScript程序的数据类型，前5种是原始值类型，包括Undefined、Null、Boolean、String、Number、Object。
2. 有必要需要注意的是规范还区分了这内置对象、元素对象和宿主对象。
所有ECMAScript实现的对象都是原生对象（其中一些是内置对象、一些在程序执行的时候创建，例如用户自定义对象）。内置对象是原生对象的一个子集、是在程序开始之前内置到ECMAScript里的（例如，parseInt, Match等）。所有的宿主对象是由宿主环境提供的，通常是浏览器，并可能包括如window、alert等。
也有对象是由特殊的内置构造函数创建： Function（函数对象构造器）、Array（数组构造器） RegExp（正则表达式构造器）、Math（数学模块）、 Date（日期的构造器）等等，这些对象也是Object对象类型的值
3. 字面量Literal

   对于三个对象的值：对象（object）,数组（array）和正则表达式（regular expression）
4. 然而，如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：
function A() {}
A.prototype = {
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // false!
因此，对函数的原型引用需要手工恢复：

function A() {}
A.prototype = {
  constructor: A,
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // true
5. a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype

   此外， 实例的[[Prototype]]值确实是在构造函数的prototype属性上获取的。

   然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。
  对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。

  这个地方，原型链，特别难理解，详细的看第一篇，观后感的，原型链的，链接，那个是非常详细的说明 
6. 有误解：

   if (foo instanceof Foo) {
     ...
   }
   这不是用来检测对象foo是否是用Foo构造函数创建的，
所有instanceof运算符只需要一个对象属性——foo.[[Prototype]]，在原型链中从Foo.prototype开始检查其是否存在。

7. alert(1..toString()); // &quot;1&quot;，不是语法错误
   大部分程序里使用原型是用来存储对象的方法、默认状态和共享对象的属性。
</code></pre><h1 id="第十九部分，求值策略-Evaluation-strategy"><a href="#第十九部分，求值策略-Evaluation-strategy" class="headerlink" title="第十九部分，求值策略(Evaluation strategy)"></a>第十九部分，求值策略(Evaluation strategy)</h1><p>很多程序员都确信在JavaScript中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参</p>
<pre><code>1. 按值传递
   按值传递，很多开发人员都很了解了，参数的值是调用者传递的对象值的拷贝(copy of value），函数内部改变参数的值不会影响到外面的对象（该参数在外面的值），一般来说，是重新分配了新内存(我们不关注分配内存是怎么实现的——也是是栈也许是动态内存分配），该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。
2. 按引用传递
   另外一个众所周知的按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。
3. 按共享传递（Call by sharing）
最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象（例如外部的该对象不是想按值传递一样完全的拷贝),改变该参数对象的属性值将会影响到外部的对象。
4. 现在我们知道了ECMAScript中将对象作为参数传递的策略了——按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象
传递的是引用的拷贝（地址副本）

再强调一下，这里所说对象的值是地址（address），而不是对象结构本身，将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。
</code></pre><h1 id="第二十部分，《你真懂JavaScript吗？》答案详解"><a href="#第二十部分，《你真懂JavaScript吗？》答案详解" class="headerlink" title="第二十部分，《你真懂JavaScript吗？》答案详解"></a>第二十部分，《你真懂JavaScript吗？》答案详解</h1><p>总结如下：</p>
<pre><code>1.  题目1

    if (!(&quot;a&quot; in window)) {
        var a = 1;
    }
    alert(a);
   答案是undefined
2. var a = 1,
       b = function a(x) {
           x &amp;&amp; a(--x);
       };
   alert(a);
   答案1
3. function a(x) {
       return x * 2;
   }
   var a;
   alert(a);
   答案 a函数
4. function b(x, y, a) {
       arguments[2] = 10;
       alert(a);
   }
   b(1, 2, 3);
   答案是10
5. function a() {
       alert(this);
   }
   a.call(null);
    答案是window
</code></pre><h1 id="第二十一部分，S-O-L-I-D五大原则之接口隔离原则ISP"><a href="#第二十一部分，S-O-L-I-D五大原则之接口隔离原则ISP" class="headerlink" title="第二十一部分，S.O.L.I.D五大原则之接口隔离原则ISP"></a>第二十一部分，S.O.L.I.D五大原则之接口隔离原则ISP</h1><p>没看懂，基本不用看</p>
<h1 id="第二十二部分，S-O-L-I-D五大原则之依赖倒置原则DIP"><a href="#第二十二部分，S-O-L-I-D五大原则之依赖倒置原则DIP" class="headerlink" title="第二十二部分，S.O.L.I.D五大原则之依赖倒置原则DIP]"></a>第二十二部分，S.O.L.I.D五大原则之依赖倒置原则DIP]</h1><p>稍微看懂了，估计是因为java看多了，ioc，基本不用看</p>
<h1 id="第二十三部分，JavaScript与DOM（上）——也适用于新手"><a href="#第二十三部分，JavaScript与DOM（上）——也适用于新手" class="headerlink" title="第二十三部分，JavaScript与DOM（上）——也适用于新手"></a>第二十三部分，JavaScript与DOM（上）——也适用于新手</h1><pre><code>最重要的是Element, Text, Document。

 Element节点在页面里展示的是一个元素，所以如果你有段落元素(&lt;p&gt;)，你可以通过这个DOM节点来访问。
 Text节点在页面里展示的所有文本相关的元素，所以如果你的段落有文本在里面的话，你可以直接通过DOM的Text节点来访问这个文本
 Document节点代表是整个文档，它是DOM的根节点。

nodeType类型，1是元素，2是属性，3是text节点，详细的type类型可以通过此地址：

    Node.ELEMENT_NODE == 1
    Node.ATTRIBUTE_NODE == 2
    Node.TEXT_NODE == 3
    Node.CDATA_SECTION_NODE == 4
    Node.ENTITY_REFERENCE_NODE == 5
    Node.ENTITY_NODE == 6
    Node.PROCESSING_INSTRUCTION_NODE == 7
    Node.COMMENT_NODE == 8
    Node.DOCUMENT_NODE == 9
    Node.DOCUMENT_TYPE_NODE == 10
    Node.DOCUMENT_FRAGMENT_NODE == 11
    Node.NOTATION_NODE == 12
</code></pre><h1 id="第二十四部分，JavaScript与DOM（下）"><a href="#第二十四部分，JavaScript与DOM（下）" class="headerlink" title="第二十四部分，JavaScript与DOM（下）"></a>第二十四部分，JavaScript与DOM（下）</h1><pre><code>node节点的2种类型，一种是元素节点，一种是text节点，上一章节已经列出了所有的节点类型，这两种需要我们现在特别注意。创建元素可以通过createElement方法，而创建text节点可以使用createTextNode，相应代码如下：
正如我们上章所说的，DOM和JavaScript语言是2个单独的东西，浏览器事件是DOM API的一部分，而不是JavaScript的一部分。

‘mouseover’ – 鼠标移动到某元素上的时候触发mouseover事件。
 ‘mouseout’ – 鼠标从某元素离开的时候触发mouseout事件。
 ‘mousemove’ – 鼠标在某元素上移动但未离开的时候触发mousemove事件。
 ‘change’ – 控件失去input焦点的时候触发该事件（或者值被改变的时候）。

 ‘load’ – 页面加载完毕（包括内容、图片、frame、object）的时候触发该事件。
 ‘resize’ – 页面大小改变的时候触发该事件（例如浏览器缩放）。
 ‘scroll’ – 页面滚动的时候触发该事件。
 ‘unload’ – 从页面或frame删除所有内容的时候触发该事件（例如离开一个页面）。

 严格来说，有2中不同的模型：W3C模型和微软模型，除IE之外W3C模型支持所有的现代浏览器，而微软模型只支持IE

 使用W3C模型的代码如下：

 // 格式：target.addEventListener( type, function, useCapture );  
 // 例子:  
 var myIntro = document.getElementById(&apos;intro&apos;);
 myIntro.addEventListener(&apos;click&apos;, introClick, false);
 使用IE模型的代码如下：

 // 格式: target.attachEvent ( &apos;on&apos; + type, function );  
 // 例子:  
 var myIntro = document.getElementById(&apos;intro&apos;);
 myIntro.attachEvent(&apos;onclick&apos;, introClick);

 一个非常重要的内容是Event对象，当事件发生的时候出发某个函数，该Event对象将自动在函数内可用，该对象包含了很多事件触发时候的信息，但IE却没有这么实现，而是自己实现的，IE浏览器是通过全局对象window下的event属性来包含这些信息

 例如当你想取消默认的行为的时候你可以使用Event对象里的preventDefault()方法，但IE里不得不使用对象的returnValue属性值来控制


 事件冒泡，就是事件触发的时候通过DOM向上冒泡，首先要知道不是所有的事件都有冒泡。事件在一个目标元素上触发的时候，该事件将触发一一触发祖先节点元素，直到最顶层的元素：
 如图所示，如果a连接被点击，触发触发连接的click事件，然后触发p的click事件，以此再触发div和body的click事件。顺序不变，而且不一定是在同时触发的。
 举例来说，如果你有一个很多行的大表格，在每个&lt;tr&gt;上绑定点击事件是个非常危险的想法，因为性能是个大问题。流行的做法是使用事件委托。事件委托描述的是将事件绑定在容器元素上，然后通过判断点击的target子元素的类型来触发相应的事件。
 事件委托依赖于事件冒泡，如果事件冒泡到table之前被禁用的话，那上面的代码就无法工作了。

 经典的事件处理模型，微软的冒泡，以及网景的捕获模型，w3c的两者兼容，网上例子很多，去看解释
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感2&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感2&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaScrip
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汤姆大叔的深入理解JavaScript读后感一（1——16节）</title>
    <link href="http://ghohankawk.github.io/2017/06/12/tomdashu/"/>
    <id>http://ghohankawk.github.io/2017/06/12/tomdashu/</id>
    <published>2017-06-12T04:07:39.341Z</published>
    <updated>2017-06-13T03:12:08.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是tom大叔的JavaScript系列的读书观后感"><a href="#今天要分享的内容是tom大叔的JavaScript系列的读书观后感" class="headerlink" title="今天要分享的内容是tom大叔的JavaScript系列的读书观后感"></a>今天要分享的内容是tom大叔的JavaScript系列的读书观后感</h1><h1 id="第一部分，编写高质量JavaScript代码的基本要点"><a href="#第一部分，编写高质量JavaScript代码的基本要点" class="headerlink" title="第一部分，编写高质量JavaScript代码的基本要点"></a>第一部分，编写高质量JavaScript代码的基本要点</h1><p>内容不多，但是作为从头规范开始，值得遵循，现在看来，才更能明白里面的道理。<br>总结一下：</p>
<pre><code>1. 避免全局变量，为啥？自己去看，以及隐式全局变量的副作用，那怎么办？命名空间
2. 推荐单一的单var形式，如  var a = 1,b = 2,myobject = {};形式
3. for循环，预存缓存变量，for-in遍历对象用hasOwnProperty，去掉原型链的属性
4. 避免使用eval，记住该咒语“eval()是魔鬼”，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免                     
5. 编码规范，缩进，空格，花括号，分号
6. 命名函数，啥时候大写，啥时候小写，推荐驼峰命名
7. 关于注解，通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。
</code></pre><h1 id="第二部分，揭秘命名函数表达式"><a href="#第二部分，揭秘命名函数表达式" class="headerlink" title="第二部分，揭秘命名函数表达式"></a>第二部分，揭秘命名函数表达式</h1><p>总结如下：</p>
<pre><code>1. 什么是申明函数？
2. 什么是表达式函数？
3. 什么是函数语句？
4. 什么是命名函数？
5. 主要是区别的地方，很细微，然后又很多浏览器的怪异行为，坑比较多
6. 还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式
7. 后面的部分，如果第一次看，肯定看不懂，是啥意思，建议先忽略掉
</code></pre><h1 id="第三部分，全面解析Module模式"><a href="#第三部分，全面解析Module模式" class="headerlink" title="第三部分，全面解析Module模式"></a>第三部分，全面解析Module模式</h1><p>总结如下：</p>
<pre><code>1. 正常的module模式，缺点就是，每次都必须new，每个实例都是单独的
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Calculator = function (eq) &#123;</div><div class="line">       //这里可以声明私有成员</div><div class="line">   </div><div class="line">       var eqCtl = document.getElementById(eq);</div><div class="line">   </div><div class="line">       return &#123;</div><div class="line">           // 暴露公开的成员</div><div class="line">           add: function (x, y) &#123;</div><div class="line">               var val = x + y;</div><div class="line">               eqCtl.innerHTML = val;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<pre><code>2. 改进过后的，利用函数自执行，可以直接使用
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;, privateName = &quot;博客园&quot;;</div><div class="line"></div><div class="line">    function privateAddTopic(data) &#123;</div><div class="line">        // 这里是内部处理代码</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    my.Name = privateName;</div><div class="line">    my.AddTopic = function (data) &#123;</div><div class="line">        privateAddTopic(data);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<pre><code>3. 改進松耦合
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (my) &#123;</div><div class="line"></div><div class="line">    // 添加一些功能   </div><div class="line">    </div><div class="line">    return my;</div><div class="line">&#125; (blogModule || &#123;&#125;));</div></pre></td></tr></table></figure>
<pre><code>4. 克隆
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  var blogModule = (function (old) &#123;</div><div class="line">       var my = &#123;&#125;,</div><div class="line">           key;</div><div class="line">    for (key in old) &#123;</div><div class="line">        if (old.hasOwnProperty(key)) &#123;</div><div class="line">            my[key] = old[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var oldAddPhotoMethod = old.AddPhoto;</div><div class="line">    my.AddPhoto = function () &#123;</div><div class="line">        // 克隆以后，进行了重写，当然也可以继续调用oldAddPhotoMethod</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<pre><code>5. 子模块
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">blogModule.CommentSubModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;;</div><div class="line">    // ...</div><div class="line"></div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<h1 id="第四部分，立即调用的函数表达式"><a href="#第四部分，立即调用的函数表达式" class="headerlink" title="第四部分，立即调用的函数表达式"></a>第四部分，立即调用的函数表达式</h1><pre><code>1. 自動執行
(function () { /* code */ } ()); // 推荐使用这个
2. (function () { /* code */ })(); // 但是这个也是可以用的，括號
3.在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。
4. 闭包的经典例子
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">   错误的：</div><div class="line">   var elems = document.getElementsByTagName(&apos;a&apos;);</div><div class="line">   </div><div class="line">   for (var i = 0; i &lt; elems.length; i++) &#123;</div><div class="line">   </div><div class="line">       elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</div><div class="line">           e.preventDefault();</div><div class="line">           alert(&apos;I am link #&apos; + i);</div><div class="line">       &#125;, &apos;false&apos;);</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">正确的：会锁住对应的index的值，虽然i最后为10，但是之前的值，已经记录好了</div><div class="line">var elems = document.getElementsByTagName(&apos;a&apos;);</div><div class="line"></div><div class="line">for (var i = 0; i &lt; elems.length; i++) &#123;</div><div class="line"></div><div class="line">    (function (lockedInIndex) &#123;</div><div class="line"></div><div class="line">        elems[i].addEventListener(&apos;click&apos;, function (e) &#123;</div><div class="line">            e.preventDefault();</div><div class="line">            alert(&apos;I am link #&apos; + lockedInIndex);</div><div class="line">        &#125;, &apos;false&apos;);</div><div class="line"></div><div class="line">    &#125;)(i);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">   ``` </div><div class="line">       5. 不管什么是自执行，还是立即调用，不用分那么清楚，只需知道立即执行一次匿名函数就够了</div><div class="line">       </div><div class="line"># 第五部分，强大的原型和原型链</div><div class="line"></div><div class="line">    1. 原型关键词，prototype</div><div class="line">    2. 说白了，原型就是一个对象</div><div class="line">    3. 通过hasOwnProperty，区分属性从哪里来的</div><div class="line">    4. 默认还有一个原型的链条，一直到Object.prototype为止</div><div class="line">    5. 所有的对象都有&quot;[[prototype]]&quot;属性（通过__proto__访问），该属性对应对象的原型</div><div class="line">    6. 所有的函数对象都有&quot;prototype&quot;属性，该属性的值会被赋值给该函数创建的对象的&quot;__proto__&quot;属性</div><div class="line">    7. 所有的原型对象都有&quot;constructor&quot;属性，该属性对应创建所有指向该原型的实例的构造函数</div><div class="line">    8. 函数对象和原型对象通过&quot;prototype&quot;和&quot;constructor&quot;属性进行相互关联</div><div class="line">    9. 最简单易懂的看下边</div><div class="line">   [原型链介绍](https://www.talkingcoder.com/article/6360227501704156372)</div><div class="line"></div><div class="line"># 第六七八部分，S.O.L.I.D五大原则之单一职责SRP（忽略）</div><div class="line"></div><div class="line">    The Single Responsibility Principle（单一职责SRP）</div><div class="line">    The Open/Closed Principle（开闭原则OCP）</div><div class="line">    The Liskov Substitution Principle（里氏替换原则LSP）</div><div class="line">    The Interface Segregation Principle（接口分离原则ISP）</div><div class="line">    The Dependency Inversion Principle（依赖反转原则DIP）</div><div class="line"># 第九部分，根本没有“JSON对象”这回事！</div><div class="line"></div><div class="line">    简单的说</div><div class="line">    1. // 这是JSON字符串</div><div class="line">       var foo = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;;</div><div class="line">    2. // 这是对象字面量</div><div class="line">       var bar = &#123; &quot;prop&quot;: &quot;val&quot; &#125;;</div><div class="line">    3. // 将字符串反序列化成json对象</div><div class="line">       var my_obj = JSON.parse( foo );</div><div class="line">    4. json对象，和字面量对象，明显的区别，前者必须有引号，后者去掉引号可以</div><div class="line">           var bar = &#123; prop: &quot;val&quot; &#125;;合法的</div><div class="line">    </div><div class="line"># 第十部分，JavaScript核心（晋级高手必读篇）</div><div class="line">    1. 执行上下文栈(Execution Context Stack)，有三种类型：global, function和eval。</div><div class="line">    2. 执行上下文(Execution Context)，变量对象(variable object)，this指针(this value)，作用域链(scope chain)</div><div class="line">    函数表达式[function expression]（而不是函数声明[function declarations，区别请参考本系列第2章]）是不包含在VO[variable object]里面的</div><div class="line">    3. 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。</div><div class="line">       它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</div><div class="line">    4. 当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了</div><div class="line">    5. 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</div><div class="line">    6. 这表示，在我们去搜寻__parent__之前，首先会去__proto__的链接中。</div><div class="line">    7. 闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</div><div class="line">    8. 在ECMAScript中，是不可以给this赋值的，因为，还是那句话，this不是变量。</div><div class="line">    9. this是执行上下文环境的一个属性，而不是某个变量对象的属性</div><div class="line"># 第十一部分，执行上下文（Execution Contexts）</div><div class="line">可以把调用上下文作为第二个参数传递给eval。那么，如果这个上下文存在，就有可能影响“私有”(有人喜欢这样叫它)变量。</div><div class="line"># 第十二部分，变量对象（Variable Object）</div><div class="line">```angularjs</div><div class="line">    if (true) &#123;</div><div class="line">        var a = 1;</div><div class="line">        &#125; else &#123;</div><div class="line">        var b = 2;</div><div class="line">        &#125;</div><div class="line">    alert(a); // 1</div><div class="line">    alert(b); // undefined,不是b没有声明，而是b的值是undefined</div></pre></td></tr></table></figure>
<p>变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">a = 10;</div><div class="line">alert(window.a); // 10</div><div class="line"> </div><div class="line">alert(delete a); // true</div><div class="line"> </div><div class="line">alert(window.a); // undefined</div><div class="line"> </div><div class="line">var b = 20;</div><div class="line">alert(window.b); // 20</div><div class="line"> </div><div class="line">alert(delete b); // false</div><div class="line"> </div><div class="line">alert(window.b); // still 20</div></pre></td></tr></table></figure></p>
<p>但是这个规则在有个上下文里不起走样，那就是eval上下文，变量没有{DontDelete}特性。</p>
<h1 id="第十三部分，This-Yes-this"><a href="#第十三部分，This-Yes-this" class="headerlink" title="第十三部分，This? Yes,this!"></a>第十三部分，This? Yes,this!</h1><pre><code>1，一个函数上下文中确定this值的通用规则如下：
2. 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。
3. 我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的this值，答案在于引用类型（type Reference）不同的中间值。
4. 标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名
5. (function () {
     alert(this); // null =&gt; global
   })();
6. 函数调用中手动设置this，apply,call
7. 作为构造器调用的函数中的this,都将this的值设置为新创建的对象。
8. 引用类型和this为null,默认为golbal
</code></pre><h1 id="第十四部分，作用域链-Scope-Chain"><a href="#第十四部分，作用域链-Scope-Chain" class="headerlink" title="第十四部分，作用域链(Scope Chain)"></a>第十四部分，作用域链(Scope Chain)</h1><pre><code>1. 函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。
2. 注意这重要的一点－－[[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁 
3. 闭包理解
var x = 10;

function foo() {
  alert(x);
}

(function () {
  var x = 20;
  foo(); // 10, but not 20
})();
[[Scope]]包括在函数内创建的词法作用域（父变量对象）。当函数进一步激活时，在变量对象的这个词法链（静态的存储于创建时）中，来自较高作用域的变量将被搜寻。
此外，这个例子也清晰的表明，一个函数（这个例子中为从函数“foo”返回的匿名函数）的[[scope]]持续存在，即使是在函数创建的作用域已经完成之后。
4. 通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象
5. 源于ECMAScript 的原型特性。如果一个属性在对象中没有直接找到，查询将在原型链中继续。即常说的二维链查找。（1）作用域链环节；（2）每个作用域链－－深入到原型链环节
6. 全局和eval上下文中的作用域链,全局上下文的作用域链仅包含全局对象
7. 在代码执行阶段有两个声明能修改作用域链。这就是with声明和catch语句。它们添加到作用域链的最前端，对象须在这些声明中出现的标识符中查找。
</code></pre><h1 id="第十五部分，函数（Functions）"><a href="#第十五部分，函数（Functions）" class="headerlink" title="第十五部分，函数（Functions）"></a>第十五部分，函数（Functions）</h1><pre><code>1。 只有这2个位置可以声明函数，也就是说:不可能在表达式位置或一个代码块中定义它。
2. // 函数可以在如下地方声明：
   // 1) 直接在全局上下文中
   function globalFD() {
     // 2) 或者在一个函数的函数体内
     function innerFD() {}
   }
3. 相当一部分问题出现了，我们为什么需要函数表达式？答案很明显——在表达式中使用它们，”不会污染”变量对象。最简单的例子是将一个函数作为参数传递给其它函数。
4. 这种模式中，初始化的FE的名称通常被忽略：
(function () {
   // 初始化作用域 
})();
5. ”为何在函数创建后的立即调用中必须用圆括号来包围它？”，答案就是：表达式句子的限制就是这样的。
6. function () {
     ...
   }();

   // 即便有名称

   function foo() {
     ...
   }();
如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。

第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。
</code></pre><h1 id="第十六部分，闭包（Closures）"><a href="#第十六部分，闭包（Closures）" class="headerlink" title="第十六部分，闭包（Closures）"></a>第十六部分，闭包（Closures）</h1><pre><code>var z = 10;

function foo() {
  alert(z);
}

foo(); // 10 – 使用静态和动态作用域的时候

(function () {

  var z = 20;
  foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域

})();

// 将foo作为参数的时候是一样的
(function (funArg) {

  var z = 30;
  funArg(); // 10 – 静态作用域, 30 – 动态作用域

})(foo);
上述描述的就是两类funarg问题 —— 取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。

为了解决上述问题，就引入了 闭包的概念。

这里说明一下，开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，甚至理解成只有匿名函数才能是闭包。

再说一下，因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。
ECMAScript中，闭包指的是：

从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
从实践角度：以下函数才算是闭包：
即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
在代码中引用了自由变量

顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：

闭包还有另外一个非常重要的应用 —— 延迟调用：

var a = 10;
setTimeout(function () {
  alert(a); // 10, after one second
}, 1000);

还可以创建封装的作用域来隐藏辅助对象：

var foo = {};

// 初始化
(function (object) {

  var x = 10;

  object.getX = function _getX() {
    return x;
  };

})(foo);

alert(foo.getX()); // 获得闭包 &quot;x&quot; – 10
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是tom大叔的JavaScript系列的读书观后感&quot;&gt;&lt;a href=&quot;#今天要分享的内容是tom大叔的JavaScript系列的读书观后感&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是tom大叔的JavaScript系
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>adSense试试看</title>
    <link href="http://ghohankawk.github.io/2017/06/09/adSense/"/>
    <id>http://ghohankawk.github.io/2017/06/09/adSense/</id>
    <published>2017-06-09T04:13:09.827Z</published>
    <updated>2017-06-09T04:18:04.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是adSense"><a href="#今天要分享的内容是adSense" class="headerlink" title="今天要分享的内容是adSense"></a>今天要分享的内容是adSense</h1><h1 id="最近老大让弄广告"><a href="#最近老大让弄广告" class="headerlink" title="最近老大让弄广告"></a>最近老大让弄广告</h1><p>既然自己都在做这个东西，何不在自己的网站里面引进一下，试试看，效果如何</p>
<h1 id="后续再加统计"><a href="#后续再加统计" class="headerlink" title="后续再加统计"></a>后续再加统计</h1><p>暂时留个坑</p>
<h1 id="高考终于结束了，老弟也解放了，-｡･∀･-ﾉﾞ嗨的和同学聚会去了"><a href="#高考终于结束了，老弟也解放了，-｡･∀･-ﾉﾞ嗨的和同学聚会去了" class="headerlink" title="高考终于结束了，老弟也解放了，(｡･∀･)ﾉﾞ嗨的和同学聚会去了"></a>高考终于结束了，老弟也解放了，(｡･∀･)ﾉﾞ嗨的和同学聚会去了</h1><h1 id="晚上又能回家了，离得近，就是这点方便"><a href="#晚上又能回家了，离得近，就是这点方便" class="headerlink" title="晚上又能回家了，离得近，就是这点方便"></a>晚上又能回家了，离得近，就是这点方便</h1><p>为天下的学子庆祝一下，一图胜前言<br><img src="http://img1.gtimg.com/gamezone/pics/hv1/56/203/1857/120803246.jpg" alt=""></p>
<h1 id="恭喜表哥要订婚了"><a href="#恭喜表哥要订婚了" class="headerlink" title="恭喜表哥要订婚了"></a>恭喜表哥要订婚了</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是adSense&quot;&gt;&lt;a href=&quot;#今天要分享的内容是adSense&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是adSense&quot;&gt;&lt;/a&gt;今天要分享的内容是adSense&lt;/h1&gt;&lt;h1 id=&quot;最近老大让弄广告&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写在高考前，对弟弟的祝福</title>
    <link href="http://ghohankawk.github.io/2017/06/06/before-gaokao/"/>
    <id>http://ghohankawk.github.io/2017/06/06/before-gaokao/</id>
    <published>2017-06-06T11:49:16.524Z</published>
    <updated>2017-06-06T12:04:47.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随便写点"><a href="#随便写点" class="headerlink" title="随便写点"></a>随便写点</h1><p>记得十年前，这个时候，已经进入了考场，转眼，十年都过去了</p>
<h1 id="有首歌叫十年"><a href="#有首歌叫十年" class="headerlink" title="有首歌叫十年"></a>有首歌叫十年</h1><p>确实，十年之前，你不认识我，我不认识你</p>
<h1 id="每个人都需要经历这个坎"><a href="#每个人都需要经历这个坎" class="headerlink" title="每个人都需要经历这个坎"></a>每个人都需要经历这个坎</h1><p>谁都替代不了，可能有些人比较顺利的迈过去了，而有些人很难</p>
<p>这个事情，说重要，它确认重要，足以改变人的一生命运</p>
<p>不重要，也不过是一场考试而已，在人生的旅途中，只是一个章节而已</p>
<h1 id="我只想说，"><a href="#我只想说，" class="headerlink" title="我只想说，"></a>我只想说，</h1><p>认真对待，在正确的年龄做正确的事情，就足矣了</p>
<p>不过结果如何，你老爸老妈，都在等你回家吃饭</p>
<p>老哥，也祝福你，十年寒窗，加油，上图吧</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63198678_d0361387025dac92a6181c21104178c2" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63198678" target="_blank">米娜桑~高考加油！  (<em>ﾟ▽ﾟ</em>)</a> by <a href="https://www.pixiv.net/member.php?id=14531483" target="_blank">KoinKoni</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;随便写点&quot;&gt;&lt;a href=&quot;#随便写点&quot; class=&quot;headerlink&quot; title=&quot;随便写点&quot;&gt;&lt;/a&gt;随便写点&lt;/h1&gt;&lt;p&gt;记得十年前，这个时候，已经进入了考场，转眼，十年都过去了&lt;/p&gt;
&lt;h1 id=&quot;有首歌叫十年&quot;&gt;&lt;a href=&quot;#有首歌
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于log4j的使用说明</title>
    <link href="http://ghohankawk.github.io/2017/06/06/log4j/"/>
    <id>http://ghohankawk.github.io/2017/06/06/log4j/</id>
    <published>2017-06-06T10:58:35.396Z</published>
    <updated>2017-06-06T11:40:08.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是log4j的使用。"><a href="#今天要分享的内容是log4j的使用。" class="headerlink" title="今天要分享的内容是log4j的使用。"></a>今天要分享的内容是log4j的使用。</h1><p>每个系统都有日志记录，而多数都是用的log4j，以为会配置了，懂了，发现还是有些细节的问题，要问，说不上来</p>
<h1 id="先来直接看配置吧和测试用例吧"><a href="#先来直接看配置吧和测试用例吧" class="headerlink" title="先来直接看配置吧和测试用例吧"></a>先来直接看配置吧和测试用例吧</h1><p>jar包的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- log4j support --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2.17&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>log4j.properties文件如下，放在你的web的resource下面，推荐maven标准工程来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">### 设置###</div><div class="line">log4j.rootLogger = DEBUG,stdout,D,E</div><div class="line"></div><div class="line">log4j.logger.A=DEBUG, stdout</div><div class="line">log4j.logger.A.B=INFO, stdout  </div><div class="line"></div><div class="line">### 输出信息到控制抬 ###</div><div class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</div><div class="line">log4j.appender.stdout.Target = System.out</div><div class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</div><div class="line"></div><div class="line">### 输出DEBUG 级别以上的日志到=D://logs/error.log ###</div><div class="line">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</div><div class="line">log4j.appender.D.File = D://logs/log.log</div><div class="line">log4j.appender.D.Append = true</div><div class="line">log4j.appender.D.Threshold = DEBUG</div><div class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</div><div class="line"></div><div class="line">### 输出ERROR 级别以上的日志到=D://logs/error.log ###</div><div class="line">log4j.appender.E = org.apache.log4j.DailyRollingFileAppender</div><div class="line">log4j.appender.E.File =D://logs/error.log</div><div class="line">log4j.appender.E.Append = true</div><div class="line">log4j.appender.E.Threshold = ERROR</div><div class="line">log4j.appender.E.layout = org.apache.log4j.PatternLayout</div><div class="line">log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</div></pre></td></tr></table></figure></p>
<p>测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import org.apache.log4j.Logger;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-06 18:32</div><div class="line"> */</div><div class="line">public class log4jTtest &#123;</div><div class="line">    private static Logger logger = Logger.getLogger(log4jTtest.class);</div><div class="line">    private static Logger loggerA = Logger.getLogger(&quot;A&quot;);</div><div class="line">    private static Logger loggerA_B = Logger.getLogger(&quot;A.B&quot;);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        // 记录debug级别的信息</div><div class="line">        logger.debug(&quot;This is debug message.&quot;);</div><div class="line">        // 记录info级别的信息</div><div class="line">        logger.info(&quot;This is info message.&quot;);</div><div class="line">        // 记录error级别的信息</div><div class="line">        logger.error(&quot;This is error message.&quot;);</div><div class="line"></div><div class="line">        loggerA_B.info(&quot;repeat three times in console&quot;);</div><div class="line">        loggerA.info(&quot;repeat two times in console&quot;);</div><div class="line">        logger.info(&quot;repeat one times in console&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="注意上面的输出结果，你知道输出啥内容，则，就真正理解了"><a href="#注意上面的输出结果，你知道输出啥内容，则，就真正理解了" class="headerlink" title="注意上面的输出结果，你知道输出啥内容，则，就真正理解了"></a>注意上面的输出结果，你知道输出啥内容，则，就真正理解了</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[DEBUG] 2017-06-06 19:05:03,477 method:log4jTtest.main(log4jTtest.java:18)</div><div class="line">This is debug message.</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:20)</div><div class="line">This is info message.</div><div class="line">[ERROR] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:22)</div><div class="line">This is error message.</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)</div><div class="line">repeat three times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)</div><div class="line">repeat three times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,479 method:log4jTtest.main(log4jTtest.java:24)</div><div class="line">repeat three times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:25)</div><div class="line">repeat two times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:25)</div><div class="line">repeat two times in console</div><div class="line">[INFO ] 2017-06-06 19:05:03,480 method:log4jTtest.main(log4jTtest.java:26)</div><div class="line">repeat one times in console</div></pre></td></tr></table></figure>
<h1 id="问题如下"><a href="#问题如下" class="headerlink" title="问题如下"></a>问题如下</h1><ol>
<li>前面的三个输出，不用解释，都明白为啥</li>
<li>为啥那个loggerA_B，输出了三次，而loggerA输出了二次，logger输出了一次？</li>
</ol>
<h1 id="log4j几个重要的概念"><a href="#log4j几个重要的概念" class="headerlink" title="log4j几个重要的概念"></a>log4j几个重要的概念</h1><ul>
<li>logger组件<ol>
<li>简单的说，它就是决定了应用程序中，哪些代码哪些地方，有可能输出日志</li>
<li>这也就是为什么，每个类里面上来，就是，logger的初始化，它决定了这个类有资格输出日志</li>
<li>首先Log4J中总是存在一个rootLogger，即使没有显示配置也是存在的，并且默认输出级别为DEBUG。</li>
<li>Log4J中的层次是用’.’来分隔的，如log4j.logger.com.example.test，这里并不是说log4j.logger后面一定是具体的包名乃至类名，</li>
</ol>
</li>
<li>appender组件<ol>
<li>输出地，也就是你的日志想输出到哪里，把上面的logger里面的日志</li>
<li>再简单点，就是输出到控制台和文件里面，也就是上面的配置stdout和D和E</li>
<li>这个需要和下面的这个概念配合</li>
</ol>
</li>
<li>输出控制的概念<ol>
<li>Log4j默认把日志信息分为五个等级  all&lt;debug &lt; info &lt; warn &lt; error &lt; fatal&lt;off</li>
<li>只有大于设置的级别，才会打印日志，低于则忽略</li>
<li>log4j.appender.threshold=ERROR，这种配置用于控制，一个appender的输出级别</li>
</ol>
</li>
<li>继承的概念<ol>
<li>log4j.rootLogger=DEBUG, Console</li>
<li>log4j.logger.A=DEBUG, Console</li>
<li>log4j.logger.A.B=INFO, Console</li>
<li>A.B继承A，再继承最顶级的root</li>
<li>Log4j是根据Log的名字来判断继承关系的</li>
</ol>
</li>
</ul>
<h1 id="来解释一下，上面的输出结果"><a href="#来解释一下，上面的输出结果" class="headerlink" title="来解释一下，上面的输出结果"></a>来解释一下，上面的输出结果</h1><ol>
<li>首先是，debug，info和error前三个日志输出，它们的logger是log4jTtest.class初始化的，继承根logger，因此就是debug级别，同时因为还有D和E的两个appender，所以你在d盘可以看到，有一个info的文件还有一个error的文件，这个日志输出没问题</li>
<li>然后就是解释那重复的三个，因为loggerA_B，它是根据A.B这个参数初始化的，是有继承的，满足A.B的info级别的日志输出，必然满足A的logger的日志输出，当然还有默认的根输出，因此三次</li>
<li>而那个两次的，它的logger是loggerA，继承于根，因此，info的时候，它本身输出一次，根也输出一次，就是两次了。</li>
<li>最后一个，用的是默认的根，当然，只能输出一次了</li>
</ol>
<h1 id="问题来了，怎么避免重复，因为继承父的logger？"><a href="#问题来了，怎么避免重复，因为继承父的logger？" class="headerlink" title="问题来了，怎么避免重复，因为继承父的logger？"></a>问题来了，怎么避免重复，因为继承父的logger？</h1><pre><code>log4j.additivity.A.B=false
logger A.B的日志仅会输出到自己Console中，不会继承任何父logger的appender。
</code></pre><p> 就加上面的这句，就解决了问题</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前反反复复看了很多次，关于日志log4j的配置，每次看完以为会了，但是到了项目里面，总是不知道，自己有时候打印的日志到底跑哪里去了，或者去哪里看？<br>总结其原因就是，对于细节没有掌握理解到位，比如就是这个logger的概念，如果你真正的明白了，就知道了</p>
<p>谁能产生日志？logger</p>
<p>日志放哪里？appender</p>
<p>什么级别的日志才会输出？日志级别</p>
<p>他们是相互独立的组件，单独配置，又是相互配合，一起使用的，n*m的这种概念</p>
<p>因此上面的配置文件，一个logger可以对应多个appender，而appender之间又是彼此独立的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是log4j的使用。&quot;&gt;&lt;a href=&quot;#今天要分享的内容是log4j的使用。&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是log4j的使用。&quot;&gt;&lt;/a&gt;今天要分享的内容是log4j的使用。&lt;/h1&gt;&lt;p&gt;每个系统都有
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>六一儿童节快乐（补）</title>
    <link href="http://ghohankawk.github.io/2017/06/02/liuyi/"/>
    <id>http://ghohankawk.github.io/2017/06/02/liuyi/</id>
    <published>2017-06-02T09:45:21.639Z</published>
    <updated>2017-06-02T09:47:39.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="昨天这么重要的节日忘记了"><a href="#昨天这么重要的节日忘记了" class="headerlink" title="昨天这么重要的节日忘记了"></a>昨天这么重要的节日忘记了</h1><p>今天专程来补图，喵帕斯~<br>祝天下所有的大小朋友，儿童节快乐~<br><img src="http://img.ngacn.cc/attachments/mon_201706/01/-9lddQ13m-9na1KxT1kSgl-d8.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;昨天这么重要的节日忘记了&quot;&gt;&lt;a href=&quot;#昨天这么重要的节日忘记了&quot; class=&quot;headerlink&quot; title=&quot;昨天这么重要的节日忘记了&quot;&gt;&lt;/a&gt;昨天这么重要的节日忘记了&lt;/h1&gt;&lt;p&gt;今天专程来补图，喵帕斯~&lt;br&gt;祝天下所有的大小朋友，儿童节
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中的pattern和matcher的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/02/java-match/"/>
    <id>http://ghohankawk.github.io/2017/06/02/java-match/</id>
    <published>2017-06-02T08:53:23.377Z</published>
    <updated>2017-06-02T09:24:24.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java语言中的pattern和matcher的用法"><a href="#今天要分享的内容是java语言中的pattern和matcher的用法" class="headerlink" title="今天要分享的内容是java语言中的pattern和matcher的用法"></a>今天要分享的内容是java语言中的pattern和matcher的用法</h1><p>java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。<br>它包括两个类：Pattern和Matcher Pattern 一个Pattern是一个正则表达式经编译后的表现模式。<br>Matcher 一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。<br>首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，<br>然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。</p>
<h1 id="先理解捕获组的概念"><a href="#先理解捕获组的概念" class="headerlink" title="先理解捕获组的概念"></a>先理解捕获组的概念</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">捕获组可以通过从左到右计算其开括号来编号，编号是从1 开始的。</div><div class="line">例如，在表达式 ((A)(B(C)))中，存在四个这样的组：</div><div class="line">1        ((A)(B(C)))</div><div class="line">2        (A)</div><div class="line">3        (B(C))</div><div class="line">4        (C)</div><div class="line"></div><div class="line">组0始终代表整个表达式。</div></pre></td></tr></table></figure>
<h1 id="详解Pattern类"><a href="#详解Pattern类" class="headerlink" title="详解Pattern类"></a>详解Pattern类</h1><pre><code>Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, 
Java代码示例: 
Pattern p=Pattern.compile(&quot;\\w+&quot;); 
p.pattern();//返回 \w+ 
</code></pre><h1 id="详解Matcher类"><a href="#详解Matcher类" class="headerlink" title="详解Matcher类"></a>详解Matcher类</h1><pre><code>说了这么多,终于轮到Matcher类登场了,Pattern.matcher(CharSequence input)返回一个Matcher对象.
Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例. 
Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持. 
Java代码示例: 

Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;22bb23&quot;); 
m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 
</code></pre><h1 id="注意看下面这个例子，pattern方法返回的值"><a href="#注意看下面这个例子，pattern方法返回的值" class="headerlink" title="注意看下面这个例子，pattern方法返回的值"></a>注意看下面这个例子，pattern方法返回的值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import java.util.regex.Matcher;</div><div class="line">import java.util.regex.Pattern;</div><div class="line"></div><div class="line">public class StringPattern &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Pattern p = Pattern.compile(&quot;\\d+&quot;);</div><div class="line">        Matcher m = p.matcher(&quot;22bb23&quot;);</div><div class="line">        Pattern pattern = m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的</div><div class="line">        String pattern1 = pattern.pattern();</div><div class="line">        System.out.println(pattern1);//\d+</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Matcher-matches-Matcher-lookingAt-Matcher-find-区别"><a href="#Matcher-matches-Matcher-lookingAt-Matcher-find-区别" class="headerlink" title="Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()区别"></a>Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()区别</h1><ol>
<li>Matcher类提供三个匹配操作方法,三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回false<br>matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true </li>
<li>lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true </li>
<li>find()对字符串进行匹配,匹配到的字符串可以在任何位置. </li>
</ol>
<h1 id="Mathcer-start-Matcher-end-Matcher-group"><a href="#Mathcer-start-Matcher-end-Matcher-group" class="headerlink" title="Mathcer.start()/ Matcher.end()/ Matcher.group()"></a>Mathcer.start()/ Matcher.end()/ Matcher.group()</h1><ol>
<li>当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息. </li>
<li>start()返回匹配到的子字符串在字符串中的索引位置. </li>
<li>end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. </li>
<li>group()返回匹配到的子字符串 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.regex.Matcher;</div><div class="line">import java.util.regex.Pattern;</div><div class="line"></div><div class="line">public class StringPattern &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Pattern p=Pattern.compile(&quot;([a-z]+)(\\d+)&quot;);</div><div class="line">        Matcher m=p.matcher(&quot;aaa2223bb&quot;);</div><div class="line">        System.out.println(m.find());   //匹配aaa2223</div><div class="line"></div><div class="line">        System.out.println(m.groupCount());  //返回2,因为有2组</div><div class="line">        System.out.println(m.start(1));   //返回0 返回第一组匹配到的子字符串在字符串中的索引号</div><div class="line">        System.out.println(m.start(2));   //返回3</div><div class="line">        System.out.println(m.end(1));   //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置.</div><div class="line">        System.out.println(m.end(2));   //返回7</div><div class="line">        System.out.println(m.group(1));   //返回aaa,返回第一组匹配到的子字符串</div><div class="line">        System.out.println(m.group(2));;   //返回2223,返回第二组匹配到的子字符串</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="find比较特殊，特此说明"><a href="#find比较特殊，特此说明" class="headerlink" title="find比较特殊，特此说明"></a>find比较特殊，特此说明</h1><p>find</p>
<ol>
<li>public boolean find()尝试查找与该模式匹配的输入序列的下一个子序列。<br>此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。<br>如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。  </li>
<li>返回：<br>当且仅当输入序列的子序列匹配此匹配器的模式时才返回 true。</li>
</ol>
<p>因此有下面这种，循环find的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import java.util.regex.Matcher;</div><div class="line">import java.util.regex.Pattern;</div><div class="line"></div><div class="line">public class StringPattern &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Pattern p=Pattern.compile(&quot;\\d+&quot;);</div><div class="line">        Matcher m=p.matcher(&quot;我的QQ是:123 我的电话是:456 我的邮箱是:789@aaa.com&quot;);</div><div class="line">        while(m.find()) &#123;</div><div class="line">            System.out.println(m.group());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="最后强调"><a href="#最后强调" class="headerlink" title="最后强调"></a>最后强调</h1><p>现在大家应该知道,每次执行匹配操作后start(),end(),group()三个方法的值都会改变,改变成匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息.<br>注意:只有当匹配操作成功,才可以使用start(),end(),group()三个方法,否则会抛出java.lang.IllegalStateException,也就是当matches(),lookingAt(),find()其中任意一个方法返回true时,才可以使用.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java语言中的pattern和matcher的用法&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java语言中的pattern和matcher的用法&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java语言中的patte
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中的replace和replaceAll的区别</title>
    <link href="http://ghohankawk.github.io/2017/06/02/java-replace/"/>
    <id>http://ghohankawk.github.io/2017/06/02/java-replace/</id>
    <published>2017-06-02T07:59:53.019Z</published>
    <updated>2017-06-02T08:11:00.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java语言中的replace的用法"><a href="#今天要分享的内容是java语言中的replace的用法" class="headerlink" title="今天要分享的内容是java语言中的replace的用法"></a>今天要分享的内容是java语言中的replace的用法</h1><h1 id="测试用例如下"><a href="#测试用例如下" class="headerlink" title="测试用例如下"></a>测试用例如下</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class StringReplaceTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        String src = new String("aabbccdd333ee");</div><div class="line">        System.out.println(src.replace("3", "f"));</div><div class="line">        System.out.println(src.replace('3', 'f'));</div><div class="line">        System.out.println(src.replaceAll("\\d", "ff"));</div><div class="line">        System.out.println(src.replaceAll("a", "f"));</div><div class="line">        System.out.println(src.replaceFirst("\\d", "ff"));</div><div class="line">        System.out.println(src.replaceFirst("4", "ff"));</div><div class="line">        System.out.println("\\");</div><div class="line">        System.out.println("\\\\");</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><ol>
<li>aabbccddfffee</li>
<li>aabbccddffffffee</li>
<li>ffbbccdd333ee</li>
<li>aabbccddff33ee</li>
<li>aabbccdd333ee</li>
<li>\</li>
<li>\\</li>
</ol>
<h1 id="解释如下"><a href="#解释如下" class="headerlink" title="解释如下"></a>解释如下</h1><ul>
<li>replace的参数是char和CharSequence,即可以支持字符的替换,也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串); </li>
<li>replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\d”, “*”)把一个字符串所有的数字字符都换成星号; </li>
</ul>
<p><pre><br>相同点是都是全部替换,即把源字符串中的某一字符或字符串全部换成指定的字符或字符串,如果只想替换第一次出现的,可以使用 replaceFirst(),这个方法也是基于规则表达式的替换,但与replaceAll()不同的是,只替换第一次出现的字符串;<br>另外,如果replaceAll()和replaceFirst()所用的参数据不是基于规则表达式的,则与replace()替换字符串的效果是一样的,即这两者也支持字符串的操作;<br>还有一点注意:执行了替换操作后,源字符串的内容是没有发生改变的<br></pre></p>
<h1 id="最后讲一个关于斜杠的问题"><a href="#最后讲一个关于斜杠的问题" class="headerlink" title="最后讲一个关于斜杠的问题"></a>最后讲一个关于斜杠的问题</h1><pre><code>&apos;\&apos;在java中是一个转义字符，所以需要用两个代表一个。例如System.out.println( &quot;\\&quot; ) ;只打印出一个&quot;\&quot;。但是&apos;\&apos;也是正则表达式中的转义字符（replaceAll 的参数就是正则表达式），需要用两个代表一个。所以：\\\\被java转换成\\,\\又被正则表达式转换成\。 
</code></pre><ol>
<li>CODE: \\\\ </li>
<li>Java: \\ </li>
<li>Regex: \ </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java语言中的replace的用法&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java语言中的replace的用法&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java语言中的replace的用法&quot;&gt;&lt;/a&gt;今天要分享
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis学习系列之——介绍篇</title>
    <link href="http://ghohankawk.github.io/2017/06/02/redis-jieshao/"/>
    <id>http://ghohankawk.github.io/2017/06/02/redis-jieshao/</id>
    <published>2017-06-02T05:42:48.686Z</published>
    <updated>2017-06-02T05:58:20.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是redis背景介绍"><a href="#今天要分享的内容是redis背景介绍" class="headerlink" title="今天要分享的内容是redis背景介绍"></a>今天要分享的内容是redis背景介绍</h1><h1 id="Redis-背景介绍"><a href="#Redis-背景介绍" class="headerlink" title="Redis 背景介绍"></a>Redis 背景介绍</h1><ul>
<li><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p>
</li>
<li><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
</li>
<li>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</li>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h1 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h1><ul>
<li><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
</li>
<li><p>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p>
</li>
<li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。<h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</li>
</ul>
<ol>
<li>String（字符串）<br>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。<br>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</li>
</ol>
<p>注意：一个键最大能存储512MB。</p>
<ol>
<li>Hash（哈希）<br>Redis hash 是一个键值对集合。</li>
</ol>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
<ol>
<li>List（列表）<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</li>
</ol>
<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<ol>
<li>Set（集合）<br>Redis的Set是string类型的无序集合。</li>
</ol>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<ol>
<li>zset(sorted set：有序集合)<br>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是redis背景介绍&quot;&gt;&lt;a href=&quot;#今天要分享的内容是redis背景介绍&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是redis背景介绍&quot;&gt;&lt;/a&gt;今天要分享的内容是redis背景介绍&lt;/h1&gt;&lt;h1 id=&quot;R
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis学习系列之——安装篇</title>
    <link href="http://ghohankawk.github.io/2017/06/01/redis-anzhuang/"/>
    <id>http://ghohankawk.github.io/2017/06/01/redis-anzhuang/</id>
    <published>2017-06-01T07:04:04.246Z</published>
    <updated>2017-06-01T07:10:07.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是redis的使用安装篇"><a href="#今天要分享的内容是redis的使用安装篇" class="headerlink" title="今天要分享的内容是redis的使用安装篇"></a>今天要分享的内容是redis的使用安装篇</h1><p>这里主要分享，Windows下的安装使用，其他的系统，自己找</p>
<h1 id="Window-下安装"><a href="#Window-下安装" class="headerlink" title="Window 下安装"></a>Window 下安装</h1><p><img src="http://www.runoob.com/wp-content/uploads/2014/11/3B8D633F-14CE-42E3-B174-FCCD48B11FF3.jpg" alt=""><br>下载地址：<a href="https://github.com/MSOpenTech/redis/releases。" target="_blank" rel="external">https://github.com/MSOpenTech/redis/releases。</a><br>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。</p>
<h1 id="安装步骤二，启动服务器"><a href="#安装步骤二，启动服务器" class="headerlink" title="安装步骤二，启动服务器"></a>安装步骤二，启动服务器</h1><p>打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.windows.conf 。<br>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：<br><img src="http://www.runoob.com/wp-content/uploads/2014/11/redis-install1.png" alt=""></p>
<h1 id="安装步骤三，启动客户端"><a href="#安装步骤三，启动客户端" class="headerlink" title="安装步骤三，启动客户端"></a>安装步骤三，启动客户端</h1><p>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。<br>切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。<br>设置键值对 set myKey abc<br>取出键值对 get myKey<br><img src="http://www.runoob.com/wp-content/uploads/2014/11/redis-install2.jpg" alt=""></p>
<p>顺便附带一个<a href="http://www.runoob.com/redis/redis-install.html" target="_blank" rel="external">菜鸟redis教程传送门</a></p>
<h1 id="最后强调一句，默认的数据是存储在db0里面"><a href="#最后强调一句，默认的数据是存储在db0里面" class="headerlink" title="最后强调一句，默认的数据是存储在db0里面"></a>最后强调一句，默认的数据是存储在db0里面</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是redis的使用安装篇&quot;&gt;&lt;a href=&quot;#今天要分享的内容是redis的使用安装篇&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是redis的使用安装篇&quot;&gt;&lt;/a&gt;今天要分享的内容是redis的使用安装篇&lt;/h1&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客文章模板</title>
    <link href="http://ghohankawk.github.io/2017/05/27/article/"/>
    <id>http://ghohankawk.github.io/2017/05/27/article/</id>
    <published>2017-05-27T06:02:34.814Z</published>
    <updated>2017-05-27T06:59:20.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是。。。"><a href="#今天要分享的内容是。。。" class="headerlink" title="今天要分享的内容是。。。"></a>今天要分享的内容是。。。</h1><p>xxxxxxxxxx</p>
<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>正常说明，要干什么，再加一个链接按钮 <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">xxx</a>. </p>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><ul>
<li>第一点好处</li>
<li>第一点好处</li>
<li>第一点好处</li>
</ul>
<h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><pre><code>tab键，直接加底色，正常说明，顺便加一个加黑。
</code></pre><p>   <strong>好黑啊</strong></p>
<h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><p>想要加一张图片<br><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png" alt=""></p>
<h1 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h1><p>想要加原生代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">            body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125;</div><div class="line">            ul&#123;list-style: none;&#125;</div><div class="line">            img&#123;border:none;vertical-align: middle;&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="第六部分"><a href="#第六部分" class="headerlink" title="第六部分"></a>第六部分</h1><p>相要加个高亮<br>执行命令：<code>npm install marked</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是。。。&quot;&gt;&lt;a href=&quot;#今天要分享的内容是。。。&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是。。。&quot;&gt;&lt;/a&gt;今天要分享的内容是。。。&lt;/h1&gt;&lt;p&gt;xxxxxxxxxx&lt;/p&gt;
&lt;h1 id=&quot;第一部分&quot;&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图片测试</title>
    <link href="http://ghohankawk.github.io/2017/05/27/picTest/"/>
    <id>http://ghohankawk.github.io/2017/05/27/picTest/</id>
    <published>2017-05-27T05:24:03.940Z</published>
    <updated>2017-05-27T05:27:28.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这里面没内容"><a href="#这里面没内容" class="headerlink" title="这里面没内容"></a>这里面没内容</h1><p>   只是为了测试一下，图片能否直接展示在首页里面<br><img src="http://kenshin.hk/blog/movie/2016/kiminona/kiminona-02.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这里面没内容&quot;&gt;&lt;a href=&quot;#这里面没内容&quot; class=&quot;headerlink&quot; title=&quot;这里面没内容&quot;&gt;&lt;/a&gt;这里面没内容&lt;/h1&gt;&lt;p&gt;   只是为了测试一下，图片能否直接展示在首页里面&lt;br&gt;&lt;img src=&quot;http://kenshin.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新博客版本升级</title>
    <link href="http://ghohankawk.github.io/2017/05/27/newBlog/"/>
    <id>http://ghohankawk.github.io/2017/05/27/newBlog/</id>
    <published>2017-05-27T04:50:09.050Z</published>
    <updated>2017-05-27T05:21:56.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为啥升级博客？"><a href="#为啥升级博客？" class="headerlink" title="为啥升级博客？"></a>为啥升级博客？</h1><p>   之前做完了ppt分享后，威哥触动了我，重新维护改造一下，以后记录工作生活点滴，今天庆祝复活了   </p>
<h1 id="升级说明"><a href="#升级说明" class="headerlink" title="升级说明"></a>升级说明</h1><p>   主要有以下的改造   </p>
<ul>
<li>外观改造，去掉了那些无用的评论，统计，因为实际确实没啥人关注</li>
<li>改完了外观清晰，简单的界面，去掉了那些标签功能，只要是方便自己看</li>
<li>另外增加了，关于我的部分，按照个人的喜好进行了改编</li>
</ul>
<p>对了，明天就要端午节放假啦，提前来张图庆祝一下，请收下</p>
<p><script src="https://source.pixiv.net/source/embed.js" data-id="63090620_47249e28b3d64ab364938a0dfbb60af5" data-size="large" data-border="on" charset="utf-8"></script><noscript><p><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63090620" target="_blank">端午節ちまき</a> by <a href="https://www.pixiv.net/member.php?id=266106" target="_blank">兔姬</a> on <a href="https://www.pixiv.net/" target="_blank">pixiv</a></p></noscript></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为啥升级博客？&quot;&gt;&lt;a href=&quot;#为啥升级博客？&quot; class=&quot;headerlink&quot; title=&quot;为啥升级博客？&quot;&gt;&lt;/a&gt;为啥升级博客？&lt;/h1&gt;&lt;p&gt;   之前做完了ppt分享后，威哥触动了我，重新维护改造一下，以后记录工作生活点滴，今天庆祝复活了 
    
    </summary>
    
    
  </entry>
  
</feed>
