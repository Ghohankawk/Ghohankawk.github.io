<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闻道</title>
  <subtitle>闻道有先后，术业有专攻，如是而已</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ghohankawk.github.io/"/>
  <updated>2017-12-20T07:56:40.905Z</updated>
  <id>http://ghohankawk.github.io/</id>
  
  <author>
    <name>ghohank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于在linux上你必须要学的常用命令</title>
    <link href="http://ghohankawk.github.io/2017/12/20/linux-usual-cmd/"/>
    <id>http://ghohankawk.github.io/2017/12/20/linux-usual-cmd/</id>
    <published>2017-12-20T06:52:02.609Z</published>
    <updated>2017-12-20T07:56:40.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？"><a href="#从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？" class="headerlink" title="从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？"></a>从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？</h1><p>随便测试分享几张图片</p>
<ol>
<li>首页这里不会具体介绍所有命令的相关选项参数，因为实在是记不住，有些也没必要</li>
<li>会根据linux每日一命令的系列中，选出每个命令，最常用的组合，方便日常使用</li>
<li>这个里面提供了最日常用的，建议每个人按照自己的需求，也进行总结分享</li>
</ol>
<p>那么今天就把终端上回用到的命令，分享一下，大家可以参考一下<br><a id="more"></a> </p>
<h1 id="全部都记在keep上了，直接上图"><a href="#全部都记在keep上了，直接上图" class="headerlink" title="全部都记在keep上了，直接上图"></a>全部都记在keep上了，直接上图</h1><p><img src="https://i.loli.net/2017/12/20/5a3a15990f0cb.png" alt="linux命令1.png"><br>分隔线———————–<br><img src="https://i.loli.net/2017/12/20/5a3a161e21584.png" alt="linux命令2.png"><br>分隔线———————–<br><img src="https://i.loli.net/2017/12/20/5a3a1705476f5.png" alt="linux命令3.png"><br>分隔线———————–<br><img src="https://i.loli.net/2017/12/20/5a3a17050119b.png" alt="linux命令4.png"><br>分隔线———————–<br><img src="https://i.loli.net/2017/12/20/5a3a1704c6bfa.png" alt="linux命令5.png"><br>分隔线———————–<br><img src="https://i.loli.net/2017/12/20/5a3a1703a7d7c.png" alt="linux命令6.png"></p>
<h1 id="以上就是分享的全部，你要是不知道linux有啥命令？命令能干啥？或者只知道，ls-cd-这种参数不会加的，那么看一下这组分享，应该有帮助。"><a href="#以上就是分享的全部，你要是不知道linux有啥命令？命令能干啥？或者只知道，ls-cd-这种参数不会加的，那么看一下这组分享，应该有帮助。" class="headerlink" title="以上就是分享的全部，你要是不知道linux有啥命令？命令能干啥？或者只知道，ls,cd,这种参数不会加的，那么看一下这组分享，应该有帮助。"></a>以上就是分享的全部，你要是不知道linux有啥命令？命令能干啥？或者只知道，ls,cd,这种参数不会加的，那么看一下这组分享，应该有帮助。</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？&quot;&gt;&lt;a href=&quot;#从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？&quot; class=&quot;headerlink&quot; title=&quot;从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？&quot;&gt;&lt;/a&gt;从终端ssh到linux上，是否不知道该敲什么命令，想看什么？或者用linux的命令能干啥？是否有这种困惑？&lt;/h1&gt;&lt;p&gt;随便测试分享几张图片&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首页这里不会具体介绍所有命令的相关选项参数，因为实在是记不住，有些也没必要&lt;/li&gt;
&lt;li&gt;会根据linux每日一命令的系列中，选出每个命令，最常用的组合，方便日常使用&lt;/li&gt;
&lt;li&gt;这个里面提供了最日常用的，建议每个人按照自己的需求，也进行总结分享&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么今天就把终端上回用到的命令，分享一下，大家可以参考一下&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于sublime的不可不知的快捷键</title>
    <link href="http://ghohankawk.github.io/2017/11/03/shotcut-sublime/"/>
    <id>http://ghohankawk.github.io/2017/11/03/shotcut-sublime/</id>
    <published>2017-11-03T07:37:39.920Z</published>
    <updated>2017-11-13T09:17:17.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么能快速的使用sublime？"><a href="#怎么能快速的使用sublime？" class="headerlink" title="怎么能快速的使用sublime？"></a>怎么能快速的使用sublime？</h1><p>推荐，少女终末旅行，和上个季的，来自深渊的风格，不错</p>
<p>前端那么多的ide，我还是最喜欢sublime，因为确实简洁，启动速度超快，其他的都太重了<br><a id="more"></a> </p>
<h1 id="总的分为几个部分"><a href="#总的分为几个部分" class="headerlink" title="总的分为几个部分"></a>总的分为几个部分</h1><table>
<thead>
<tr>
<th>选择类</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。</td>
</tr>
<tr>
<td>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。</td>
</tr>
<tr>
<td>Ctrl+L  选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。</td>
</tr>
<tr>
<td>Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。</td>
</tr>
<tr>
<td>Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。</td>
</tr>
<tr>
<td>Ctrl+M 光标移动至括号内结束或开始的位置。</td>
</tr>
<tr>
<td>Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。</td>
</tr>
<tr>
<td>Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。</td>
</tr>
<tr>
<td>Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。</td>
</tr>
<tr>
<td>Ctrl+Shift+] 选中代码，按下快捷键，展开代码。</td>
</tr>
<tr>
<td>Ctrl+K+0 展开所有折叠代码。</td>
</tr>
<tr>
<td>Ctrl+→ 向右单位性地移动光标，快速移动光标。</td>
</tr>
<tr>
<td>Ctrl+← 向左单位性地移动光标，快速移动光标。</td>
</tr>
<tr>
<td>shift+↑向上选中多行。</td>
</tr>
<tr>
<td>shift+↓向下选中多行。</td>
</tr>
<tr>
<td>Shift+← 向左选中文本。</td>
</tr>
<tr>
<td>Shift+→ 向右选中文本。</td>
</tr>
<tr>
<td>Ctrl+Shift+← 向左单位性地选中文本。</td>
</tr>
<tr>
<td>Ctrl+Shift+→ 向右单位性地选中文本。</td>
</tr>
<tr>
<td>Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。</td>
</tr>
<tr>
<td>Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。</td>
</tr>
<tr>
<td>Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。</td>
</tr>
<tr>
<td>Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>编辑类</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。</td>
</tr>
<tr>
<td>Ctrl+Shift+D 复制光标所在整行，插入到下一行。</td>
</tr>
<tr>
<td>Tab 向右缩进。只对光标后（或者选中的）的代码有效</td>
</tr>
<tr>
<td>Shift+Tab 向左缩进。</td>
</tr>
<tr>
<td>Ctrl+[ 向左缩进。对整行有效</td>
</tr>
<tr>
<td>Ctrl+]向右缩进。对整行有效</td>
</tr>
<tr>
<td>Ctrl+K+K 从光标处开始删除代码至行尾。按住Ctrl，按两次K。</td>
</tr>
<tr>
<td>Ctrl+Shift+K 删除整行。</td>
</tr>
<tr>
<td>Ctrl+/ 注释单行。</td>
</tr>
<tr>
<td>Ctrl+Shift+/注释多行。</td>
</tr>
<tr>
<td>Ctrl+K+U 转换大写。</td>
</tr>
<tr>
<td>Ctrl+K+L转换小写。</td>
</tr>
<tr>
<td>Ctrl+Z撤销。</td>
</tr>
<tr>
<td>Ctrl+Y恢复撤销。</td>
</tr>
<tr>
<td>Ctrl+U软撤销，感觉和 Gtrl+Z 一样。</td>
</tr>
<tr>
<td>Ctrl+F2设置书签，F2切换书签</td>
</tr>
<tr>
<td>Ctrl+T左右字母互换。</td>
</tr>
<tr>
<td>F6单词检测拼写</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>搜索类</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+F 打开底部搜索框，查找关键字。</td>
</tr>
<tr>
<td>Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。</td>
</tr>
<tr>
<td>Ctrl+P 打开搜索框。举个栗子：</td>
</tr>
<tr>
<td>1、输入当前项目中的文件名，快速搜索文件，</td>
</tr>
<tr>
<td>2、输入@和关键字，查找文件中函数名，</td>
</tr>
<tr>
<td>3、输入：和数字，跳转到文件中该行代码，</td>
</tr>
<tr>
<td>4、输入#和关键字，查找变量名。</td>
</tr>
<tr>
<td>Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。</td>
</tr>
<tr>
<td>Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。</td>
</tr>
<tr>
<td>Ctrl+：打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。</td>
</tr>
<tr>
<td>Esc退出光标多行选择，退出搜索框，命令框等。</td>
</tr>
<tr>
<td>Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime  text或插件的功能，例如使用package安装插件。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>显示类</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。</td>
</tr>
<tr>
<td>Ctrl+PageDown 向左切换当前窗口的标签页。</td>
</tr>
<tr>
<td>Ctrl+PageUp 向右切换当前窗口的标签页。</td>
</tr>
<tr>
<td>Alt+Shift+1  窗口分屏，恢复默认1屏（非小键盘的数字）</td>
</tr>
<tr>
<td>Alt+Shift+2 左右分屏-2列</td>
</tr>
<tr>
<td>Alt+Shift+3 左右分屏-3列</td>
</tr>
<tr>
<td>Alt+Shift+4 左右分屏-4列</td>
</tr>
<tr>
<td>Alt+Shift+5 等分4屏</td>
</tr>
<tr>
<td>Alt+Shift+8 垂直分屏-2屏</td>
</tr>
<tr>
<td>Alt+Shift+9 垂直分屏-3屏</td>
</tr>
<tr>
<td>Ctrl+K+B 开启/关闭侧边栏。</td>
</tr>
<tr>
<td>F11 全屏模式</td>
</tr>
<tr>
<td>Shift+F11 免打扰模式</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>多重选择（Multi-Selection）</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>多重选择功能允许在页面中同时存在多个光标，让很多本来需要正则表达式、高级搜索和替换才能完成的任务也变得游刃有余了。</td>
</tr>
<tr>
<td>激活多重选择的方法有两几种：</td>
</tr>
<tr>
<td>1. 按住 Ctrl 然后在页面中希望中现光标的位置点击。(头部插入)</td>
</tr>
<tr>
<td>选择数行文本，然后按下 Shift + Ctrl + L。(尾部插入)</td>
</tr>
<tr>
<td>通过反复按下 Ctrl + D 可将全文中与光标当前所在位置的词相同的词逐一加入选择，而直接按下</td>
</tr>
<tr>
<td>2. Alt+F3即可一次性选择所有相同的词。按下鼠标中键来进行垂直方向的纵列选择，也可以进入多重编辑状态。</td>
</tr>
<tr>
<td>1方法适合不多，可以数的过来的那种选择，通过鼠标</td>
</tr>
<tr>
<td>2方法适合大量的全局替换编辑</td>
</tr>
</tbody>
</table>
<h1 id="以上就是分享的全部，基本可以应对日常的使用。"><a href="#以上就是分享的全部，基本可以应对日常的使用。" class="headerlink" title=" 以上就是分享的全部，基本可以应对日常的使用。"></a> 以上就是分享的全部，基本可以应对日常的使用。</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;怎么能快速的使用sublime？&quot;&gt;&lt;a href=&quot;#怎么能快速的使用sublime？&quot; class=&quot;headerlink&quot; title=&quot;怎么能快速的使用sublime？&quot;&gt;&lt;/a&gt;怎么能快速的使用sublime？&lt;/h1&gt;&lt;p&gt;推荐，少女终末旅行，和上个季的，来自深渊的风格，不错&lt;/p&gt;
&lt;p&gt;前端那么多的ide，我还是最喜欢sublime，因为确实简洁，启动速度超快，其他的都太重了&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于vim的不可不知的快捷键</title>
    <link href="http://ghohankawk.github.io/2017/11/03/shotcut-vim/"/>
    <id>http://ghohankawk.github.io/2017/11/03/shotcut-vim/</id>
    <published>2017-11-03T07:37:31.010Z</published>
    <updated>2017-11-17T04:26:34.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux上使用vi编辑查看文本总是记不住那些按键？"><a href="#linux上使用vi编辑查看文本总是记不住那些按键？" class="headerlink" title="linux上使用vi编辑查看文本总是记不住那些按键？"></a>linux上使用vi编辑查看文本总是记不住那些按键？</h1><p>先看几张，可爱的娜娜奇</p>
<p>对于开发人员，linux是不陌生的吧，尤其是写动态页面的，经常要登录linux上面查看，文件是否更新，以及更新的内容变化<br>因此今天总结一下，这些常用的快捷键<br><a id="more"></a> </p>
<h1 id="总的分为几个部分"><a href="#总的分为几个部分" class="headerlink" title="总的分为几个部分"></a>总的分为几个部分</h1><table>
<thead>
<tr>
<th>光标移动</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>h,j,k,l（替代箭头）</td>
<td>h表示往左，j表示往下，k表示往上，l表示往右</td>
</tr>
<tr>
<td>Ctrl+f（翻页）</td>
<td>下一页</td>
</tr>
<tr>
<td>Ctrl+b（翻页）</td>
<td>上一页</td>
</tr>
<tr>
<td>w, e, W, E（单词内部跳）</td>
<td>跳到单词的后面，小写包括标点</td>
</tr>
<tr>
<td>b, B（单词之间跳）</td>
<td>以单词为单位往前跳动光标，小写包含标点</td>
</tr>
<tr>
<td>0（好像和下面的^没有啥区别，效果一样）</td>
<td>跳到本行的头部</td>
</tr>
<tr>
<td>O（插入一行）</td>
<td>开启新的一行</td>
</tr>
<tr>
<td>^</td>
<td>一行的开始</td>
</tr>
<tr>
<td>$</td>
<td>一行的结尾</td>
</tr>
<tr>
<td>gg</td>
<td>文档的第一行</td>
</tr>
<tr>
<td>[N]G</td>
<td>文档的第N行（G 是最后一行），如：27+shift+g</td>
</tr>
<tr>
<td>插入</td>
<td></td>
</tr>
<tr>
<td>i（小写相对于光标）</td>
<td>插入到光标前面</td>
</tr>
<tr>
<td>I（大写相对于行）</td>
<td>插入到行的开始位置</td>
</tr>
<tr>
<td>a</td>
<td>插入到光标的后面</td>
</tr>
<tr>
<td>A</td>
<td>插入到行的最后位置</td>
</tr>
<tr>
<td>o（相对于行）</td>
<td>在当前光标的下方插入新一行</td>
</tr>
<tr>
<td>O(Shift+o)</td>
<td>在当前光标的上方插入新一行</td>
</tr>
<tr>
<td>Esc</td>
<td>关闭插入模式</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>编辑</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>r（单个字符replace）</td>
<td>在插入模式替换光标所在的一个字符</td>
</tr>
<tr>
<td>J(行)</td>
<td>合并下一行到上一行</td>
</tr>
<tr>
<td>s（单个字符删除进入插入状态）</td>
<td>删除光标所在的一个字符, 光标还在当行</td>
</tr>
<tr>
<td>S（整行删除进入插入状态）</td>
<td>删除光标所在的一行，光标还在当行，不同于dd</td>
</tr>
<tr>
<td>u（类别ctrl+z）</td>
<td>撤销上一步操作</td>
</tr>
<tr>
<td>ctrl+r（类别ctrl+y）</td>
<td>恢复上一步操作</td>
</tr>
<tr>
<td>.(记忆)</td>
<td>重复最后一个命令</td>
</tr>
<tr>
<td>~（单个字符）</td>
<td>变换为大写</td>
</tr>
<tr>
<td>[N]&gt;&gt;</td>
<td>一行或N行往右移动一个tab</td>
</tr>
<tr>
<td>[N]&lt;&lt;</td>
<td>一行或N行往左移动一个tab</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>退出</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>关闭（前提是，执行了已保存）</td>
</tr>
<tr>
<td>:q!</td>
<td>（强行退，丢失内容）强制关，不保存</td>
</tr>
<tr>
<td>:wq,:x,ZZ(这三个是等价的)</td>
<td>保存并关闭</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>查找和搜索</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>/pattern(最常用的)</td>
<td>搜索（非插入模式) ，支持正则</td>
</tr>
<tr>
<td>?pattern（区别是按n的时候，方向不一样）</td>
<td>往前搜索</td>
</tr>
<tr>
<td>n</td>
<td>光标到达搜索结果的前一个目标</td>
</tr>
<tr>
<td>N</td>
<td>光标到达搜索结果的后一个目标</td>
</tr>
<tr>
<td>r+p（上面编辑r的用法）</td>
<td>将光标之后的字符替换为字母p</td>
</tr>
<tr>
<td>:s/word/replace（相对于行）</td>
<td>光标所在行的第一个 word 替换为replace。</td>
</tr>
<tr>
<td>:%s/word/replace/（相对于全局）</td>
<td>全文查找 word 并替换为 replace</td>
</tr>
<tr>
<td>:1,50s/word/replace/（指定范围内，也就是行）</td>
<td>在第1行和第50行之间（含）进行搜索和替换</td>
</tr>
<tr>
<td>:45s/word/replace/（固定行）</td>
<td>表示仅仅在第45行进行搜索和替换。而 1,$ 行号范围和 % 是等价的</td>
</tr>
<tr>
<td>:%s/^/ 要插入的字符串</td>
<td>每行开头插入字符串</td>
</tr>
<tr>
<td>:%s/$/要插入的字符串</td>
<td>每行结尾插入字符串</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>剪切，复制，粘贴</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>dd</td>
<td>删除一行，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>de</td>
<td>（不包含之后的空格）删除光标后的单词内容，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>dw</td>
<td>（包含空格）删除光标后的单词内容以及之后的空格，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>[N]dd</td>
<td>删除以当前行开始的n行</td>
</tr>
<tr>
<td>x</td>
<td>（单字符） 删除后一个字符</td>
</tr>
<tr>
<td>X</td>
<td>删除前一个字符</td>
</tr>
<tr>
<td>D</td>
<td>（区别在于光标不动，还在当前行，和dd相比）删除一行最后一个字符</td>
</tr>
<tr>
<td>[N]yy</td>
<td>复制一行或者N行</td>
</tr>
<tr>
<td>yw</td>
<td>（单词相对于）复制一个单词</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>窗口操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>:vsplit</td>
<td>水平方向分割出一个窗口</td>
</tr>
<tr>
<td>:split</td>
<td>垂直方向分割出一个窗口</td>
</tr>
<tr>
<td>:close</td>
<td>关闭窗口</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>切换窗口, h到左边窗口，j到下方窗口，k到上方窗口，l到右边窗口</td>
</tr>
</tbody>
</table>
<h1 id="以上就是分享的全部，有这6个方面的知识，基本可以应对日常的使用。"><a href="#以上就是分享的全部，有这6个方面的知识，基本可以应对日常的使用。" class="headerlink" title="以上就是分享的全部，有这6个方面的知识，基本可以应对日常的使用。"></a>以上就是分享的全部，有这6个方面的知识，基本可以应对日常的使用。</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;linux上使用vi编辑查看文本总是记不住那些按键？&quot;&gt;&lt;a href=&quot;#linux上使用vi编辑查看文本总是记不住那些按键？&quot; class=&quot;headerlink&quot; title=&quot;linux上使用vi编辑查看文本总是记不住那些按键？&quot;&gt;&lt;/a&gt;linux上使用vi编辑查看文本总是记不住那些按键？&lt;/h1&gt;&lt;p&gt;先看几张，可爱的娜娜奇&lt;/p&gt;
&lt;p&gt;对于开发人员，linux是不陌生的吧，尤其是写动态页面的，经常要登录linux上面查看，文件是否更新，以及更新的内容变化&lt;br&gt;因此今天总结一下，这些常用的快捷键&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6新特性概览总结</title>
    <link href="http://ghohankawk.github.io/2017/10/12/js-es6/"/>
    <id>http://ghohankawk.github.io/2017/10/12/js-es6/</id>
    <published>2017-10-12T06:41:14.840Z</published>
    <updated>2017-10-12T11:41:54.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是ES6？"><a href="#什么是ES6？" class="headerlink" title="什么是ES6？"></a>什么是ES6？</h1><p> ES6（ECMAScript 6 == ECMAScript2015）是即将到来的新版本JavaScript语言的标准，代号harmony,上一次标准的制订还是2009年出台的ES5。<br>大部分标准已经就绪，且各浏览器对ES6的支持也正在实现中。<br>目前想要运行ES6代码的话，可以用<a href="http://google.github.io/traceur-compiler/demo/repl.html#" target="_blank" rel="external">google/traceur-compiler</a>将代码转译。<br>当然，并不是所有ES6新特性都被实现了，有一些还是无法测试的。<br>如果你还不知道什么是ES6的话，它是JavaScript一个新的实现，几个新特性。</p>
<p>首先，一个简单的JavaScript时间线，不了解历史的人也无法创造历史。</p>
<ul>
<li>1995年：JavaScript以LiveScript之名诞生</li>
<li>1997年：ECMAScript标准确立</li>
<li>1999年：ES3发布，IE5非常生气</li>
<li>2000年-2005年：XMLHttpRequest，熟知为AJAX，在如Outlook Web Access(2002)、Oddpost(2002)、Gmail(2004)、Google Maps(2005)中得到了广泛的应用</li>
<li>2009年：ES5发布（这是我们目前用的最多的版本），带来了forEach / Object.keys / Object.create（特地为Douglas Crockford所造，JSON标准创建者） ，还有JSON标准。</li>
</ul>
<p>历史课上完了，我们回来讲编程。<br><a id="more"></a> </p>
<h1 id="箭头操作符是什么？"><a href="#箭头操作符是什么？" class="headerlink" title="箭头操作符是什么？"></a>箭头操作符是什么？</h1><p>其实就是类比java中的lambda表达式，ES6中新增的箭头操作符=&gt;便有异曲同工之妙。它简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。<br>使用箭头函数需要注意：</p>
<ul>
<li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。</li>
</ul>
<pre><code>var f = () =&gt; 5;
// 等同于
var f = function (){ return 5 };

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
    return num1 + num2;
};
</code></pre><p>##为什么有？<br>JS中回调是经常的事，而一般回调又以匿名函数的形式出现，每次都需要写一个function，甚是繁琐。当引入箭头操作符后可以方便地写回调了，去掉繁琐的function   </p>
<pre><code>var array = [1, 2, 3];
//传统写法
array.forEach(function(v, i, a) {
    console.log(v);
});
//ES6
array.forEach(v =&gt; console.log(v));
</code></pre><h1 id="class是什么？"><a href="#class是什么？" class="headerlink" title="class是什么？"></a>class是什么？</h1><p>ES6中添加了对类的支持，引入了class关键字（其实class在JavaScript中一直是保留字，目的就是考虑到可能在以后的新版本中会用到，现在终于派上用场了）。JS本身就是面向对象的，ES6中提供的类实际上只是JS原型模式的包装。现在提供原生的class支持后，对象的创建，继承更加直观了，并且父类方法的调用，实例化，静态方法和构造函数等概念都更加形象化。</p>
<pre><code>//类的定义
class Animal {
    //ES6中新型构造器
    constructor(name) {
        this.name = name;
    }
    //实例方法
    sayName() {
        console.log(&apos;My name is &apos;+this.name);
    }
}
//类的继承
class Programmer extends Animal {
    constructor(name) {
        //直接调用父类构造器进行初始化
        super(name);
    }
    program() {
        console.log(&quot;I&apos;m coding...&quot;);
    }
}
//测试我们的类
var animal=new Animal(&apos;dummy&apos;),
wayou=new Programmer(&apos;wayou&apos;);
animal.sayName();//输出 ‘My name is dummy’
wayou.sayName();//输出 ‘My name is wayou’
wayou.program();//输出 ‘I&apos;m coding...’
</code></pre><h1 id="增强的对象字面量是什么？"><a href="#增强的对象字面量是什么？" class="headerlink" title="增强的对象字面量是什么？"></a>增强的对象字面量是什么？</h1><p>对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在：</p>
<ul>
<li>可以在对象字面量里面定义原型</li>
<li>定义方法可以不用function关键字</li>
<li>直接调用父类方法  </li>
</ul>
<pre><code>var Person = {
  name: &apos;张三&apos;,

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log(&apos;我的名字是&apos;, this.name); }
};

var lastWord = &quot;last word&quot;;

var a = {
    &quot;first word&quot;: &quot;hello&quot;,
    [lastWord]: &quot;world&quot;
};

//表达式属性
a[&quot;first word&quot;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&quot;last word&quot;] // &quot;world&quot;


//通过对象字面量创建对象
var human = {
    breathe() {
        console.log(&apos;breathing...&apos;);
    }
};
var worker = {
    __proto__: human, //设置此对象的原型为human,相当于继承human
    company: &apos;freelancer&apos;,
    work() {
        console.log(&apos;working...&apos;);
    }
};
human.breathe();//输出 ‘breathing...’
//调用继承来的breathe方法
worker.breathe();//输出 ‘breathing...’
</code></pre><h1 id="字符串模板是什么？"><a href="#字符串模板是什么？" class="headerlink" title="字符串模板是什么？"></a>字符串模板是什么？</h1><p>ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。</p>
<pre><code>//产生一个随机数
var num=Math.random();
//将这个数字输出到console
console.log(`your num is ${num}`);

`In JavaScript&apos;\n&apos; is a line-feed.`

// 多行字符串
console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
var name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`

//反斜杠转义
var greeting = `\`Yo\` World!`;

//对象属性
var obj = {x: 1, y: 2};
console.log(`${obj.x + obj.y}`)

//函数调用
function fn() {
  return &quot;Hello World&quot;;
}
console.log(`foo ${fn()} bar`);
</code></pre><h1 id="自动解析是什么？"><a href="#自动解析是什么？" class="headerlink" title="自动解析是什么？"></a>自动解析是什么？</h1><p>自动解析数组或对象中的值。比如若一个函数要返回多个值，常规的做法是返回一个对象，将每个值做为这个对象的属性返回。但在ES6中，利用解构这一特性，可以直接返回一个数组，然后数组中的值会自动被解析到对应接收该值的变量中。</p>
<pre><code>var [x,y]=getVal(),//函数返回值的解构
    [name,,age]=[&apos;wayou&apos;,&apos;male&apos;,&apos;secrect&apos;];//数组解构

function getVal() {
    return [ 1, 2 ];
}

console.log(&apos;x:&apos;+x+&apos;, y:&apos;+y);//输出：x:1, y:2 
console.log(&apos;name:&apos;+name+&apos;, age:&apos;+age);//输出： name:wayou, age:secrect 

let [foo, [[bar], baz]] = [1, [[2], 3]];
let [x, y=&apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;
let [a, b, c] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);

var { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };

var {x, y = 5} = {x: 1};
console.log(x, y) // 1, 5

let { log, sin, cos } = Math;

function move({x=0, y=0} = {}) {
  return [x, y];
}

move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><h1 id="参数默认值，不定参数，拓展参数是什么？"><a href="#参数默认值，不定参数，拓展参数是什么？" class="headerlink" title="参数默认值，不定参数，拓展参数是什么？"></a>参数默认值，不定参数，拓展参数是什么？</h1><ul>
<li>默认参数值（默认赋值）</li>
</ul>
<p>现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。</p>
<pre><code>function sayHello(name){
    //传统的指定默认参数的方式
    var name=name||&apos;dude&apos;;
    console.log(&apos;Hello &apos;+name);
}
//运用ES6的默认参数
function sayHello2(name=&apos;dude&apos;){
    console.log(`Hello ${name}`);
}
sayHello();//输出：Hello dude
sayHello(&apos;Wayou&apos;);//输出：Hello Wayou
sayHello2();//输出：Hello dude
sayHello2(&apos;Wayou&apos;);//输出：Hello Wayou
</code></pre><ul>
<li>不定参数（三个点参数）</li>
</ul>
<p>不定参数是在函数中使用命名参数同时接收不定数量的未命名参数。这只是一种语法糖，在以前的JavaScript代码中我们可以通过arguments变量来达到这一目的。不定参数的格式是三个句点后跟代表所有不定参数的变量名。比如下面这个例子中，…x代表了所有传入add函数的参数。</p>
<pre><code>//将所有参数相加的函数
function add(...x){
    return x.reduce((m,n)=&gt;m+n);
}
//传递任意个数的参数
console.log(add(1,2,3));//输出：6
console.log(add(1,2,3,4,5));//输出：15
</code></pre><ul>
<li>拓展参数（三个点数组参数）</li>
</ul>
<p>拓展参数则是另一种形式的语法糖，它允许传递数组或者类数组直接做为函数的参数而不用通过apply。   </p>
<pre><code>var people=[&apos;Wayou&apos;,&apos;John&apos;,&apos;Sherlock&apos;];
//sayHello函数本来接收三个单独的参数人一，人二和人三
function sayHello(people1,people2,people3){
    console.log(`Hello ${people1},${people2},${people3}`);
}
//但是我们将一个数组以拓展参数的形式传递，它能很好地映射到每个单独的参数
sayHello(...people);//输出：Hello Wayou,John,Sherlock 

//而在以前，如果需要传递数组当参数，我们需要使用函数的apply方法
sayHello.apply(null,people);//输出：Hello Wayou,John,Sherlock 
</code></pre><h1 id="let与const-关键字是什么？"><a href="#let与const-关键字是什么？" class="headerlink" title="let与const 关键字是什么？"></a>let与const 关键字是什么？</h1><p>可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。const则很直观，用来定义常量，即无法被更改值的变量。</p>
<pre><code>for (let i=0;i&lt;2;i++)console.log(i);//输出: 0,1
console.log(i);//输出：undefined,严格模式下会报错
对比之前的var
for (var i=0;i&lt;2;i++)console.log(i);//输出: 0,1
console.log(i);//输出：2
</code></pre><h1 id="for-of-值遍历是什么？"><a href="#for-of-值遍历是什么？" class="headerlink" title="for of 值遍历是什么？"></a>for of 值遍历是什么？</h1><p>我们都知道for in 循环用于遍历数组，类数组或对象，ES6中新引入的for of循环功能相似，不同的是每次循环它提供的不是序号而是值。</p>
<pre><code>var someArray = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ];

for (v of someArray) {
    console.log(v);//输出 a,b,c
}
for of 和 for in 的对比区别
for (v in someArray) {
        console.log(v);//输出 0,1,2
}

var a1 = [1, 2, 3, 4];
var a2 = [for (i of a1) i * 2];
a2 // [2, 4, 6, 8]

var years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];
[for (year of years) if (year &gt; 2000 &amp;&amp; year &lt; 2010) year];
</code></pre><h1 id="模块是什么？（关键字module）"><a href="#模块是什么？（关键字module）" class="headerlink" title="模块是什么？（关键字module）"></a>模块是什么？（关键字module）</h1><p>在ES6标准中，JavaScript原生支持module了。这种将JS代码分割成不同功能的小块进行化的概念是在一些三方规范中流行起来的，比如CommonJS和AMD模式。</p>
<p>将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用    </p>
<pre><code>// point.js
module &quot;point&quot; {
    export class Point {
        constructor (x, y) {
            public x = x;
            public y = y;
        }
    }
}

// myapp.js
//声明引用的模块
module point from &quot;/point.js&quot;;
//这里可以看出，尽管声明了引用的模块，还是可以通过指定需要的部分进行导入
import Point from &quot;point&quot;;

var origin = new Point(0, 0);
console.log(origin);

module命令可以取代import语句，达到整体输入模块的作用。
// circle.js
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}

// main.js
module circle from &apos;circle&apos;;

console.log(&quot;圆面积：&quot; + circle.area(4));
console.log(&quot;圆周长：&quot; + circle.circumference(14));


export default命令定义模块的默认方法。
// export-default.js
export default function () {
    console.log(&apos;foo&apos;);
}

// import-default.js
import customName from &apos;./export-default&apos;;
customName(); // &apos;foo&apos;
</code></pre><h1 id="Map，Set-和-WeakMap，WeakSet是什么？（新增数据类型）"><a href="#Map，Set-和-WeakMap，WeakSet是什么？（新增数据类型）" class="headerlink" title="Map，Set 和 WeakMap，WeakSet是什么？（新增数据类型）"></a>Map，Set 和 WeakMap，WeakSet是什么？（新增数据类型）</h1><p>这些是新加的集合类型，提供了更加方便的获取属性值的方法，不用像以前一样用hasOwnProperty来检查某个属性是属于原型链上的呢还是当前对象的。同时，在进行属性值添加与获取时有专门的get，set 方法。<br>类比和java中的类型</p>
<pre><code>// Sets
var s = new Set();
s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);
s.size === 2;
s.has(&quot;hello&quot;) === true;

// Maps
var m = new Map();
m.set(&quot;hello&quot;, 42);
m.set(s, 34);
m.get(s) == 34;

// Weak Maps
var wm = new WeakMap();
wm.set(s, { extra: 42 });
wm.size === undefined

// Weak Sets
var ws = new WeakSet();
ws.add({ data: 42 });//因为添加到ws的这个临时对象没有其他变量引用它，所以ws不会保存它的值，也就是说这次添加其实没有意思
</code></pre><p>有时候我们会把对象作为一个对象的键用来存放属性值，普通集合类型比如简单对象会阻止垃圾回收器对这些作为属性键存在的对象的回收，有造成内存泄漏的危险。而WeakMap,WeakSet则更加安全些，这些作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉<br>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受原始类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制，有助于防止内存泄漏。</p>
<p>Map结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br>注意Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。只有对同一个对象的引用，Map结构才将其视为同一个键</p>
<pre><code>var map = new Map();

map.set([&apos;a&apos;], 555); 
map.get([&apos;a&apos;]) // undefined
</code></pre><h1 id="Promises是什么？（异步处理，ajax）"><a href="#Promises是什么？（异步处理，ajax）" class="headerlink" title="Promises是什么？（异步处理，ajax）"></a>Promises是什么？（异步处理，ajax）</h1><p>Promises是处理异步操作的一种模式，之前在很多三方库中有实现，比如jQuery的deferred 对象。当你发起一个异步请求，并绑定了.when(), .done()等事件处理程序时，其实就是在应用promise模式。</p>
<pre><code>//创建promise
var promise = new Promise(function(resolve, reject) {
    // 进行一些异步或耗时操作
    if ( /*如果成功 */ ) {
        resolve(&quot;Stuff worked!&quot;);
    } else {
        reject(Error(&quot;It broke&quot;));
    }
});
//绑定处理程序
promise.then(function(result) {
    //promise成功的话会执行这里
    console.log(result); // &quot;Stuff worked!&quot;
}, function(err) {
    //promise失败会执行这里
    console.log(err); // Error: &quot;It broke&quot;
});
</code></pre><h1 id="Proxies是什么？（设计模式）"><a href="#Proxies是什么？（设计模式）" class="headerlink" title="Proxies是什么？（设计模式）"></a>Proxies是什么？（设计模式）</h1><p>Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。</p>
<p>Proxy用于修改某些操作的默认行为，等于在目标对象之前，架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。而Proxy.revocable()方法则返回一个可取消的Proxy实例。</p>
<pre><code>//定义被侦听的目标对象
var engineer = { name: &apos;Joe Sixpack&apos;, salary: 50 };
//定义处理程序
var interceptor = {
  set: function (receiver, property, value) {
    console.log(property, &apos;is changed to&apos;, value);
    receiver[property] = value;
  }
};
//创建代理以进行侦听
engineer = Proxy(engineer, interceptor);
//做一些改动来触发代理
engineer.salary = 60;//控制台输出：salary is changed to 60

var person = {
  name: &quot;张三&quot;
};

var proxy = new Proxy(person, {
    get: function(target, property) {
        return property in target ? target[property] : &quot;米有&quot;;
    }
});

proxy.name // &quot;张三&quot;
proxy.title // &quot;米有&quot;
</code></pre><p>对于处理程序，是在被侦听的对象身上发生了相应事件之后，处理程序里面的方法就会被调用，上面例子中我们设置了set的处理函数，表明，如果我们侦听的对象的属性被更改，也就是被set了，那这个处理程序就会被调用，同时通过参数能够得知是哪个属性被更改，更改为了什么值。</p>
<h1 id="Math，Number，String，Object-的新API是什么？"><a href="#Math，Number，String，Object-的新API是什么？" class="headerlink" title="Math，Number，String，Object 的新API是什么？"></a>Math，Number，String，Object 的新API是什么？</h1><pre><code>Number.EPSILON
Number.isInteger(Infinity) // false
Number.isNaN(&quot;NaN&quot;) // false

Math.acosh(3) // 1.762747174039086
Math.hypot(3, 4) // 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2

&quot;abcde&quot;.contains(&quot;cd&quot;) // true
&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;

Array.from()：用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象
Array.from(document.querySelectorAll(&apos;*&apos;)) // Returns a real Array

Array.of()方法用于将一组值，转换为数组。弥补数组构造函数Array()的不足。
Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(7, 1) // [0,7,7]
[1,2,3].findIndex(x =&gt; x == 2) // 1
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;

Object.assign(Point, { origin: new Point(0,0) })

二进制和八进制数值的新的写法，分别用前缀0b和0o表示
0b111110111 === 503 // true
0o767 === 503 // true
</code></pre><h1 id="Symbols是什么？"><a href="#Symbols是什么？" class="headerlink" title="Symbols是什么？"></a>Symbols是什么？</h1><p>我们知道对象其实是键值对的集合，而键通常来说是字符串。而现在除了字符串外，我们还可以用symbol这种值来做为对象的键。Symbol是一种基本类型，像数字，字符串还有布尔一样，它不是一个对象。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。之后就可以用这个返回值做为对象的键了。Symbol还可以用来创建私有属性，外部无法直接访问由symbol做为键的属性值。</p>
<p>Symbol是一种新的原始数据类型，表示独一无二的ID，它通过Symbol函数生成。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。Symbol函数可以接受一个字符串作为参数，表示Symbol实例的名称。</p>
<pre><code>(function() {

  // 创建symbol
  var key = Symbol(&quot;key&quot;);

  function MyClass(privateData) {
    this[key] = privateData;
  }

  MyClass.prototype = {
    doStuff: function() {
      ... this[key] ...
    }
  };

})();

var c = new MyClass(&quot;hello&quot;)
c[&quot;key&quot;] === undefined//无法访问该属性，因为是私有的

var mySymbol = Symbol(&apos;Test&apos;);
mySymbol.name
// Test

// 有参数的情况
var s1 = Symbol(&quot;foo&quot;);
var s2 = Symbol(&quot;foo&quot;);

s1 === s2 // false

//不能与其他类型的值进行运算
var sym = Symbol(&apos;My symbol&apos;);
&apos;&apos; + sym
// TypeError: Cannot convert a Symbol value to a string

//可以转换为字符串
String(sym)
// &apos;Symbol(My symbol)&apos;
</code></pre><h1 id="Generator-函数是什么？-个人认为最不好理解的"><a href="#Generator-函数是什么？-个人认为最不好理解的" class="headerlink" title="Generator 函数是什么？(个人认为最不好理解的)"></a>Generator 函数是什么？(个人认为最不好理解的)</h1><p>Generator是一个普通函数，有两个特征：一是function命令与函数名之间有一个星号；二是函数体内部使用yield语句，定义遍历器的每个成员。</p>
<p>Generator可以理解成一个函数的内部状态的遍历器，每调用一次，函数的内部状态发生一次改变。换句话说，它就是一个改装了的 Iterator 遍历器，通过 yield 来增加一个 next() 节点。</p>
<p>先看一下Generator函数的完整作用： 用Generator函数定义helloWorldGenerator，它的遍历器有两个成员“hello”和“world”。当调用Generator函数的时候，该函数并不执行，而是返回一个遍历器（可以理解成暂停执行）。以后，每次调用这个遍历器的next方法，就从函数体的头部或者上一次停下来的地方开始执行（可以理解成恢复执行），直到遇到下一个yield语句为止。</p>
<p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。</p>
<pre><code>function *foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
</code></pre><h2 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h2><p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数会被当作上一个yield语句的返回值。这个功能有很重要的语法意义，Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。</p>
<pre><code>function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var it = foo(5);

it.next()
// { value:6, done:false }
it.next(12)
// { value:8, done:false }
it.next(13)
// { value:42, done:true }
先把这个例子理解了，再说
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是ES6？&quot;&gt;&lt;a href=&quot;#什么是ES6？&quot; class=&quot;headerlink&quot; title=&quot;什么是ES6？&quot;&gt;&lt;/a&gt;什么是ES6？&lt;/h1&gt;&lt;p&gt; ES6（ECMAScript 6 == ECMAScript2015）是即将到来的新版本JavaScript语言的标准，代号harmony,上一次标准的制订还是2009年出台的ES5。&lt;br&gt;大部分标准已经就绪，且各浏览器对ES6的支持也正在实现中。&lt;br&gt;目前想要运行ES6代码的话，可以用&lt;a href=&quot;http://google.github.io/traceur-compiler/demo/repl.html#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;google/traceur-compiler&lt;/a&gt;将代码转译。&lt;br&gt;当然，并不是所有ES6新特性都被实现了，有一些还是无法测试的。&lt;br&gt;如果你还不知道什么是ES6的话，它是JavaScript一个新的实现，几个新特性。&lt;/p&gt;
&lt;p&gt;首先，一个简单的JavaScript时间线，不了解历史的人也无法创造历史。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1995年：JavaScript以LiveScript之名诞生&lt;/li&gt;
&lt;li&gt;1997年：ECMAScript标准确立&lt;/li&gt;
&lt;li&gt;1999年：ES3发布，IE5非常生气&lt;/li&gt;
&lt;li&gt;2000年-2005年：XMLHttpRequest，熟知为AJAX，在如Outlook Web Access(2002)、Oddpost(2002)、Gmail(2004)、Google Maps(2005)中得到了广泛的应用&lt;/li&gt;
&lt;li&gt;2009年：ES5发布（这是我们目前用的最多的版本），带来了forEach / Object.keys / Object.create（特地为Douglas Crockford所造，JSON标准创建者） ，还有JSON标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;历史课上完了，我们回来讲编程。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于生命中最亲的人的离别</title>
    <link href="http://ghohankawk.github.io/2017/08/31/person-leave/"/>
    <id>http://ghohankawk.github.io/2017/08/31/person-leave/</id>
    <published>2017-08-31T07:20:27.651Z</published>
    <updated>2017-09-28T09:11:24.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是离别？"><a href="#什么是离别？" class="headerlink" title="什么是离别？"></a>什么是离别？</h1><p>离别是离开，不会再相见的意思。人要是真的走了，那么这辈子，就真的不会再见了。有些词，再也没有用武之地，<br>比如，爷爷，奶奶，而如今多了一个外婆。这些词的含义，也到此为止了。<br><a id="more"></a> </p>
<h1 id="生命又是什么？"><a href="#生命又是什么？" class="headerlink" title="生命又是什么？"></a>生命又是什么？</h1><p>生命就是从获得它的最开始，到最终的结束。会遇到各种各样的人，有对你好的，有对你亲的，在你的生命旅程中，陪伴着你一起走。</p>
<h1 id="什么又是最亲的人？"><a href="#什么又是最亲的人？" class="headerlink" title="什么又是最亲的人？"></a>什么又是最亲的人？</h1><p>在你生命中出现的，可能对你最好的人，也许是你妈，你爸，或者爷爷和奶奶，又或者是哥哥，姐姐。。。<br>总是会给你比其他人，更多的关注，更你更多的帮助，给你信任，给你支持。<br>在你困难的时候，最无助的时候，也是第一时间会想起ta们</p>
<h1 id="那么长大又是怎么回事？"><a href="#那么长大又是怎么回事？" class="headerlink" title="那么长大又是怎么回事？"></a>那么长大又是怎么回事？</h1><p>长大就是不断的从一个地方去到另外一个地方，渐渐的离开你最亲的人，从小时候的一直陪伴，到慢慢寒暑假可以在一起见两次，<br>到最后的，每年春节回去见一次。长大，就是慢慢的见面机会越来越少的意思。不再论时间，而是论次数。</p>
<h1 id="那么为什么要长大？"><a href="#那么为什么要长大？" class="headerlink" title="那么为什么要长大？"></a>那么为什么要长大？</h1><p>这个问题，就和人为什么会老，我一直都不理解。也不想去理解。</p>
<h1 id="那生命-最亲人-离别会怎么样？"><a href="#那生命-最亲人-离别会怎么样？" class="headerlink" title="那生命+最亲人+离别会怎么样？"></a>那生命+最亲人+离别会怎么样？</h1><p>我会想起，很小的时候，是从那个有ta的地方长大的，教我穿衣服，拿筷子，很多的第一次都是从那个时候开始的，因此，<br>我忘不了，那时候每年的新衣服都是ta买的，然后，从那个时候我就一直记得我的理想。</p>
<p>稍微长大了一点，哭着离开那个不舍得的地方，不管怎么样，那个时候，每年过寒假，就要回去，熟悉的环境，熟悉的人都在。<br>人总是不把目前的一些东西认为理所当然，可不知，有一天总会失去这种日常生活。</p>
<p>慢慢再大了一点，好像是有了自己的想法了，就渐渐不在有曾经的那种认识了，自以为长大了，什么都懂了，其实回过头来看自己什么也不懂。</p>
<p>忘不了，每年过年，给我压岁钱的时候，总是背着其他的孩子多给我一百，我一直攒着放在一个本子里面没动。</p>
<p>虽然从五台山跟着ta去过很多次了，曾经徒步走过，五个台，忘不了，那种辛苦，所以发誓下次再来的时候，一定要开着坚决不再走了。<br>现在回头看来，已经成为了宝贵的记忆。一起走过南山寺,龙泉寺，佛光寺，钻过佛母洞，一起住寺庙，吃斋饭，上早课，念经文</p>
<p>忘不了，ta曾说过，以后老了能走动的时候，还想去一趟五台山，我也记在了心里。<br>也就是从那个时候养成的生活习惯，一直保留到现在，我也会以后传承下去的。</p>
<p>人总是健忘的，容易忘记过去，忘记曾经的艰辛。</p>
<p>于是，又慢慢长大了一点，要出去读书，上学去了，真正的意义的远离了家乡，从时间变为了次数，一年两次的仅有的回家机会。</p>
<p>忘不了，大学入学那年，是ta买的送给我的第一个手机，虽然那个时候经济已经不如从前了，可是为了我，还是舍得</p>
<p>到后来，毕业了，工作了，慢慢的变为了一年春节的一次。剩给我们的时间真的不多了。</p>
<p>那年，我也是第一次，懂了，生老病死，这简简单单的四个字的含义，是如此的简单，如此的直白。</p>
<p>可能，你从小到现在，都没有感觉自己发生什么变化，可是，真实的是变化，发生在你身边，有些人不经意之间就老了。是如此的快，如此的猝不及防。</p>
<p>人生总是这么无奈，当你没有能力的时候，受别人的照顾，而你奋斗刚有能力的时候，照顾你的人却已经不在你身边了。</p>
<p>忘不了，原来今年夏天的那一面，居然是这辈子的最后一面，那时，还是好好的，可是，如今，</p>
<p>曾经那么坚强的人，为什么突然变得这么脆弱，说走就这么轻易离开了，</p>
<p>你在最后，在想什么，你又想说什么，我都不得而知了。</p>
<p>只是听到，最后说你，一呼一呼的，喘不上气，在等最后的人，也没有等到，我听了，眼泪情不自禁的掉了下来，控制不住自己。</p>
<p>这个根本不是我认识的熟悉的你，你在我从小的印象中从来都不是这样的，你到底是怎么了这两年来？</p>
<p>请你告诉我，为什么好人就不能长命百岁？</p>
<p>为了那些不争气的人，你总是替他们操碎了心，这下你好了，就不用管他们了。</p>
<p>对，你是解放了，不用再过问这些俗事了，也该好好休息一下了。</p>
<p>对不起，请你再等等我，从我出生到现在，陪伴了快三十年的时间，我马上回去，明天就回去看你，这点时间我想你是不会介意的吧，<br>你要是介意，请你告诉我。</p>
<p>请你原谅我的不坚强，我向你保证，这是最后一次流泪了。</p>
<p>所以，我想在你面前痛哭，看你今生的最后一眼，送你走完最后一程，我们来生再见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是离别？&quot;&gt;&lt;a href=&quot;#什么是离别？&quot; class=&quot;headerlink&quot; title=&quot;什么是离别？&quot;&gt;&lt;/a&gt;什么是离别？&lt;/h1&gt;&lt;p&gt;离别是离开，不会再相见的意思。人要是真的走了，那么这辈子，就真的不会再见了。有些词，再也没有用武之地，&lt;br&gt;比如，爷爷，奶奶，而如今多了一个外婆。这些词的含义，也到此为止了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何创建一个简单hello wolrd的amp网页？</title>
    <link href="http://ghohankawk.github.io/2017/08/28/amp-hello/"/>
    <id>http://ghohankawk.github.io/2017/08/28/amp-hello/</id>
    <published>2017-08-28T12:09:28.886Z</published>
    <updated>2017-08-29T06:52:28.618Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们说点什么呢？直接看下面的效果：</p>
<p><iframe width="100%" onload="this.height=window.getComputedStyle(this).width;" frameborder="0" src="/origin/helloAmp1.html"></iframe></p>
<p><iframe width="100%" onload="this.height=window.getComputedStyle(this).width;" frameborder="0" src="/origin/helloAmp2.html"></iframe><br><a id="more"></a> </p>
<h1 id="这是一个简单的AMP测试页面"><a href="#这是一个简单的AMP测试页面" class="headerlink" title="这是一个简单的AMP测试页面"></a>这是一个简单的AMP测试页面</h1><p>按照官网搭建的hello world，主要是amp的自己标签应用，明天继续高点事情 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们说点什么呢？直接看下面的效果：&lt;/p&gt;
&lt;p&gt;&lt;iframe width=&quot;100%&quot; onload=&quot;this.height=window.getComputedStyle(this).width;&quot; frameborder=&quot;0&quot; src=&quot;/origin/helloAmp1.html&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;&lt;iframe width=&quot;100%&quot; onload=&quot;this.height=window.getComputedStyle(this).width;&quot; frameborder=&quot;0&quot; src=&quot;/origin/helloAmp2.html&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Java中的编程规约</title>
    <link href="http://ghohankawk.github.io/2017/07/24/java-format/"/>
    <id>http://ghohankawk.github.io/2017/07/24/java-format/</id>
    <published>2017-07-24T09:19:13.306Z</published>
    <updated>2017-07-24T09:21:26.802Z</updated>
    
    <content type="html"><![CDATA[<p>今天要分享的内容是Java中的编程规约，之前看公司的这个java这部分都空中，就看到前端日志的阿里巴巴的开发手册，把我关注的地方总结了一下。</p>
<a id="more"></a> 
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#命名规约">命名规约</a></li>
<li><a href="#常量定义">常量定义</a></li>
<li><a href="#格式规约">格式规约</a></li>
<li><a href="#OOP规约">OOP规约</a></li>
<li><a href="#集合处理">集合处理</a></li>
<li><a href="#并发处理">并发处理</a></li>
<li><a href="#控制语句">控制语句</a></li>
<li><a href="#注释规约">注释规约</a></li>
<li><a href="#异常处理">异常处理</a></li>
<li><a href="#日志规约">日志规约</a></li>
<li><a href="#其它规约">其它规约</a></li>
</ul>
<h3 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h3><ul>
<li>【强制】所有编程相关命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</li>
</ul>
<pre><code>反例：    _name    /__name /    $Object    /    name_    /    name$    /    Object$
</code></pre><ul>
<li>【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式 也要避免采用。</li>
</ul>
<pre><code>反例：    DaZhePromotion [打折] / getPingfenByName() [评分] / int 变量 = 3;
正例：    ali / alibaba / taobao / cainiao / aliyun / youku / hangzhou 等国际通用的 名称，可视为英文。
</code></pre><ul>
<li>【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型 的相关命名）DO / DTO / VO / DAO 等。</li>
</ul>
<pre><code>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 
反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion
</code></pre><ul>
<li>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。</li>
</ul>
<pre><code>正例：    localValue / getHttpMessage() / inputUserId
</code></pre><ul>
<li>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 </li>
</ul>
<pre><code>正例：    MAX_STOCK_COUNT
反例：    MAX_COUNT
</code></pre><ul>
<li><p>【强制】抽象类命名使用 Abstract 或 Base 开头；</p>
<pre><code>异常类命名使用 Exception 结尾；
测试类命 名以它要测试的类的名称开始，以 Test 结尾。
</code></pre></li>
<li><p>【强制】中括号是数组类型的一部分，</p>
<pre><code>数组定义如下：String[]    args; 
反例：请勿使用 String args[]的方式来定义
</code></pre></li>
<li><p>【强制】POJO 类中的任何布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</p>
</li>
</ul>
<pre><code>反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出 异常。
</code></pre><ul>
<li>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。</li>
</ul>
<pre><code>正例： 应用工具类包名为 com.alibaba.mpp.util、类名为 MessageUtils（此规则参考 spring 的框架结构）
</code></pre><ul>
<li>【强制】杜绝完全不规范的缩写，避免望文不知义。 </li>
</ul>
<pre><code>反例：&lt;某业务代码&gt;AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。
</code></pre><ul>
<li><p>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。 </p>
<pre><code>正例：public class OrderFactory;
      public class LoginProxy; 
      public class ResourceObserver;
</code></pre></li>
<li><p>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。</p>
</li>
</ul>
<pre><code>正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = &quot;alibaba&quot;;
反例：接口方法定义：public abstract    void f();
说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默 认实现。
</code></pre><ul>
<li>接口和实现类的命名有两套规则：<ul>
<li>【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部 的实现类用 Impl 的后缀与接口区别。</li>
</ul>
</li>
</ul>
<pre><code>正例：CacheServiceImpl 实现 CacheService 接口。
</code></pre><ul>
<li>【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形 式）。</li>
</ul>
<pre><code>正例：AbstractTranslator 实现 Translatable。
</code></pre><ul>
<li><p>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。 说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 </p>
<pre><code>正例：枚举名字：DealStatusEnum；成员名称：SUCCESS / UNKOWN_REASON。 
</code></pre></li>
<li>【参考】各层命名规约：<ul>
<li>Service/DAO 层方法命名规约<br><em>获取单个对象的方法用 get 做前缀。
</em>获取多个对象的方法用 list 做前缀。<br><em>获取统计值的方法用 count 做前缀。
</em>插入的方法用 save（推荐）或 insert 做前缀。<br><em>删除的方法用 remove（推荐）或 delete 做前缀。 
</em>修改的方法用 update 做前缀。</li>
<li>领域模型命名规约<br><em>数据对象：xxxDO，xxx 即为数据表名。
</em>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br><em>展示对象：xxxVO，xxx 一般为网页名称。
</em>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li>
</ul>
</li>
</ul>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><ul>
<li>【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。 </li>
</ul>
<pre><code>反例：    String key=&quot;Id#taobao_&quot;+tradeId；
cache.put(key, value);
</code></pre><ul>
<li>【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。</li>
</ul>
<pre><code>说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?
</code></pre><ul>
<li><p>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存 相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。 说明：大而全的常量类，非得 ctrl+f 才定位到修改的常量，不利于理解，也不利于维护。</p>
</li>
<li><p>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包 内共享常量、类内共享常量。</p>
<ul>
<li>跨应用共享常量：放置在二方库中，通常是 client.jar 中的 const 目录下。 </li>
<li><p>应用内共享常量：放置在一方库的 modules 中的 const 目录下。</p>
<pre><code>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示 “是”的变量：
类 A 中：public static final String YES = &quot;yes&quot;; 类 B 中：public static final String YES = &quot;y&quot;;
 A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致产生线上问题。
</code></pre></li>
<li>子工程内部共享常量：即在当前子工程的 const 目录下。</li>
<li>包内共享常量：即在当前包下单独的 const 目录下。</li>
<li>类内共享常量：直接在类内部 private static final 定义。</li>
</ul>
</li>
<li><p>【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须 使用 Enum 类，下面正例中的数字就是延伸信息，表示星期几。</p>
</li>
</ul>
<pre><code>正例：public Enum{ MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}
</code></pre><h3 id="格式规约"><a href="#格式规约" class="headerlink" title="格式规约"></a>格式规约</h3><ul>
<li><p>【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果 是非空代码块则：</p>
<ul>
<li>左大括号前不换行。</li>
<li>左大括号后换行。</li>
<li>右大括号前换行。</li>
<li>右大括号后还有 else 等代码则不换行；表示终止右大括号后必须换行。</li>
</ul>
</li>
<li><p>【强制】 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空<br>格。 </p>
</li>
<li><p>【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。</p>
</li>
<li><p>【强制】任何运算符左右必须加一个空格。 说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p>
</li>
<li><p>【强制】代码块缩进 4 个空格，如果使用 tab 缩进，请设置成 1 个 tab 为 4 个空格。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void main(String args[]) &#123;</div><div class="line">// 缩进 4 个空格 </div><div class="line">    String say = &quot;hello&quot;;</div><div class="line">// 运算符的左右必须有一个空格 </div><div class="line">    int flag = 0;</div><div class="line">// 关键词 if 与括号之间必须有一个空格，括号内 f 与左括号，1 与右括号不需要空格 </div><div class="line">    if (flag == 0) &#123;</div><div class="line">        System.out.println(say);</div><div class="line">    &#125;</div><div class="line">// 左大括号前加空格且不换行；左大括号后换行 </div><div class="line">    if (flag == 1) &#123;</div><div class="line">        System.out.println(&quot;world&quot;);</div><div class="line">// 右大括号前换行，右大括号后有 else，不用换行</div><div class="line">    &#125; else &#123;</div><div class="line">        System.out.println(&quot;ok&quot;);</div><div class="line">// 右大括号做为结束，必须换行</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时，遵循如下原则：</p>
<ul>
<li>换行时相对上一行缩进 4 个空格。</li>
<li>运算符与下文一起换行。</li>
<li>方法调用的点符号与下文一起换行。</li>
<li>在多个参数超长，逗号后进行换行。</li>
<li>在括号前不要换行，见反例。 </li>
</ul>
</li>
</ul>
<pre><code>  正例：
StringBuffer sb = new StringBuffer();
//超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 s
b.append(&quot;zi&quot;).append(&quot;xin&quot;)…
      .append(&quot;huang&quot;);

反例：
StringBuffer sb = new StringBuffer();
//超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)…append
(&quot;huang&quot;);

//参数很多的方法调用也超过 120 个字符，逗号后才是换行处 method(args1, args2, args3, ...
, argsX);
</code></pre><ul>
<li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 </p>
<pre><code>正例：下例中实参的&quot;a&quot;,后边必须要有一个空格。
method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
</code></pre></li>
<li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。 </p>
<pre><code>正例：
int a = 3; 
long b = 4L; 
float c = 5F;
StringBuffer sb = new StringBuffer();
说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的 情况下，是一种累赘的事情。
</code></pre></li>
<li><p>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不 要使用 windows 格式。</p>
</li>
<li>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之 间插入一个空行。相同业务逻辑和语义之间不需要插入空行。 说明：没有必要插入多行空格进行隔开。<h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3></li>
<li>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。</li>
<li>【强制】所有的覆写方法，必须加@Override 注解。</li>
</ul>
<pre><code>反例：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编 译报错。
</code></pre><ul>
<li>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程） </li>
</ul>
<pre><code>正例：public User getUsers(String type, Integer... ids);
</code></pre><ul>
<li>【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接 口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</li>
<li>【强制】不能使用过时的类或方法。<br>说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该 使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那 么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</li>
<li>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 </li>
</ul>
<pre><code>正例：    &quot;test&quot;.equals(object);
反例：    object.equals(&quot;test&quot;);
说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）
</code></pre><ul>
<li>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之 外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方 法进行判断。</li>
<li>【强制】关于基本数据类型与包装数据类型的使用标准如下：<ul>
<li>所有的 POJO 类属性必须使用包装数据类型。</li>
<li>RPC 方法的返回值和参数必须使用包装数据类型。</li>
<li>所有的局部变量推荐使用基本数据类型。<br>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</li>
</ul>
</li>
</ul>
<pre><code>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。 
反例：某业务的交易报表上显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的
RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划 线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。
</code></pre><ul>
<li>【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。</li>
</ul>
<pre><code>反例：某业务的 DO 的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置 入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。
</code></pre><ul>
<li><p>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。<br>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>
</li>
<li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 </p>
</li>
<li><p>【强制】POJO 类必须写 toString 方法。使用工具类 source&gt; generate toString 时，如果继<br>承了另一个 POJO 类，注意在前面加一下 super.toString。 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排 查问题。</p>
</li>
<li><p>【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内 容的检查，否则会有抛 IndexOutOfBoundsException 的风险。<br>说明：</p>
<pre><code>String str = &quot;a,b,c,,&quot;; String[] ary = str.split(&quot;,&quot;);
//预期大于 3，结果是 3 System.out.println(ary.length)
</code></pre></li>
<li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便 于阅读。</p>
</li>
<li>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方 法。 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类 关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一 个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最 后。</li>
<li>【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在 getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题难度。</li>
</ul>
<pre><code>反例：
public Integer getData(){ if(true) {
return data + 100;
} else {
return data - 100;
}
}
</code></pre><ul>
<li>【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。 </li>
</ul>
<pre><code>反例：
String str = &quot;start&quot;; for(int i=0; i&lt;100; i++){
str = str + &quot;hello&quot;;
}
说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。
</code></pre><ul>
<li><p>【推荐】final 可提高程序响应效率，声明成 final 的情况：</p>
<ul>
<li>不需要重新赋值的变量，包括类属性、局部变量。</li>
<li>对象参数前加 final，表示不允许修改引用的指向。</li>
<li>类方法确定不允许被重写。</li>
</ul>
</li>
<li><p>【推荐】慎用 Object 的 clone 方法来拷贝对象。<br>说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的 拷贝。</p>
</li>
<li><p>【推荐】类成员与方法访问控制从严：</p>
<ul>
<li>如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。</li>
<li>工具类不允许有 public 或 default 构造方法。</li>
<li><p>类非 static 成员变量并且与子类共享，必须是 protected。</p>
</li>
<li><p>类非 static 成员变量并且仅在本类使用，必须是 private。 </p>
</li>
<li><p>类 static 成员变量如果仅在本类使用，必须是 private。</p>
</li>
<li><p>若是 static 成员变量，必须考虑是否为 final。</p>
</li>
<li>类成员方法只供类内部调用，必须是 private。</li>
<li><p>类成员方法只对继承类公开，那么限制为 protected。 说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。</p>
<pre><code>思 考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一 个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视 线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。
</code></pre></li>
</ul>
</li>
<li><a href="#集合处理">集合处理</a></li>
</ul>
<h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><ul>
<li>【强制】Map/Set 的 key 为自定义对象时，必须重写 hashCode 和 equals。</li>
</ul>
<pre><code>正例：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作 为 key 来使用。
</code></pre><ul>
<li><p>【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ; 说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p>
</li>
<li><p>【强制】在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、 删除均产生 ConcurrentModificationException 异常。</p>
</li>
<li><p>【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全 一样的数组，大小就是 list.size()。</p>
</li>
</ul>
<pre><code>反例：
直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它 类型数组将出现 ClassCastException 错误。
正例：
List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(&quot;guan&quot;);
list.add(&quot;bao&quot;);
String[] array = new String[list.size()]; array = list.toArray(array);
说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配 内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组 元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素 个数一致。
</code></pre><ul>
<li><p>【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。<br>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>String[] str = new String[] { “a”, “b” }; List  list = Arrays.asList(str);<br>第一种情况：list.add(“c”);  运行时异常。 第二种情况：str[0]= “gujin”; 那么 list.get(0)也会随之修改。</p>
</li>
<li><p>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法。 说明：苹果装箱后返回一个&lt;? extends Fruits&gt;对象，此对象就不能往里加任何水果，包括苹 果。</p>
</li>
<li><p>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</p>
</li>
</ul>
<pre><code>反例：
List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;);
a.add(&quot;2&quot;);
for (String temp : a) { 
if(&quot;1&quot;.equals(temp)){
a.remove(temp);
}
}
</code></pre><p>说明：这个例子的执行结果会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结 果吗？</p>
<pre><code>正例：
Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext()){
String temp = it.next(); 
if(删除元素的条件){
it.remove();
}
}
</code></pre><ul>
<li>【强制】在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort， Collections.sort 会报 IllegalArgumentException 异常。<br>说明：<ul>
<li>自反性：x，y 的比较结果和 y，x 的比较结果相反。 </li>
<li>传递性：x&gt;y,y&gt;z,则 x&gt;z。</li>
<li>对称性：x=y,则 x,z 比较结果和 y，z 比较结果相同。 </li>
</ul>
</li>
</ul>
<pre><code>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：
new Comparator&lt;Student&gt;() {
@Override
public int compare(Student o1, Student o2) { return o1.getId() &gt; o2.getId() ? 1 : -1;
}
}
</code></pre><ul>
<li><p>【推荐】集合初始化时，尽量指定集合初始值大小。<br>说明：ArrayList 尽量使用 ArrayList(int initialCapacity) 初始化。</p>
</li>
<li><p>【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。<br>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更 高。如果是 JDK8，使用 Map.foreach 方法。</p>
<pre><code>正例：values()返回的是 V 值集合，是一个 list 集合对象；
keySet()返回的是 K 值集合，是 一个 Set 集合对象；e
ntrySet()返回的是 K-V 值组合集合。
</code></pre></li>
<li><p>【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>线程局部安全</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody>
</table>
<pre><code>反例：很多同学认为 ConcurrentHashMap 是可以置入 null 值。在批量翻译场景中，子线程分 发时，出现置入 null 值的情况，但主线程没有捕获到此异常，导致排查困难。
</code></pre><ul>
<li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不 稳定性(unorder)带来的负面影响。</p>
<pre><code>说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则 依次排列的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。
</code></pre></li>
<li>【参考】利用 Set 元素唯一的特性，可以快速对另一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历去重操作。</li>
</ul>
<h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><ul>
<li><p>【强制】获取单例对象要线程安全。在单例对象里面做操作也要保证线程安全。 说明：资源驱动类、工具类、单例工厂类都需要注意。</p>
</li>
<li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。</p>
</li>
<li>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</li>
</ul>
<pre><code>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：
private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {
@Override
protected DateFormat initialValue() {
return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
}
};
说明：如果是 JDK8 的应用，可以使用 instant 代替 Date，Localdatetime 代替 Calendar， Datetimeformatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。
</code></pre><ul>
<li><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p>
</li>
<li><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造 成死锁。<br>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序 也必须是 A、B、C，否则可能出现死锁。</p>
</li>
<li><p>【强制】并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在 数据库层使用乐观锁，使用 version 作为更新依据。<br>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。</p>
</li>
<li><p>【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获 抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</p>
</li>
<li><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 各个方法的弊端：</p>
<ul>
<li>newFixedThreadPool 和 newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li>
<li>newCachedThreadPool 和 newScheduledThreadPool:<br>主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li>
</ul>
</li>
<li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 </p>
<pre><code>正例：
public class TimerTaskThread extends Thread { public TimerTaskThread(){
super.setName(&quot;TimerTaskThread&quot;); …
}
</code></pre></li>
<li><p>【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方 法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 countDown 方法，直到超时才返回结果。<br>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p>
</li>
<li><p>【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。<br>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()实例。</p>
<pre><code>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个线 程一个实例。
</code></pre></li>
<li><p>【推荐】通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化 问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方 案中较为简单一种（适用于 jdk5 及以上版本），将目标属性声明为 volatile 型<br>（比如反例 中修改 helper 的属性声明为 private volatile Helper helper = null;）；</p>
</li>
</ul>
<pre><code>反例：
class Foo {
private Helper helper = null; 
public Helper getHelper() {
    if (helper == null)    
    synchronized(this) 
    { 
    if (helper == null)
    helper = new Helper();
    }
    return helper; }
    // other functions and members...
}
</code></pre><ul>
<li><p>【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。如果想取回 count++数据，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); count++操作如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p>
</li>
<li><p>【参考】注意 HashMap 的扩容死链，导致 CPU 飙升的问题。</p>
</li>
<li><p>【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。 这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态 变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这 个线程内定义的)都可以操控这个变量。</p>
</li>
</ul>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ul>
<li><p>【强制】在一个 switch 块内，每个 case 要么通过 break/return 来终止，要么注释说明程序 将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在 最后，即使它什么代码也没有。</p>
</li>
<li><p>【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，避免使用下 面的形式：if (condition) statements;</p>
</li>
<li>【推荐】推荐尽量少用 else， if-else 的方式可以改写成：</li>
</ul>
<pre><code>if(condition){
…
return obj;
}
// 接着写 else 的业务逻辑代码;
说明：如果使用要 if-else if-else 方式表达逻辑，【强制】请勿超过 3 层，超过请使用状态 设计模式。
</code></pre><ul>
<li>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行复杂的语句，以提高 可读性。</li>
</ul>
<pre><code>正例：
//伪代码如下
InputStream stream = file.open(fileName, &quot;w&quot;);

if (stream != null) {
…
}
反例：
if (file.open(fileName, &quot;w&quot;) != null)) {
…
}
</code></pre><ul>
<li>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、 获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</li>
<li><p>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</p>
</li>
<li><p>【参考】方法中需要进行参数校验的场景：</p>
<ul>
<li>调用频次低的方法。</li>
<li>执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致 中间执行回退，或者错误，那得不偿失。</li>
<li>需要极高稳定性和可用性的方法。</li>
<li>对外提供的开放接口，不管是 RPC/API/HTTP 接口。</li>
</ul>
</li>
<li><p>【参考】方法中不需要参数校验的场景：</p>
<ul>
<li>极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参 数检查。</li>
<li>底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错 误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台 服务器中，所以 DAO 的参数校验，可以省略。</li>
<li>被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参 数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li>
</ul>
</li>
</ul>
<h3 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h3><ul>
<li>【强制】类、类属性、类方法的注释必须使用 javadoc 规范，使用/<em>*内容</em>/格式，不得使用<br>//xxx 方式。<br>说明：在 IDE 编辑窗口中，javadoc 方式会提示相关注释，生成 javadoc 可以正确输出相应注 释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高 阅读效率。</li>
<li>【强制】所有的抽象方法（包括接口中的方法）必须要用 javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：如有实现和调用注意事项，请一并说明。</li>
<li><p>【强制】所有的类都必须添加创建者信息。</p>
</li>
<li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使 用/<em> </em>/注释，注意与代码对齐。</p>
</li>
<li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p>
</li>
<li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词、关键字，保 持英文原文即可。</p>
<pre><code>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。
</code></pre></li>
<li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。 说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。</p>
</li>
<li><p>【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。 说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p>
</li>
<li><p>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看 的，使其能够快速接替自己的工作。</p>
</li>
<li>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一 个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</li>
</ul>
<pre><code>反例：
// put elephant into fridge 
put(elephant, fridge);
方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么， 语义清晰的代码不需要额外的注释。
</code></pre><ul>
<li>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描， 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<ul>
<li>待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个 javadoc 的标签，目前的<br>javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 javadoc 标签）。</li>
<li>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</li>
</ul>
</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>【强制】不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：<br>IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保 证程序健壮性。</li>
</ul>
<pre><code>正例：if(obj != null) {...}
反例：try { obj.method() } catch(NullPointerException e){…}
</code></pre><ul>
<li><p>【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。</p>
</li>
<li><p>【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳 定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分 异常类型，再做对应的异常处理。</p>
</li>
<li>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。</li>
<li><p>【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。</p>
</li>
<li><p>【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。 说明：如果 JDK7，可以使用 try-with-resources 方法。*     </p>
</li>
<li>【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不 会再执行 try 块中的 return 语句。</li>
<li>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期抛的是绣球，实际接到的是铅球，就会产生意外情况。</li>
<li>【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分 说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。 说明：本规约明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用 者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回 null 的情况。</li>
<li><p>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p>
<ul>
<li><p>返回类型为包装数据类型，有可能是 null，返回 int 值时注意判空。</p>
<pre><code>反例：
public int f(){ return Integer 对象}，如果为 null，自动解箱抛 NPE。 
</code></pre></li>
<li>数据库的查询结果可能为 null。</li>
<li>集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 </li>
<li>远程调用返回对象，一律要求进行 NPE 判断。</li>
<li>对于 Session 中获取的数据，建议 NPE 检查，避免空指针。</li>
<li>级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</li>
</ul>
</li>
<li><p>【推荐】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必 须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式， 封装 isSuccess、“错误码”、“错误简短信息”。<br>说明：关于 RPC 方法返回方式使用 Result 方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用<br>端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输 的性能损耗也是问题。</p>
</li>
<li>【推荐】定义时区分 unchecked / checked 异常，避免直接使用 RuntimeException 抛出，更 不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过 的自定义异常，如：DaoException / ServiceException 等。</li>
<li>【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副 本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。 正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto){…}</li>
</ul>
<h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><ul>
<li>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li>
</ul>
<pre><code>import  org.slf4j.Logger; 
import org.slf4j.LoggerFactory;
private static final Logger logger = LoggerFactory.getLogger(Abc.class);
</code></pre><ul>
<li><p>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</p>
</li>
<li><p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么<br>类型，什么目的，也有利于归类查找。 </p>
</li>
</ul>
<pre><code>正例：mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log
说明：推荐对日志进行分类，错误日志和业务日志尽量分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。
</code></pre><ul>
<li>【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。<br>说明：logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol); 如果 日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会 执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 </li>
</ul>
<pre><code>正例：（条件）
if (logger.isDebugEnabled()) {
logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol);
}
正例：（占位符）
logger.debug(&quot;Processing trade with id: {} and symbol : {} &quot;, id, symbol);
</code></pre><ul>
<li><p>【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。 </p>
<pre><code>正例：&lt;logger name=&quot;com.taobao.ecrm.member.config&quot; additivity=&quot;false&quot;&gt;
</code></pre></li>
<li><p>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么往上 抛。</p>
<pre><code>正例：logger.error(各类参数或者对象 toString + &quot;_&quot; + e.getMessage(), e);
</code></pre></li>
<li><p>输出的 POJO 类必须重写 toString 方法，否则只输出此对象的 hashCode 值（地址值），没啥 参考意义。</p>
</li>
<li>【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常、或者重要的错误信息。如 非必要，请不要在此场景打出 error 级别，避免频繁报警。</li>
<li><p>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 </p>
<pre><code>说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。纪录日志时请 思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？
</code></pre></li>
<li>【参考】如果日志用英文描述不清楚，推荐使用中文注释。对于中文 UTF-8 的日志，在 secureCRT 中，set encoding=utf-8；如果中文字符还乱码，请设置：全局&gt;默认的会话设置&gt;外观&gt;字体&gt;<br>选择字符集 gb2312；如果还不行，执行命令：set termencoding=gbk，并且直接使用中文来 进行检索。</li>
</ul>
<h3 id="其它规约"><a href="#其它规约" class="headerlink" title="其它规约"></a>其它规约</h3><ul>
<li>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);</li>
<li>【强制】避免用 Apache Beanutils 进行属性的 copy。<br>说明：Apache BeanUtils 性能较差，可以使用其他方案比如 Spring BeanUtils, Cglib BeanCopier。</li>
<li><p>【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按 规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（注意，boolean 命名不需要 加 is 前缀），会自动调用 isXxx()方法。<br>说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p>
</li>
<li><p>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。 说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。</p>
</li>
<li>【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值范围 0≤x&lt;1（能够取 到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取 整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li>
<li>【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime(); 说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime。在 JDK8 中，针对统计时 间等场景，推荐使用 Instant 类。</li>
<li>【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符，更不要在 vm 模板中加入任何复杂的逻 辑。</li>
<li>【推荐】任何数据结构的使用都应限制大小。 说明：这点很难完全做到，但很多次的故障都是因为数据结构自增长，结果造成内存被吃光。</li>
<li>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性 等要坚决从程序中清理出去，避免造成过多垃圾。清理这类垃圾代码是技术气场，不要有这样 的观念：“不做不错，多做多错”。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要分享的内容是Java中的编程规约，之前看公司的这个java这部分都空中，就看到前端日志的阿里巴巴的开发手册，把我关注的地方总结了一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于hive中decode函数，默认转码没有GBK中文字符集的问题</title>
    <link href="http://ghohankawk.github.io/2017/07/21/hive-decode/"/>
    <id>http://ghohankawk.github.io/2017/07/21/hive-decode/</id>
    <published>2017-07-21T08:57:42.850Z</published>
    <updated>2017-07-21T12:19:25.047Z</updated>
    
    <content type="html"><![CDATA[<p>今天要分享的内容是hive的select查询中的decode函数，对url进行转码的查询，看了官方文档，心都凉了，如下<br>string<br><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF" target="_blank" rel="external">decode(binary bin, string charset)</a><br>Decodes the first argument into a String using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). If either argument is null, the result will also be null. (As of Hive 0.12.0.)<br><a id="more"></a> </p>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>上面的那句话，就是说，默认的编码类型，只能从中的一个字符类型，其他不在范围内的肯定识别不了    </p>
<h1 id="比如说，-cb-d1-b9-b7"><a href="#比如说，-cb-d1-b9-b7" class="headerlink" title="比如说，%cb%d1%b9%b7"></a>比如说，%cb%d1%b9%b7</h1><p>上面的这个转码以后是，搜狗</p>
<p>前提必须是，用gbk，gb1312，gb18030随便一个字符集就可以了，他们的三个区别，<br>基本就是gb1312&lt;gbk&lt;gb18030,就是说，一个包含的字符集比一个多，也就是更全</p>
<p>如果你用java的utf-8解码，肯定是乱码中文</p>
<p>如果你用js的decodeURI()的这个方法，会报错，因为他不是utf-8的转码</p>
<h1 id="搜狗的utf-8的编码是多少？"><a href="#搜狗的utf-8的编码是多少？" class="headerlink" title="搜狗的utf-8的编码是多少？"></a>搜狗的utf-8的编码是多少？</h1><pre><code>%e6%90%9c%e7%8b%97
</code></pre><p>因此，你无论用java的urldecoder的decode方法，或者<br>js中的decodeURI(“%e6%90%9c%e7%8b%97”)方法，都是能得到正确的编码的</p>
<h1 id="那在hive中怎么办？"><a href="#那在hive中怎么办？" class="headerlink" title="那在hive中怎么办？"></a>那在hive中怎么办？</h1><p>关于怎么办这个地方，真是被坑了好久了</p>
<ol>
<li>资料少，根本搜不到</li>
<li>你也不会搜，也就是不会提问，当然搜不到</li>
<li><p>总之，就是找不到答案</p>
<h1 id="答案就是，另外的一个内建函数reflect"><a href="#答案就是，另外的一个内建函数reflect" class="headerlink" title="答案就是，另外的一个内建函数reflect"></a>答案就是，另外的一个内建函数reflect</h1><p> select  reflect(‘java.net.URLDecoder’, ‘decode’,’%cb%d1%b9%b7’ , “GBK”) from tmp_table  </p>
</li>
</ol>
<p>光看名字，就会让你想到，java中的反射，果不其然，这次就到了，你熟悉的地方了</p>
<p>因为网上的例子太少了，就连写出上面的查询，都是各种坑啊</p>
<h1 id="最后一个无关的问题，charset-forName-或者，decode函数，字符集区分大小写吗？"><a href="#最后一个无关的问题，charset-forName-或者，decode函数，字符集区分大小写吗？" class="headerlink" title="最后一个无关的问题，charset.forName(),或者，decode函数，字符集区分大小写吗？"></a>最后一个无关的问题，charset.forName(),或者，decode函数，字符集区分大小写吗？</h1><p>不区分，官方文档里面说了</p>
<h1 id="如何做到不区分的？Charset-gg-Charset-forName-“gg”-为什么识别是错的？"><a href="#如何做到不区分的？Charset-gg-Charset-forName-“gg”-为什么识别是错的？" class="headerlink" title="如何做到不区分的？Charset gg = Charset.forName(“gg”);为什么识别是错的？"></a>如何做到不区分的？Charset gg = Charset.forName(“gg”);为什么识别是错的？</h1><p>这个本来和hive是无关的，最开始运行的时候报错了，以为是这个地方的问题</p>
<p>最后最终调试了一下代码，总算是知道，为啥可以做到忽略大小写的问题，里面有一个很关键的排序比较器</p>
<p>网上的资源，太少了，根本没有一个讲这个部分的原理，看了半天硬是没有看明白</p>
<p>最终在不限的努力，找到了一个关键类</p>
<p>ASCIICaseInsensitiveComparator</p>
<p>就是他，起到了忽略大小写的关键原因，可以用ide反向最终一下，一看就明白</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要分享的内容是hive的select查询中的decode函数，对url进行转码的查询，看了官方文档，心都凉了，如下&lt;br&gt;string&lt;br&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;decode(binary bin, string charset)&lt;/a&gt;&lt;br&gt;Decodes the first argument into a String using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). If either argument is null, the result will also be null. (As of Hive 0.12.0.)&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何展示自己定义的一些html页面？</title>
    <link href="http://ghohankawk.github.io/2017/07/21/originTemplate/"/>
    <id>http://ghohankawk.github.io/2017/07/21/originTemplate/</id>
    <published>2017-07-21T07:28:53.148Z</published>
    <updated>2017-07-21T08:46:18.483Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们说点什么呢？直接看下面的效果：</p>
<p><iframe width="100%" onload="this.height=window.getComputedStyle(this).width;" frameborder="0" src="/origin/test.html"></iframe><br><a id="more"></a><br>上面的这三个小黄人，是我自己内部的html文件，<br>采取的方案，就是上篇文章中所说的两种方案结合</p>
<h1 id="1方案的好处在于，他和hexo主题相结合，保持了主题的一致性"><a href="#1方案的好处在于，他和hexo主题相结合，保持了主题的一致性" class="headerlink" title="1方案的好处在于，他和hexo主题相结合，保持了主题的一致性"></a>1方案的好处在于，他和hexo主题相结合，保持了主题的一致性</h1><h1 id="2方案的好处在于，完全能自定义html文件，包括里面的css和js"><a href="#2方案的好处在于，完全能自定义html文件，包括里面的css和js" class="headerlink" title="2方案的好处在于，完全能自定义html文件，包括里面的css和js"></a>2方案的好处在于，完全能自定义html文件，包括里面的css和js</h1><p>因此我的思路，就是利用这两种方案的优点结合起来，定义这个markdown模板</p>
<p>只要每次，改一下iframe中的src路径地址，就可以了，剩下的可以随意展示定制自己的网站了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们说点什么呢？直接看下面的效果：&lt;/p&gt;
&lt;p&gt;&lt;iframe width=&quot;100%&quot; onload=&quot;this.height=window.getComputedStyle(this).width;&quot; frameborder=&quot;0&quot; src=&quot;/origin/test.html&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于hexo中使用自己定义的html页面方法</title>
    <link href="http://ghohankawk.github.io/2017/07/21/originHtml/"/>
    <id>http://ghohankawk.github.io/2017/07/21/originHtml/</id>
    <published>2017-07-21T07:05:51.441Z</published>
    <updated>2017-07-21T08:52:54.574Z</updated>
    
    <content type="html"><![CDATA[<html><br><head><br>    <meta charset="UTF-8"><br>    <title>hexo中实用原生html的两种方法</title><br></head><br><body><br><h1>hexo中实用原生html的两种方法</h1><br><h1>方法一</h1><br><p><br>你现在看到的这个页面，就是自己原生写的html文件。<br>直接在你的markdown里面的头部，写上一句，layout:false<br>就可以写你的熟悉的html页面了。<br>但是，确定也是很明显的，就是所有的标签页，那些提示都写用不了啦，变成了原生的人肉<br>没有ide自己写页面，当然痛苦，而且样式不可以控制<br></p><br><br><br><br><br><h1>方法二</h1><br><p>在_config.yml中配置一个，skip_render属性，默认是source根部下面的<br>因此，我这里，提前弄好了一个自定义的小黄人html页面<br><br><iframe width="100%" onload="this.height=window.getComputedStyle(this).width;" frameborder="0" src="/origin/test.html"></iframe><br></p><br><br><br></body><br></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;br&gt;&lt;head&gt;&lt;br&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;br&gt;    &lt;title&gt;hexo中实用原生html的两种方法&lt;/title&gt;&lt;br&gt;&lt;/head&gt;&lt;br&gt;&lt;body&gt;&lt;br&gt;&lt;h1&gt;hexo中实用原生html的两种方法&lt;/h1&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于java中的synchronized的用法</title>
    <link href="http://ghohankawk.github.io/2017/07/05/java-synchronized/"/>
    <id>http://ghohankawk.github.io/2017/07/05/java-synchronized/</id>
    <published>2017-07-05T11:35:14.232Z</published>
    <updated>2017-07-14T11:33:01.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是synchronized"><a href="#今天要分享的内容是synchronized" class="headerlink" title="今天要分享的内容是synchronized"></a>今天要分享的内容是synchronized</h1><p>这个地方也是，说起来知道同步的用法，但是并不是多么的清楚，和上面的那篇mysql的子查询一样，看到代码中很多这样写的。<br>就顺便研究总结一下：<br><a id="more"></a> </p>
<h1 id="修饰对象有几种-能出现在什么地方"><a href="#修饰对象有几种-能出现在什么地方" class="headerlink" title="修饰对象有几种(能出现在什么地方)"></a>修饰对象有几种(能出现在什么地方)</h1><ul>
<li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分， 作用的对象是这个类的所有对象。</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法， 作用的对象是调用这个方法的对象；</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法， 作用的对象是这个类的所有对象；</li>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码， 作用的对象是调用这个代码块的对象；</li>
</ul>
<h1 id="2个锁"><a href="#2个锁" class="headerlink" title="2个锁"></a>2个锁</h1><p>上面的4种情况，核心也就是，2个锁</p>
<ol>
<li>对象锁，修饰一个类的成员方法和代码块，就是这种情况，他强调的是创建对象，调用对象本身，比如，a对象和b对象完全不同</li>
<li>类锁（其实没有，类比概念，好理解），也就是修饰类，和静态的方法，这两种的同步是一样的，他们强调的是类class这个对象的锁，因此a对象和b对象拥有同样的锁，所以是相同的</li>
</ol>
<h1 id="废话不多说，直接上例子吧"><a href="#废话不多说，直接上例子吧" class="headerlink" title="废话不多说，直接上例子吧"></a>废话不多说，直接上例子吧</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-07-05 19:52</div><div class="line"> */</div><div class="line">public class synchronizedTest &#123;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰方法块</div><div class="line">     */</div><div class="line">    static class SyncMehtodBlock implements Runnable &#123;</div><div class="line">        private static int count;</div><div class="line"></div><div class="line">        public SyncMehtodBlock() &#123;</div><div class="line">            count = 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtodBlock&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtodBlock&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰方法</div><div class="line">     */</div><div class="line">    static class SyncMehtod extends Thread &#123;</div><div class="line">        private synchronizedTest syn;</div><div class="line"></div><div class="line">        public SyncMehtod(synchronizedTest synchronizedTest) &#123;</div><div class="line">            this.syn = synchronizedTest;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            syn.test();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void test() &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;开始..SyncMehtod&quot;);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;结束..SyncMehtod&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰静态方法</div><div class="line">     */</div><div class="line">    static class SyncStaticMehtod extends Thread &#123;</div><div class="line"></div><div class="line">        public synchronized static void staticTest() &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;开始..SyncStaticMehtod&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;结束..SyncStaticMehtod&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            staticTest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步线程,修饰类</div><div class="line">     */</div><div class="line">    static class SyncClass extends Thread &#123;</div><div class="line"></div><div class="line">        public void classTest() &#123;</div><div class="line">            synchronized (synchronizedTest.class) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;开始..SyncClass&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;结束..SyncClass&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            classTest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //情况1，修饰方法块</div><div class="line">        SyncMehtodBlock syncMehtodBlock = new SyncMehtodBlock();</div><div class="line">        Thread thread1 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock1&quot;);</div><div class="line">        Thread thread2 = new Thread(syncMehtodBlock, &quot;syncMehtodBlock2&quot;);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况2，修饰方法</div><div class="line">        synchronizedTest syn = new synchronizedTest();</div><div class="line">        SyncMehtod syncMehtod3 = new SyncMehtod(syn);</div><div class="line">        SyncMehtod syncMehtod4 = new SyncMehtod(syn);</div><div class="line">        syncMehtod3.start();</div><div class="line">        syncMehtod4.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况3，修饰静态方法</div><div class="line">        SyncStaticMehtod a = new SyncStaticMehtod();</div><div class="line">        SyncStaticMehtod b = new SyncStaticMehtod();</div><div class="line">        Thread thread5 = new Thread(a, &quot;SyncStaticMehtod1&quot;);</div><div class="line">        Thread thread6 = new Thread(b, &quot;SyncStaticMehtod2&quot;);</div><div class="line">        thread5.start();</div><div class="line">        thread6.start();</div><div class="line"></div><div class="line"></div><div class="line">        //情况4，修饰类</div><div class="line">        SyncClass c = new SyncClass();</div><div class="line">        SyncClass d = new SyncClass();</div><div class="line">        Thread thread7 = new Thread(c, &quot;SyncClass1&quot;);</div><div class="line">        Thread thread8 = new Thread(d, &quot;SyncClass2&quot;);</div><div class="line">        thread7.start();</div><div class="line">        thread8.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我写了一个，模拟4种情况的例子，报每个类型都包含进去了</p>
<p>请注意观察里面的synchronized的关键位置，出现的情况，以及每个测试例子，是如何新建的，区分不同</p>
<p>所有的例子，都是具有同步的，因为竞争，比如，a先开始，那么a先结束，然后才能轮到b开始，b结束</p>
<p>好好，体会里面的内容</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。</li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
</ol>
<p>我觉得别人说的，这三句话，已经说的很明白不过，我也就不加自己的体会了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是synchronized&quot;&gt;&lt;a href=&quot;#今天要分享的内容是synchronized&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是synchronized&quot;&gt;&lt;/a&gt;今天要分享的内容是synchronized&lt;/h1&gt;&lt;p&gt;这个地方也是，说起来知道同步的用法，但是并不是多么的清楚，和上面的那篇mysql的子查询一样，看到代码中很多这样写的。&lt;br&gt;就顺便研究总结一下：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于mysql中select子查询</title>
    <link href="http://ghohankawk.github.io/2017/07/03/mysql/"/>
    <id>http://ghohankawk.github.io/2017/07/03/mysql/</id>
    <published>2017-07-03T11:58:01.077Z</published>
    <updated>2017-07-14T11:33:01.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是mysql的select子查询"><a href="#今天要分享的内容是mysql的select子查询" class="headerlink" title="今天要分享的内容是mysql的select子查询"></a>今天要分享的内容是mysql的select子查询</h1><p>一直记得凯哥，半年前说过的一句话，原来你不知道，子查询啊，其实，我知道是又这么一回事<br>但是，具体又说不上来，大概就是那种，一看就知道，但是你有不完全知道的类型吧<br>现在在写hive语法的时候又碰到了，那么就好好总结一次吧。<br><a id="more"></a> </p>
<h1 id="子查询定义"><a href="#子查询定义" class="headerlink" title="子查询定义"></a>子查询定义</h1><p>在一个表表达中可以调用另一个表表达式，这个被调用的表表达式叫做子查询（subquery），<br>那么也称作子选择（subselect）或内嵌选择（inner select）。<br>子查询的结果传递给调用它的表达式继续处理。</p>
<p>说人话就是，一个sql语句，出现了2个以上的select关键词，这个清晰了吧？</p>
<h1 id="子查询分类1"><a href="#子查询分类1" class="headerlink" title="子查询分类1"></a>子查询分类1</h1><pre><code>1*1   标量子查询：返回的结果集是一个标量集合，一行一列，也就是一个标量值。可以指定一个标量表达式的任何地方，都可以用一个标量子查询。
1*n   行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。
n*1   列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）。
n*n   表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。
     就这么四类
</code></pre><p>从定义上讲，</p>
<p>每个标量子查询也是一个行子查询和一个列子查询，反之则不是；</p>
<p>每个行子查询和列子查询也是一个表子查询，反之也不是。</p>
<h1 id="子查询分类2"><a href="#子查询分类2" class="headerlink" title="子查询分类2"></a>子查询分类2</h1><pre><code>where型子查询：（把内层查询结果当作外层查询的比较条件）
定义：where型的子查询就是把内层查询的结果当作外层查询的条件。

from型子查询：（把内层的查询结果供外层再次查询）
定义：from子查询就是把子查询的结果(内存里的一张表)当作一张临时表，然后再对它进行处理。

exists型子查询：（把外层查询结果拿到内层，看内层的查询是否成立）
定义：exists子查询就是对外层表进行循环，再对内表进行内层查询。和in ()差不多，但是它们还是有区别的。主要是看两个张表大小差的程度。若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）；
</code></pre><p>其实，光这么说，很难明白的，因为你都没写过，根本理解不了，尤其是exisit子查询</p>
<h1 id="使用子查询原则"><a href="#使用子查询原则" class="headerlink" title="使用子查询原则"></a>使用子查询原则</h1><pre><code>1.一个子查询必须放在圆括号中。
2.将子查询放在比较条件的右边以增加可读性。
子查询不包含 ORDER BY 子句。对一个 SELECT 语句只能用一个 ORDER BY 子句，并且如果指定了它就必须放在主 SELECT 语句的最后。
3.在子查询中可以使用两种比较条件：单行运算符(&gt;, =, &gt;=, &lt;, &lt;&gt;, &lt;=) 和多行运算符(IN, ANY, ALL)。
</code></pre><h1 id="where型子查询"><a href="#where型子查询" class="headerlink" title="where型子查询"></a>where型子查询</h1><p>select * from a where a.xx = (select xx from b where b.xx=”xx”),这种感觉</p>
<h1 id="from型子查询"><a href="#from型子查询" class="headerlink" title="from型子查询"></a>from型子查询</h1><p>select <em> from (select </em> from a) as aa,这种感觉</p>
<h1 id="exists型子查询"><a href="#exists型子查询" class="headerlink" title="exists型子查询"></a>exists型子查询</h1><p>因为上面那两种，子查询，很明了简单，就不谈了，主要说下面的</p>
<p>尽量表达清楚</p>
<pre><code>EXISTS关键字表示存在。使用EXISTS关键字时，内层查询语句不返回查询的记录，
而是返回一个真假值，如果内层查询语句查询到满足条件的记录，
只要子查询中至少返回一个值，则EXISTS语句的值就为True。
就返回true，否则返回false。当返回的值为true时，外层查询语句将进行查询，
否则不进行查询。NOT EXISTS刚好与之相反。exists的用法和in ()差不多，
但是它们还是有区别的。主要是看两个张表大小差的程度。
若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）;
</code></pre><p>看上面这段话的，解释，保证，你看了，也不知道在说啥，其实说的稍微有点问题</p>
<p>正确的解释，应该是，上面的当然也没错</p>
<p>exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条 件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false</p>
<p>就是循环外层的查询结果，然后带进去，查看条件是否成立，不成立丢弃，成立留下</p>
<pre><code>select * from user where exists (select 1);
这句话，就会输出，user表中全部的人，因为后面的条件，对于每个人都成立
</code></pre><p>select * from user where userId in (1, 2, 3);</p>
<p>这样的in查询，等价于</p>
<p>select * from user where userId = 1 or userId = 2 or userId = 3;</p>
<p>因此，要求in后面的表是小表，才不至于，很大的表，循环多次</p>
<h1 id="记住一句话，谁的表大就用谁的索引"><a href="#记住一句话，谁的表大就用谁的索引" class="headerlink" title="记住一句话，谁的表大就用谁的索引"></a>记住一句话，谁的表大就用谁的索引</h1><p>下面来考虑exists和in的性能</p>
<pre><code>考虑如下SQL语句

1: select * from A where exists (select * from B where B.id = A.id);

2: select * from A where A.id in (select id from B);
</code></pre><p> 查询1.可以转化以下伪代码，便于理解</p>
<pre><code> for ($i = 0; $i &lt; count(A); $i++) {

 　　$a = get_record(A, $i); #从A表逐条获取记录

 　　if (B.id = $a[id]) #如果子条件成立

 　　　　$result[] = $a;

 }

return $result;
</code></pre><p> 大概就是这么个意思，其实可以看到,查询1主要是用到了B表的索引，A表如何对查询的效率影响应该不大<br> 也就是说，表B越大就越能利用到索引的优势</p>
<p> 而假设B表是小表的所有id为1,2,3,查询2可以转换为</p>
<pre><code>select * from A where A.id = 1 or A.id = 2 or A.id = 3;
</code></pre><p> 这个好理解了，这里主要是用到了A的索引，B表如何对查询影响不大<br>  也就是说，表A越大就越能利用到索引的优势</p>
<p> 下面再看not exists 和 not in</p>
<pre><code>1. select * from A where not exists (select * from B where B.id = A.id);

2. select * from A where A.id not in (select id from B);
</code></pre><p>看查询1，还是和上面一样，用了B的索引</p>
<p>而对于查询2，可以转化成如下语句</p>
<pre><code>select * from A where A.id != 1 and A.id != 2 and A.id != 3;
</code></pre><p>可以知道not in是个范围查询，这种!=的范围查询无法使用任何索引,等于说A表的每条记录，都要在B表里遍历一次，查看B表里是否存在这条记录</p>
<p>not in 和not exists如果查询语句</p>
<p>使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。<br>所以无论那个表大，用not exists都比not in要快。          </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先大概说一下，这个子查询吧，其实，mysql还有很多的细节地方要注意，有时间再说说，自己的理解吧</p>
<p>补充一句，昨天和妹子出去吃饭，今天居然就感冒生病了，心疼啊/(ㄒoㄒ)/~~，怪我了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是mysql的select子查询&quot;&gt;&lt;a href=&quot;#今天要分享的内容是mysql的select子查询&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是mysql的select子查询&quot;&gt;&lt;/a&gt;今天要分享的内容是mysql的select子查询&lt;/h1&gt;&lt;p&gt;一直记得凯哥，半年前说过的一句话，原来你不知道，子查询啊，其实，我知道是又这么一回事&lt;br&gt;但是，具体又说不上来，大概就是那种，一看就知道，但是你有不完全知道的类型吧&lt;br&gt;现在在写hive语法的时候又碰到了，那么就好好总结一次吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于linux中的grep用法</title>
    <link href="http://ghohankawk.github.io/2017/06/29/linux-grep/"/>
    <id>http://ghohankawk.github.io/2017/06/29/linux-grep/</id>
    <published>2017-06-29T11:29:00.193Z</published>
    <updated>2017-07-14T11:33:01.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是grep这个命令"><a href="#今天要分享的内容是grep这个命令" class="headerlink" title="今天要分享的内容是grep这个命令"></a>今天要分享的内容是grep这个命令</h1><p>之前有一篇写了awk，那么grep的这个命令也就顺便研究一下<br><a id="more"></a> </p>
<h1 id="grep背景简介"><a href="#grep背景简介" class="headerlink" title="grep背景简介"></a>grep背景简介</h1><p>  grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。Unix的grep家族包 括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能 更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p>
<p>  grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到屏幕，不影响原文件内容。</p>
<p>  grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<h1 id="grep正则表达式元字符集（基本集）"><a href="#grep正则表达式元字符集（基本集）" class="headerlink" title="grep正则表达式元字符集（基本集）"></a>grep正则表达式元字符集（基本集）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">^</div><div class="line">锚定行的开始 如：&apos;^grep&apos;匹配所有以grep开头的行。</div><div class="line"></div><div class="line">$</div><div class="line">锚定行的结束 如：&apos;grep$&apos;匹配所有以grep结尾的行。</div><div class="line"></div><div class="line">.</div><div class="line">匹配一个非换行符的字符 如：&apos;gr.p&apos;匹配gr后接一个任意字符，然后是p。</div><div class="line"></div><div class="line">*</div><div class="line">匹配零个或多个先前字符 如：&apos;*grep&apos;匹配所有一个或多个空格后紧跟grep的行。 .*一起用代表任意字符。</div><div class="line"></div><div class="line">[]</div><div class="line">匹配一个指定范围内的字符，如&apos;[Gg]rep&apos;匹配Grep和grep。</div><div class="line"></div><div class="line">[^]</div><div class="line">匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。</div><div class="line"></div><div class="line">\(..\)</div><div class="line">标记匹配字符，如&apos;\(love\)&apos;，love被标记为1。</div><div class="line"></div><div class="line">\&lt;</div><div class="line">锚定单词的开始，如:&apos;\&lt;grep&apos;匹配包含以grep开头的单词的行。</div><div class="line"></div><div class="line">\&gt;</div><div class="line">锚定单词的结束，如&apos;grep\&gt;&apos;匹配包含以grep结尾的单词的行。</div><div class="line"></div><div class="line">x\&#123;m\&#125;</div><div class="line">重复字符x，m次，如：&apos;0\&#123;5\&#125;&apos;匹配包含5个o的行。</div><div class="line"></div><div class="line">x\&#123;m,\&#125;</div><div class="line">重复字符x,至少m次，如：&apos;o\&#123;5,\&#125;&apos;匹配至少有5个o的行。</div><div class="line"></div><div class="line">x\&#123;m,n\&#125;</div><div class="line">重复字符x，至少m次，不多于n次，如：&apos;o\&#123;5,10\&#125;&apos;匹配5--10个o的行。</div><div class="line"></div><div class="line">\w</div><div class="line">匹配文字和数字字符，也就是[A-Za-z0-9]，如：&apos;G\w*p&apos;匹配以G后跟零个或多个文字或数字字符，然后是p。</div><div class="line"></div><div class="line">\W</div><div class="line">\w的反置形式，匹配一个或多个非单词字符，如点号句号等。</div><div class="line"></div><div class="line">\b</div><div class="line">单词锁定符，如: &apos;\bgrep\b&apos;只匹配grep。</div></pre></td></tr></table></figure>
<h1 id="用于egrep和-grep-E的元字符扩展集"><a href="#用于egrep和-grep-E的元字符扩展集" class="headerlink" title="用于egrep和 grep -E的元字符扩展集"></a>用于egrep和 grep -E的元字符扩展集</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">+</div><div class="line">匹配一个或多个先前的字符。如：&apos;[a-z]+able&apos;，匹配一个或多个小写字母后跟able的串，如loveable,enable,disable等。</div><div class="line"></div><div class="line">?</div><div class="line">匹配零个或多个先前的字符。如：&apos;gr?p&apos;匹配g后跟一个r或没有字符，然后是p的行。</div><div class="line"></div><div class="line">a|b|c</div><div class="line">匹配a或b或c。如：grep|sed匹配grep或sed</div><div class="line"></div><div class="line">()</div><div class="line">分组符号，如：love(able|rs)ov+匹配loveable或lovers，匹配一个或多个ov。</div><div class="line"></div><div class="line">    \(\)：将一个或多个字符捆绑在一起，当作一个整体进行处理；</div><div class="line"></div><div class="line">        # grep &quot;\(xy\)\+&quot; grep.txt</div><div class="line"></div><div class="line">        \(xy\)*ab</div><div class="line"></div><div class="line">Note：分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：\1,\2,\3,.....</div><div class="line"></div><div class="line">    \1：从左侧起，第一个左括号以及与之匹配右括号之间的模式所匹配到的字符；</div><div class="line"></div><div class="line">        \(ab\+\(xy\)*\)：</div><div class="line"></div><div class="line">            \1：ab\+\(xy\)*</div><div class="line"></div><div class="line">            \2：xy</div><div class="line"></div><div class="line">x&#123;m&#125;,x&#123;m,&#125;,x&#123;m,n&#125;</div><div class="line">作用同x\&#123;m\&#125;,x\&#123;m,\&#125;,x\&#123;m,n\&#125;</div></pre></td></tr></table></figure>
<h1 id="POSIX字符类"><a href="#POSIX字符类" class="headerlink" title="POSIX字符类"></a>POSIX字符类</h1><p>为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是A-Za-z0-9的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[:alnum:]</div><div class="line">文字数字字符</div><div class="line"></div><div class="line">[:alpha:]</div><div class="line">文字字符</div><div class="line"></div><div class="line">[:digit:]</div><div class="line">数字字符</div><div class="line"></div><div class="line">[:graph:]</div><div class="line">非空字符（非空格、控制字符）</div><div class="line"></div><div class="line">[:lower:]</div><div class="line">小写字符</div><div class="line"></div><div class="line">[:cntrl:]</div><div class="line">控制字符</div><div class="line"></div><div class="line">[:print:]</div><div class="line">非空字符（包括空格）</div><div class="line"></div><div class="line">[:punct:]</div><div class="line">标点符号</div><div class="line"></div><div class="line">[:space:]</div><div class="line">所有空白字符（新行，空格，制表符）</div><div class="line"></div><div class="line">[:upper:]</div><div class="line">大写字符</div><div class="line"></div><div class="line">[:xdigit:]</div><div class="line">十六进制数字（0-9，a-f，A-F）</div></pre></td></tr></table></figure>
<h1 id="Grep命令选项"><a href="#Grep命令选项" class="headerlink" title="Grep命令选项"></a>Grep命令选项</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">-?</div><div class="line">同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。</div><div class="line"></div><div class="line">-b，--byte-offset</div><div class="line">打印匹配行前面打印该行所在的偏移。</div><div class="line"></div><div class="line">-c,--count</div><div class="line">只打印匹配的行数，不显示匹配的内容，数量匹配了多少行。</div><div class="line"></div><div class="line">-f File，--file=File</div><div class="line">从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。</div><div class="line"></div><div class="line">-h，--no-filename</div><div class="line">当搜索多个文件时，不显示匹配文件名前缀。</div><div class="line"></div><div class="line">-i，--ignore-case</div><div class="line">忽略大小写差别。</div><div class="line"></div><div class="line">-q，--quiet</div><div class="line">取消显示，只返回退出状态。0则表示找到了匹配的行。</div><div class="line"></div><div class="line">-l，--files-with-matches</div><div class="line">打印匹配模板的文件清单。</div><div class="line"></div><div class="line">-L，--files-without-match</div><div class="line">打印不匹配模板的文件清单。</div><div class="line"></div><div class="line">-n，--line-number</div><div class="line">在匹配的行前面打印行号。</div><div class="line"></div><div class="line">-s，--silent</div><div class="line">不显示关于不存在或者无法读取文件的错误信息。</div><div class="line"></div><div class="line">-v，--revert-match</div><div class="line">反检索，只显示不匹配的行。</div><div class="line"></div><div class="line">-w，--word-regexp</div><div class="line">如果被\&lt;和\&gt;引用，就把表达式做为一个单词搜索。</div><div class="line"></div><div class="line">-V，--version</div><div class="line">显示软件版本信息。</div><div class="line"></div><div class="line">--color=auto：对匹配到的文本着色显示；</div><div class="line"></div><div class="line"></div><div class="line">    -o：仅显示匹配到的字符串</div><div class="line"></div><div class="line">    -A #：after，显示匹配的后#行</div><div class="line"></div><div class="line">    -B #：before，显示匹配的前#行</div><div class="line"></div><div class="line">    -C #：context，前后各#行</div><div class="line"></div><div class="line">    -E：使用ERE，支持扩展的正则表达式</div><div class="line"></div><div class="line">    -s：不显示不存在或无匹配的错误信息</div></pre></td></tr></table></figure>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">要用好grep这个工具，其实就是要写好正则表达式，所以这里不对grep的所有功能进行实例讲解，只列几个例子，讲解一个正则表达式的写法。</div><div class="line"></div><div class="line">$ ls -l | grep &apos;^a&apos;</div><div class="line">通过管道过滤ls -l输出的内容，只显示以a开头的行。</div><div class="line"></div><div class="line">$ grep &apos;test&apos; d*</div><div class="line">显示所有以d开头的文件中包含test的行。</div><div class="line"></div><div class="line">$ grep &apos;test&apos; aa bb cc</div><div class="line">显示在aa，bb，cc文件中匹配test的行。</div><div class="line"></div><div class="line">$ grep &apos;[a-z]\&#123;5\&#125;&apos; aa</div><div class="line">显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</div><div class="line"></div><div class="line">$ grep &apos;w\(es\)t.*\1&apos; aa</div><div class="line">如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.*），这些字符后面紧跟着另外一个es（\1），找到就显示该行。如果用egrep或grep -E，就不用&quot;\&quot;号进行转义，直接写成&apos;w(es)t.*\1&apos;就可以了。</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>grep确实很强大，同时，相对awk还是简单多了，无论是命令还是使用</p>
<p>毕竟只是单纯的去查找，而不做任何的修改内容上</p>
<p>awk函数多，又可以自己编程</p>
<p>多到底，grep还是考验对正则表达式的理解</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是grep这个命令&quot;&gt;&lt;a href=&quot;#今天要分享的内容是grep这个命令&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是grep这个命令&quot;&gt;&lt;/a&gt;今天要分享的内容是grep这个命令&lt;/h1&gt;&lt;p&gt;之前有一篇写了awk，那么grep的这个命令也就顺便研究一下&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于linux中的awk用法</title>
    <link href="http://ghohankawk.github.io/2017/06/29/linux-awk/"/>
    <id>http://ghohankawk.github.io/2017/06/29/linux-awk/</id>
    <published>2017-06-29T08:05:45.039Z</published>
    <updated>2017-07-14T11:33:01.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是awk这个命令"><a href="#今天要分享的内容是awk这个命令" class="headerlink" title="今天要分享的内容是awk这个命令"></a>今天要分享的内容是awk这个命令</h1><p>因为要看日志，以前公司业务小的时候，能下载到本地用文本工具一个一个去找，但是现在不行了</p>
<p>面对hive大数据，根本行不通，没办法，不得不面对这个命令<br><a id="more"></a> </p>
<h1 id="先来了解一下awk背景知识"><a href="#先来了解一下awk背景知识" class="headerlink" title="先来了解一下awk背景知识"></a>先来了解一下awk背景知识</h1><p>awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)，如果没有指定模式，则所有被操作所指定的行都被处理。awk分别代表其作者姓氏的第一个字母。因为它的作者是三个人，分别是Alfred Aho、Brian Kernighan、Peter Weinberger。gawk是awk的GNU版本，它提供了Bell实验室和GNU的一些扩展。下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk。</p>
<h1 id="语法和选项"><a href="#语法和选项" class="headerlink" title="语法和选项"></a>语法和选项</h1><p>  1.语法</p>
<pre><code>awk [options] &apos;script&apos; var=value file(s)
awk [options] -f scriptfile var=value file(s)
</code></pre><ol>
<li><p>命令选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-F fs or --field-separator fs</div><div class="line">指定输入分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</div><div class="line"></div><div class="line">-v var=value or --asign var=value</div><div class="line">赋值一个用户定义变量。</div><div class="line"></div><div class="line">-f scripfile or --file scriptfile</div><div class="line">从脚本文件中读取awk命令。</div><div class="line"></div><div class="line">-mf nnn and -mr nnn</div><div class="line">对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</div><div class="line"></div><div class="line">-W compact or --compat, -W traditional or --traditional</div><div class="line">在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</div><div class="line"></div><div class="line">-W copyleft or --copyleft, -W copyright or --copyright</div><div class="line">打印简短的版权信息。</div><div class="line"></div><div class="line">-W help or --help, -W usage or --usage</div><div class="line">打印全部awk选项和每个选项的简短说明。</div><div class="line"></div><div class="line">-W lint or --lint</div><div class="line">打印不能向传统unix平台移植的结构的警告。</div><div class="line"></div><div class="line">-W lint-old or --lint-old</div><div class="line">打印关于不能向传统unix平台移植的结构的警告。</div><div class="line"></div><div class="line">-W posix</div><div class="line">打开兼容模式。但有以下限制，不识别：\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。</div><div class="line"></div><div class="line">-W re-interval or --re-inerval</div><div class="line">允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</div><div class="line"></div><div class="line">-W source program-text or --source program-text</div><div class="line">使用program-text作为源代码，可与-f命令混用。</div><div class="line"></div><div class="line">-W version or --version</div><div class="line">打印bug报告信息的版本。</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="模式和操作"><a href="#模式和操作" class="headerlink" title="模式和操作"></a>模式和操作</h1><p>awk脚本是由模式和操作组成的：</p>
<p>pattern {action} </p>
<p>如<br>$ awk ‘/root/‘ test，或</p>
<p>$ awk ‘$3 &lt; 100’ test。</p>
<p>两者是可选的，如果没有模式，则action应用到全部记录，如果没有action，则输出匹配全部记录。</p>
<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>  模式可以是以下任意一个：</p>
<pre><code>/正则表达式/：使用通配符的扩展集。
关系表达式：可以用下面运算符表中的关系运算符进行操作，可以是字符串或数字的比较，如$2&gt;%1选择第二个字段比第一个字段长的行。
模式匹配表达式：用运算符~(匹配)和~!(不匹配)。
pattern语句块，模式：指定一个行的范围。该语法不能包括BEGIN和END模式。
BEGIN：让用户指定在第一条输入记录被处理之前所发生的动作，通常可在这里设置全局变量。
END：让用户在最后一条输入记录被读取之后发生的动作。 
</code></pre><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>  操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内。主要有四部份：</p>
<pre><code>变量或数组赋值
输出命令
内置函数
控制流命令
</code></pre><h1 id="awk脚本基本结构"><a href="#awk脚本基本结构" class="headerlink" title="awk脚本基本结构"></a>awk脚本基本结构</h1><pre><code>awk &apos;BEGIN{ print &quot;start&quot; } pattern{ commands } END{ print &quot;end&quot; }&apos; file 
</code></pre><p>  一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：<br> pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>
<p>当使用不带参数的print时，它就打印当前行，当print的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用，</p>
<p>例如： </p>
<pre><code>echo | awk &apos;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; }&apos; 
v1 v2 v3 
</code></pre><p> 双引号拼接使用： </p>
<pre><code>echo | awk &apos;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; }&apos; 
v1=v2=v3
</code></pre><p>{ }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i=0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。</p>
<h1 id="awk的环境变量"><a href="#awk的环境变量" class="headerlink" title="awk的环境变量"></a>awk的环境变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">变量	描述</div><div class="line">$n	当前记录的第n个字段，字段间由FS分隔。</div><div class="line">$0	完整的输入记录。</div><div class="line">ARGC	命令行参数的数目。</div><div class="line">ARGIND	命令行中当前文件的位置(从0开始算)。</div><div class="line">ARGV	包含命令行参数的数组。</div><div class="line">CONVFMT	数字转换格式(默认值为%.6g)</div><div class="line">ENVIRON	环境变量关联数组。</div><div class="line">ERRNO	最后一个系统错误的描述。</div><div class="line">FIELDWIDTHS	字段宽度列表(用空格键分隔)。</div><div class="line">FILENAME	当前文件名。</div><div class="line">FNR	同NR，但相对于当前文件。</div><div class="line">FS	字段分隔符(默认是任何空格)。</div><div class="line">IGNORECASE	如果为真，则进行忽略大小写的匹配。</div><div class="line">NF	当前记录中的字段数。</div><div class="line">NR	当前记录数。</div><div class="line">OFMT	数字的输出格式(默认值是%.6g)。</div><div class="line">OFS	输出字段分隔符(默认值是一个空格)。</div><div class="line">ORS	输出记录分隔符(默认值是一个换行符)。</div><div class="line">RLENGTH	由match函数所匹配的字符串的长度。</div><div class="line">RS	记录分隔符(默认是一个换行符)。</div><div class="line">RSTART	由match函数所匹配的字符串的第一个位置。</div><div class="line">SUBSEP	数组下标分隔符(默认值是\034)。</div></pre></td></tr></table></figure>
<h1 id="awk运算符"><a href="#awk运算符" class="headerlink" title="awk运算符"></a>awk运算符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">运算符	描述</div><div class="line">= += -= *= /= %= ^= **=	赋值</div><div class="line">?:	C条件表达式</div><div class="line">||	逻辑或</div><div class="line">&amp;&amp;	逻辑与</div><div class="line">~ ~!	匹配正则表达式和不匹配正则表达式</div><div class="line">&lt; &lt;= &gt; &gt;= != ==	关系运算符</div><div class="line">空格	连接</div><div class="line">+ -	加，减</div><div class="line">* / &amp;	乘，除与求余</div><div class="line">+ - !	一元加，减和逻辑非</div><div class="line">^ ***	求幂</div><div class="line">++ --	增加或减少，作为前缀或后缀</div><div class="line">$	字段引用</div><div class="line">in	数组成员</div></pre></td></tr></table></figure>
<h1 id="熟悉一组专有名词"><a href="#熟悉一组专有名词" class="headerlink" title="熟悉一组专有名词"></a>熟悉一组专有名词</h1><ol>
<li>记录</li>
</ol>
<p>awk把每一个以换行符结束的行称为一个记录。<br>记录分隔符：默认的输入和输出的分隔符都是回车，保存在内建变量ORS和RS中。<br>$0变量：它指的是整条记录。如$ awk ‘{print $0}’ test将输出test文件中的所有记录。<br>变量NR：一个计数器，每处理完一条记录，NR的值就增加1。如$ awk ‘{print NR,$0}’ test将输出test文件中所有记录，并在记录前显示记录号。</p>
<ol>
<li>域</li>
</ol>
<p>记录中每个单词称做“域”，默认情况下以空格或tab分隔。awk可跟踪域的个数，并在内建变量NF中保存该值。如$ awk ‘{print $1,$3}’ test将打印test文件中第一和第三个以空格分开的列(域)。</p>
<ol>
<li>域分隔符</li>
</ol>
<p>内建变量FS保存输入域分隔符的值，默认是空格或tab。我们可以通过-F命令行选项修改FS的值。如$ awk -F: ‘{print $1,$5}’ test将打印以冒号为分隔符的第一，第五列的内容。<br>可以同时使用多个域分隔符，这时应该把分隔符写成放到方括号中，如$awk -F’[:\t]’ ‘{print $1,$3}’ test，表示以空格、冒号和tab作为分隔符。<br>输出域的分隔符默认是一个空格，保存在OFS中。如$ awk -F: ‘{print $1,$5}’ test，$1和$5间的逗号就是OFS的值。</p>
<h1 id="gawk专用正则表达式元字符"><a href="#gawk专用正则表达式元字符" class="headerlink" title="gawk专用正则表达式元字符"></a>gawk专用正则表达式元字符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">\Y 匹配一个单词开头或者末尾的空字符串。</div><div class="line"></div><div class="line">\B 匹配单词内的空字符串。</div><div class="line"></div><div class="line">\&lt; 匹配一个单词的开头的空字符串，锚定开始。</div><div class="line"></div><div class="line">\&gt;匹配一个单词的末尾的空字符串，锚定末尾。</div><div class="line"></div><div class="line">\w匹配一个字母数字组成的单词。</div><div class="line"></div><div class="line">\W匹配一个非字母数字组成的单词。</div><div class="line"></div><div class="line">\‘匹配字符串开头的一个空字符串。</div><div class="line"></div><div class="line">\&apos;匹配字符串末尾的一个空字符串。</div></pre></td></tr></table></figure>
<h1 id="匹配操作符"><a href="#匹配操作符" class="headerlink" title="匹配操作符(~)"></a>匹配操作符(~)</h1><p>  用来在记录或者域内匹配正则表达式。如$ awk ‘$1 ~/^root/‘ test将显示test文件第一列中以root开头的行。</p>
<h1 id="一组例子"><a href="#一组例子" class="headerlink" title="一组例子"></a>一组例子</h1><pre><code class="angularjs">$ awk &apos;/^(no|so)/&apos; test-----打印所有以模式no或so开头的行。

$ awk &apos;/^[ns]/{print $1}&apos; test-----如果记录以n或s开头，就打印这个记录。

$ awk &apos;$1 ~/[0-9][0-9]$/(print $1}&apos; test-----如果第一个域以两个数字结束就打印这个记录。

$ awk &apos;$1 == 100 || $2 &lt; 50&apos; test-----如果第一个或等于100或者第二个域小于50，则打印该行。

$ awk &apos;$1 != 10&apos; test-----如果第一个域不等于10就打印该行。

$ awk &apos;/test/{print $1 + 10}&apos; test-----如果记录包含正则表达式test，则第一个域加10并打印出来。

$ awk &apos;{print ($1 &gt; 5 ? &quot;ok &quot;$1: &quot;error&quot;$1)}&apos; test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。

$ awk &apos;/^root/,/^mysql/&apos; test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。
</code></pre>
<h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><pre><code class="angularjs">函数名称    返回值
atan2(x,y)    y,x范围内的余切
cos(x)    余弦函数
exp(x)    求幂
int(x)    取整
log(x)    自然对数
rand()    随机数
sin(x)    正弦
sqrt(x)    平方根
srand(x)    x是rand()函数的种子
int(x)    取整，过程没有舍入
rand()    产生一个大于等于0而小于1的随机数
</code></pre>
<h1 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h1><pre><code class="angularjs">
函数名    说明 
mktime( YYYY MM dd HH MM ss[ DST])    生成时间格式 
strftime([format [, timestamp]])    格式化时间输出，将时间戳转为时间字符串 具体格式，见下表. 
systime()    得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数




格式    描述
%a    星期几的缩写(Sun)
%A    星期几的完整写法(Sunday)
%b    月名的缩写(Oct)
%B    月名的完整写法(October)
%c    本地日期和时间
%d    十进制日期
%D    日期 08/20/99
%e    日期，如果只有一位会补上一个空格
%H    用十进制表示24小时格式的小时
%I    用十进制表示12小时格式的小时
%j    从1月1日起一年中的第几天
%m    十进制表示的月份
%M    十进制表示的分钟
%p    12小时表示法(AM/PM)
%S    十进制表示的秒
%U    十进制表示的一年中的第几个星期(星期天作为一个星期的开始)
%w    十进制表示的星期几(星期天是0)
%W    十进制表示的一年中的第几个星期(星期一作为一个星期的开始)
%x    重新设置本地日期(08/20/99)
%X    重新设置本地时间(12：00：00)
%y    两位数字表示的年(99)
%Y    当前月份
%Z    时区(PDT)
%%    百分号(%)


 $ awk &apos;{ now=strftime( &quot;%D&quot;, systime() ); print now }&apos;
 $ awk &apos;{ now=strftime(&quot;%m/%d/%y&quot;); print now }&apos;
</code></pre>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><pre><code class="angularjs">gsub( Ere, Repl, [ In ] )    除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 
sub( Ere, Repl, [ In ] )    用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 
index( String1, String2 )    在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 
length [(String)]    返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 
blength [(String)]    返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 
substr( String, M, [ N ] )    返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 
match( String, Ere )    在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 
split( String, A, [Ere] )    将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 
tolower( String )    返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 
toupper( String )    返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 
sprintf(Format, Expr, Expr, . . . )
</code></pre>
<h1 id="如何把一行竖排的数据转换成横排？实用"><a href="#如何把一行竖排的数据转换成横排？实用" class="headerlink" title="如何把一行竖排的数据转换成横排？实用"></a>如何把一行竖排的数据转换成横排？实用</h1><p>awk ‘{printf(“%s,”,$1)}’ filename</p>
<h1 id="跟grep的区别是？"><a href="#跟grep的区别是？" class="headerlink" title="跟grep的区别是？"></a>跟grep的区别是？</h1><ol>
<li><p>grep用于在文件中查找特定的内容</p>
</li>
<li><p>awk可以用来加工特定的信息，用于扩展和报表</p>
</li>
<li><p>sed是流shi的文本编辑处理，可以替换，增加，删除等操作</p>
</li>
</ol>
<p>因此，awk和sed不仅可以用于查找，有自己的函数，可以完成，复杂的信息提取</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是awk这个命令&quot;&gt;&lt;a href=&quot;#今天要分享的内容是awk这个命令&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是awk这个命令&quot;&gt;&lt;/a&gt;今天要分享的内容是awk这个命令&lt;/h1&gt;&lt;p&gt;因为要看日志，以前公司业务小的时候，能下载到本地用文本工具一个一个去找，但是现在不行了&lt;/p&gt;
&lt;p&gt;面对hive大数据，根本行不通，没办法，不得不面对这个命令&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx入门系列二</title>
    <link href="http://ghohankawk.github.io/2017/06/29/nginx2/"/>
    <id>http://ghohankawk.github.io/2017/06/29/nginx2/</id>
    <published>2017-06-29T03:12:32.223Z</published>
    <updated>2017-07-14T11:33:01.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是还是nginx相关"><a href="#今天要分享的内容是还是nginx相关" class="headerlink" title="今天要分享的内容是还是nginx相关"></a>今天要分享的内容是还是nginx相关</h1> <a id="more"></a> 
<h1 id="Nginx-重写规则指南"><a href="#Nginx-重写规则指南" class="headerlink" title="Nginx 重写规则指南"></a>Nginx 重写规则指南</h1><p>既然你看到这里，我想，不用问，你也肯定知道，nginx是运维要玩的东西，开发不直接管，那么</p>
<p>记住一句话：<br>不懂程序的运维，不是好运维；不懂运维的开发，不是 好开发。</p>
<p>对于重写规则 说到底就是正则匹配，同时，如果想把 apache 转换成 nginx，重写规则也是要改的咯。</p>
<ol>
<li><p>rewrite 模块介绍</p>
<p>nginx 的重写模块是一个简单的正则表达式匹配与一个虚拟堆叠机结合。依赖于 PCRE 库，因此需要安装 pcre。根 据相关变量重定向和选择不同的配置，从一个 location 跳转到另一个 location，不过这样的循环最多可以执行 10 次，超过后 nginx 将返回 500 错误。同时，重写模块包含 set 指令，来创建新的变量并设其值，这在有些情景 下非常有用的，如记录条件标识、传递参数到其他 location、记录做了什么等等。</p>
</li>
<li><p>rewrite 模块指令</p>
<pre><code>break 
语法：break 默认值：none
使用字段：server, location, if 完成当前设置的重写规则，停止执行其他的重写规则。

if
语法：if (condition) { … } 默认值：none 
使用字段：server, location
注意：尽量考虑使用 trp_files 代替。 判断的条件可以有以下值：
1. 一个变量的名称：空字符传”“或者一些“0”开始的字符串为 false。
2. 字符串比较：使用=或!=运算符
3. 正则表达式匹配：使用~(区分大小写)和~*(不区分大小写)，取反运算!~和!~*。
4. 文件是否存在：使用-f 和!-f 操作符
5. 目录是否存在：使用-d 和!-d 操作符
7. 文件、目录、符号链接是否存在：使用-e 和!-e 操作符
8. 文件是否可执行：使用-x 和!-x 操作符

return 
语法：return code 默认值：none
使用字段：server, location, if
停止处理并为客户端返回状态码。非标准的 444 状态码将关闭连接，不发送任何响应头。】
可以使用的状态码有：
204，400，402-406，408，410, 411, 413, 416 与 500-504。如果状态码附带文字段落，该文本将被放置在响应 主体。相反，如果状态码后面是一个 URL，该 URL 将成为 location 头补值。没有状态码的 URL 将被视为一个 302 状态码。

rewrite
语法：rewrite regex replacement flag 默认值：none
使用字段：server, location, if
按照相关的正则表达式与字符串修改 URI，指令按照在配置文件中出现的顺序执行。可以在重写指令后面添加标记。
注意：如果替换的字符串以 http://开头，请求将被重定向，并且不再执行多余的 rewrite 指令。 

尾部的标记(flag)可以是以下的值：
last – 停止处理重写模块指令，之后搜索 location 与更改后的 URI 匹配。 
break – 完成重写指令。
redirect – 返回 302 临时重定向，如果替换字段用 http://开头则被使用。 
permanent – 返回 301 永久重定向。

rewrite_log 语法：rewrite_log on | off 默认值：rewrite_log off
使用字段：server, location, if 变量：无
启用时将在 error log 中记录 notice 级别的重写日志。

set
语法：set variable value 默认值：none  
使用字段：server, location, if 为给定的变量设置一个特定值。
uninitialized_variable_warn 
语法：uninitialized_variable_warn on|off 默认值：uninitialized_variable_warn on 
使用字段：http, server, location, if 控制是否记录未初始化变量的警告信息。
</code></pre></li>
</ol>
<ol>
<li>重写规则组成部分</li>
</ol>
<ul>
<li><p>任何重写规则的第一部分都是一个正则表达式 可以使用括号来捕获，后续可以根据位置来将其引用，位置变量值取决于捕获正则表达式中的顺序，$1 引用第一 个括号中的值，$2 引用第二个括号中的值，以此类推。如：</p>
<pre><code>^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$
</code></pre><p>$1 是两个小写字母组成的字符串，$2 是由小写字母和 0 到 9 的数字组成的 5 个字符的字符串，$3 将是个文件名，<br>$4 是 png、jpg、gif 中的其中一个。</p>
</li>
<li><p>重写规则的第二部分是 URI<br>请求被改写。该 URI 可能包含正则表达式中的捕获的位置参数或这个级别下的 nginx 任何配置变量。如：<br>/data?file=$3.$4<br>如果这个 URI 不匹配 nginx 配置的任何 location，那么将给客户端返回 301(永久重定向)或 302(临时重定向)的状 态码来表示重定向类型。该状态码可以通过第三个参数来明确指定。</p>
</li>
</ul>
<ul>
<li><p>重写规则的第三部分<br>第三部分也就是尾部的标记(flag)。 last 标记将导致重写后的 URI 搜索匹配 nginx 的其他 location，最多可循 环 10 次。如：</p>
<pre><code>rewrite    &apos;^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$&apos;    /data?file=$3.$4 last; break 指令可以当做自身指令。如：
if ($bwhog) {
limit_rate 300k; break;
}
</code></pre></li>
</ul>
<p>另一个停止重写模块处理指令是 return， 来控制主 HTTP 模块处理请求。 这意味着，nginx 直接返回信息给客户 端，与 error_page 结合为客户端呈现格式化的 HTML 页面或激活不同的模块来完成请求。如果状态码附带文字段 落，该文本将被放置在响应主体。相反，如果状态码后面是一个 URL，该 URL 将成为 location 头补值。没有状态 码的 URL 将被视为一个 302 状态码。如：</p>
<pre><code>location = /image404.html {
return    404    &quot;image not found\n&quot;;
}
</code></pre><ol>
<li><p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">#  定义 image 日志格式</div><div class="line">log_format imagelog &apos;[$time_local] &apos; $image_file &apos; &apos; $image_type &apos; &apos; $body_bytes_sent &apos; &apos; $status;</div><div class="line">#  开启重写日志</div><div class="line">rewrite_log on;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">root /home/www;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">#  重写规则信息</div><div class="line">error_log logs/rewrite.log notice;</div><div class="line">#  注意这里要用‘’单引号引起来，避免&#123;&#125;</div><div class="line">rewrite &apos;^/images/([a-z]&#123;2&#125;)/([a-z0-9]&#123;5&#125;)/(.*)\.(png|jpg|gif)$&apos; /data?file=$3.$4;</div><div class="line">#  注意不能在上面这条规则后面加上“last”参数，否则下面的 set 指令不会执行</div><div class="line">set $image_file $3; set $image_type $4;</div><div class="line">&#125;</div><div class="line">location /data &#123;</div><div class="line">#  指定针对图片的日志格式，来分析图片类型和大小</div><div class="line">access_log logs/images.log mian; root /data/images;</div><div class="line">#   应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最</div><div class="line"> </div><div class="line">后一个 url 里</div><div class="line"></div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line">try_files /$arg_file /image404.html;</div><div class="line"> </div><div class="line">location = /image404.html &#123;</div><div class="line">#  图片不存在返回特定的信息</div><div class="line">return 404 &quot;image not found\n&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>nginx 逻辑运算<br>nginx 的配置中不支持 if 条件的逻辑与&amp;&amp; 逻辑或|| 运算 ，而且不支持 if 的嵌套语法，否则会报下面的错误： nginx: [emerg] invalid condition。<br>我们可以用变量的方式来间接实现。 要实现的语句：</p>
<pre><code>if    ($arg_unitid = 42012 &amp;&amp; $uri ~/thumb/){ echo        &quot;www.ttlsa.com&quot;;
}
</code></pre></li>
</ol>
<p>   如果按照这样来配置，就会报 nginx: [emerg] invalid condition 错误。 可以这么来实现，如下所示：</p>
<pre><code>set    $flag 0;
if ($uri ~ ^/thumb/[0-9]+_160.jpg$){ set $flag &quot;${flag}1&quot;;
}
if ($arg_unitid = 42012){ set $flag &quot;${flag}1&quot;;
}
if ($flag = &quot;011&quot;){ echo &quot;www.ttlsa.com&quot;;
}
</code></pre><ol>
<li><p>隐藏 Nginx 版本号的安全性与方法</p>
<pre><code># vim nginx.conf
在 http {—}里加上 server_tokens off;    如：
</code></pre></li>
<li><p>nginx 正向代理</p>
<p>我们平时用的最多的最常见的是反向代理。那么 nginx 的正向代理是如何配置的呢？</p>
<pre><code>server {
listen 8090; location / {
resolver 218.85.157.99 218.85.152.99;
resolver_timeout 30s;
proxy_pass http://$host$request_uri;
}
access_log    /data/httplogs/proxy-$host-aceess.log;
}
</code></pre><p>就这么简单哈。  </p>
<p>resolver 指令<br>语法: resolver address … [valid=time]; 默认值: none<br>配置段: http, server, location<br>配置 DNS 服务器 IP 地址。可以指定多个，以轮询方式请求。<br>nginx 会缓存解析的结果。默认情况下，缓存时间是名字解析响应中的 TTL 字段的值，可以通过 valid 参数更改。</p>
<p>resolver_timeout 指令<br>语法: resolver_timeout time; 默认值: resolver_timeout 30s;<br>配置段: http, server, location 解析超时时间。</p>
</li>
<li><p>nginx的最大好处，例子解释</p>
</li>
</ol>
<p>由于公司内网有多台服务器的 http 服务要映射到公司外网静态 IP，如果用路由的端口映射来做，就只能一台内网 服务器的 80 端口映射到外网 80 端口，其他服务器的 80 端口只能映射到外网的非 80 端口。非 80 端口的映射在访<br>问的时候要域名加上端口，比较麻烦。并且公司入口路由最多只能做 20 个端口映射。肯定以后不够用。<br>然后 k 兄就提议可以在内网搭建个 nginx 反向代理服务器，将 nginx 反向代理服务器的 80 映射到外网 IP 的 80， 这样指向到公司外网 IP 的域名的 HTTP 请求就会发送到 nginx 反向代理服务器，利用 nginx 反向代理将不同域名 的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器 的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>关于一些，高级的概念，还有第三方模块，这些内容就不属于入门级别的了</p>
<p>这两篇的意义，在于，你能初步，能看懂nginx的配置文件，每个配置的含义，以及初步的开发跳转，基本足够了</p>
<p>等后续，碰到这些高级的概念或者应用的时候，在去看</p>
<p>不是为了单纯的学习而学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是还是nginx相关&quot;&gt;&lt;a href=&quot;#今天要分享的内容是还是nginx相关&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是还是nginx相关&quot;&gt;&lt;/a&gt;今天要分享的内容是还是nginx相关&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx入门系列一</title>
    <link href="http://ghohankawk.github.io/2017/06/28/nginx/"/>
    <id>http://ghohankawk.github.io/2017/06/28/nginx/</id>
    <published>2017-06-28T07:45:35.736Z</published>
    <updated>2017-07-14T11:33:01.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是nginx的基本知识"><a href="#今天要分享的内容是nginx的基本知识" class="headerlink" title="今天要分享的内容是nginx的基本知识"></a>今天要分享的内容是nginx的基本知识</h1><a id="more"></a> 
<h1 id="先看一下conf文件解释"><a href="#先看一下conf文件解释" class="headerlink" title="先看一下conf文件解释"></a>先看一下conf文件解释</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"># vi nginx.conf</div><div class="line"></div><div class="line">user	nobody nobody; #	运行 nginx 的所属组和所有者</div><div class="line"></div><div class="line">worker_processes	2; #	开启两个 nginx 工作进程,一般几个 CPU 核心就写几 </div><div class="line"></div><div class="line">error_log	logs/error.log	notice; #	错误日志路径</div><div class="line"></div><div class="line">pid	logs/nginx.pid; # pid 路径 </div><div class="line"></div><div class="line">events &#123;</div><div class="line">    worker_connections	1024; #	一个进程能同时处理 1024 个请求</div><div class="line">    &#125;</div><div class="line">http &#123;</div><div class="line"></div><div class="line">include		mime.types; </div><div class="line"></div><div class="line">default_type	application/octet-stream;</div><div class="line"></div><div class="line">log_format	main	‘$remote_addr – $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘</div><div class="line">‘”$http_user_agent” “$http_x_forwarded_for”‘; </div><div class="line"></div><div class="line">access_log	logs/access.log	main; #	默认访问日志路径 sendfile		on;</div><div class="line"></div><div class="line">keepalive_timeout	65; # keepalive 超时时间</div><div class="line"></div><div class="line">#	开始配置一个域名,一个 server 配置段一般对应一个域名 </div><div class="line"></div><div class="line">server &#123;</div><div class="line">    </div><div class="line">listen	80; </div><div class="line"></div><div class="line">#	在本机所有 ip 上监听 80,也可以写为 192.168.1.202:80,这样的话,就只监听 192.168.1.202 上的 80 口 </div><div class="line"></div><div class="line">server_name	www.heytool.com; #	域名</div><div class="line"></div><div class="line">root		/www/html/www.heytool.com; #	站点根目录（程序目录）</div><div class="line"></div><div class="line">index	index.html index.htm; #	索引文件</div><div class="line"></div><div class="line">location / &#123;	#	可以有多个 location</div><div class="line">    root	/www/html/www.heytool.com; #	站点根目录（程序目录）</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">error_page	500 502 503 504	/50x.html;</div><div class="line"></div><div class="line">#	定义错误页面,如果是 500 错误,则把站点根目录下的 50x.html 返回给用户 </div><div class="line"></div><div class="line">location = /50x.html &#123;</div><div class="line">    root	/www/html/www.heytool.com;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#	开始配置站点</div><div class="line"> </div><div class="line">bbs.heytool.com server &#123;</div><div class="line">    listen	80;</div><div class="line">    server_name	bbs.heytool.com;  </div><div class="line">    root	/www/html/bbs.heytool.com;</div><div class="line">    index	index.html index.htm; #	索引文件 </div><div class="line">    location / &#123;</div><div class="line">    root	/www/html/bbs.heytool.com;</div><div class="line">      &#125;</div><div class="line">    error_page	500 502 503 504	/50x.html; </div><div class="line">    location = /50x.html &#123;</div><div class="line">    root	/www/html/bbs.heytool.com;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="nginx-启动，测试，关闭，重启"><a href="#nginx-启动，测试，关闭，重启" class="headerlink" title="nginx 启动，测试，关闭，重启"></a>nginx 启动，测试，关闭，重启</h1><pre><code># /usr/local/nginx-1.0.6/sbin/nginx    //启动 nginx
# /usr/local/nginx-1.0.6/sbin/nginx –t //测试 nginx 配置文件的准确性
# /usr/local/nginx-1.0.6/sbin/nginx –s reload //重载 nginx
# /usr/local/nginx-1.0.6/sbin/nginx –s stop //关闭 nginx
</code></pre><h1 id="nginx-配置虚拟主机"><a href="#nginx-配置虚拟主机" class="headerlink" title="nginx 配置虚拟主机"></a>nginx 配置虚拟主机</h1><p>也就是我们通常说的配置域名.</p>
<pre><code>server_name：虚拟主机的域名，可以写多个域名，类似于别名，比如说你可以配置成
server_name b.ttlsa.com c.ttlsa.com d.ttlsa.com，这样的话，访问任何一个域名，内容都是一样的 listen 80，监听 ip 和端口，这边仅仅只有端口，表示当前服务器所有 ip 的 80 端口，如果只想监听 127.0.0.1 的 80，写法如下：
listen 127.0.0.1:80
root /data/site/b.ttlsa.com：站点根目录，你网站文件存放的地方。注：站点目录和域名尽量一样，养成一个 好习惯
access_log /data/logs/nginx/b.ttlsa.com-access.log main：访问日志 location /{}
</code></pre><h1 id="nginx-location-配置"><a href="#nginx-location-配置" class="headerlink" title="nginx location 配置"></a>nginx location 配置</h1><p>语法规则： location [=|~|~*|^~] /uri/ { … }</p>
<ol>
<li>= 表示精确匹配,这个优先级也是最高的</li>
<li>^~ 表示 uri 以某个常规字符串开头，理解为匹配 url 路径即可。<br>nginx 不对 url 做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa 匹配到（注意是空格）。</li>
<li>~    表示区分大小写的正则匹配</li>
<li>~* 表示不区分大小写的正则匹配(和上面的唯一区别就是大小写)</li>
<li>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则</li>
<li>/ 通用匹配，任何请求都会匹配到，默认匹配. </li>
</ol>
<p>多个 location 配置的情况下匹配顺序为：</p>
<p>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止 匹配，按当前匹配规则处理请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">例子，有如下匹配规则： </div><div class="line">location / </div><div class="line">    &#123;</div><div class="line">        echo &quot;/&quot;; //需要安装 echo 模块才行,这边大家可以改成各自的规则</div><div class="line">    &#125;</div><div class="line">location = / </div><div class="line">    &#123; </div><div class="line">    echo &quot;=/&quot;;</div><div class="line">    &#125;</div><div class="line">location = /nginx </div><div class="line">    &#123; </div><div class="line">    echo &quot;=/nginx&quot;;</div><div class="line">    &#125;</div><div class="line">location ~ \.(gif|jpg|png|js|css)$ </div><div class="line">    &#123; echo &quot;small-gif/jpg/png&quot;;</div><div class="line">    &#125;</div><div class="line">location ~* \.png$ </div><div class="line">    &#123; echo &quot;all-png&quot;;</div><div class="line">    &#125;</div><div class="line">location ^~ /static/ </div><div class="line">    &#123; echo &quot;static&quot;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>那么</p>
<ol>
<li><a href="http://a.ttlsa.com/，完全匹配=/" target="_blank" rel="external">http://a.ttlsa.com/，完全匹配=/</a></li>
<li><a href="http://a.ttlsa.com/nginx,完全匹配了”=/nginx”" target="_blank" rel="external">http://a.ttlsa.com/nginx,完全匹配了”=/nginx”</a></li>
<li><a href="http://a.ttlsa.com/xxx/1111.PNG" target="_blank" rel="external">http://a.ttlsa.com/xxx/1111.PNG</a> （注意,这是大写），最后匹配到了~* .png$</li>
<li><a href="http://a.ttlsa.com/static/1111.png,虽然" target="_blank" rel="external">http://a.ttlsa.com/static/1111.png,虽然</a> static 放在最后面,但是因为有^的缘故,他是最匹配的.</li>
</ol>
<h1 id="nginx-root-amp-alias-文件路径配置"><a href="#nginx-root-amp-alias-文件路径配置" class="headerlink" title="nginx root&amp;alias 文件路径配置"></a>nginx root&amp;alias 文件路径配置</h1><p>nginx 指定文件路径有两种方式 root 和 alias，root 与 alias 主要区别在于 nginx 如何解释 location 后面的 uri，这会使两者分别以不同的方式将请求映射到 服务器文件上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">例子一：</div><div class="line">location ~ ^/weblogs/ &#123;</div><div class="line">root /data/weblogs/www.ttlsa.com; autoindex on;</div><div class="line">auth_basic	&quot;Restricted&quot;; auth_basic_user_file	passwd/weblogs;</div><div class="line">&#125;</div><div class="line">如果一个请求的 URI 是/weblogs/httplogs/www.ttlsa.com-access.log 时，web 服务器将会返回服务器上的</div><div class="line">/data/weblogs/www.ttlsa.com/weblogs/httplogs/www.ttlsa.com-access.log 的文件。 [info]root 会根据完整的 URI 请求来映射，也就是/path/uri。[/info] 因此，前面的请求映射为 path/weblogs/httplogs/www.ttlsa.com-access.log。</div><div class="line"></div><div class="line">例子二：</div><div class="line"></div><div class="line"></div><div class="line">location ^~ /binapp/ &#123;</div><div class="line">limit_conn limit 4; limit_rate 200k; internal;</div><div class="line">alias /data/statics/bin/apps/;</div><div class="line">&#125;</div><div class="line">alias 会把 location 后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。如果一个请求的 URI 是</div><div class="line">/binapp/a.ttlsa.com/favicon 时，web 服务器将会返回服务器上的</div><div class="line">/data/statics/bin/apps/a.ttlsa.com/favicon.jgp 的文件。 [warning]1. 使用 alias 时，目录名后面一定要加”/”。</div><div class="line">2. alias 可以指定任何名称。</div><div class="line">3. alias 在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</div><div class="line">4.	alias 只能位于 location 块中。[/warning]</div></pre></td></tr></table></figure></p>
<p>总结一下，就是，root相当于是根，特别之处根是在什么地方，</p>
<p>而alias是别号，也就是映射的那个路径，还可以是其他的别的地方，因此本身要去掉</p>
<h1 id="nginx变量"><a href="#nginx变量" class="headerlink" title="nginx变量"></a>nginx变量</h1><p>ngx_http_core_module 模块提供了大量的变量</p>
<pre><code>参数名称    注释
$arg_PARAMETER    HTTP 请求中某个参数的值，如/index.php?site=www.ttlsa.com，可以用$arg_site 取 得 www.ttlsa.com 这个值.
$args HTTP    请求中的完整参数。例如，在请求/index.php?width=400&amp;height=200 中，$args 表示 字符串 width=400&amp;height=200.
$binary_remote_addr    二进制格式的客户端地址。例如：\x0A\xE0B\x0E
$body_bytes_sent       表示在向客户端发送的 http 响应中，包体部分的字节数
$content_length         表示客户端请求头部中的 Content-Length 字段
$content_type    表示客户端请求头部中的 Content-Type 字段
$cookie_COOKIE          表示在客户端请求头部中的 cookie 字段
$document_root          表示当前请求所使用的 root 配置项的值
$uri    表示当前请求的 URI，不带任何参数
$document_uri    与$uri 含义相同
$request_uri    表示客户端发来的原始请求 URI，带完整的参数。$uri 和$document_uri 未必是用户的 原始请求，在内部重定向后可能是重定向后的 URI，而$request_uri 永远不会改变，始终是客户端的原始 URI.
$host    表示客户端请求头部中的 Host 字段。如果 Host 字段不存在，则以实际处理的 server
（虚拟主机）名称代替。如果 Host 字段中带有端口，如 IP:PORT，那么$host 是去掉端口的，它的值为 IP。$host 是全小写的。这些特性与 http_HEADER 中的 http_host 不同，http_host 只取出 Host 头部对应的值。
$hostname    表示 Nginx 所在机器的名称，与 gethostbyname 调用返回的值相同
$http_HEADER    表示当前 HTTP 请求中相应头部的值。HEADER 名称全小写。例如，示请求中 Host 头部 对应的值    用 $http_host 表
$sent_http_HEADER    表示返回客户端的 HTTP 响应中相应头部的值。HEADER 名称全小写。例如，用 $sent_ http_content_type 表示响应中 Content-Type 头部对应的值
$is_args    表示请求中的 URI 是否带参数，如果带参数，$is_args 值为 ?，如果不带参数，则是 空字符串
$limit_rate    表示当前连接的限速是多少，0 表示无限速
$nginx_version          表示当前 Nginx 的版本号
$query_string    请求 URI 中的参数，与 $args 相同，然而 $query_string 是只读的不会改变
$remote_addr    表示客户端的地址
$remote_port    表示客户端连接使用的端口
$remote_user    表示使用 Auth Basic Module 时定义的用户名
$request_filename     表示用户请求中的 URI 经过 root 或 alias 转换后的文件路径
$request_body    表示 HTTP 请求中的包体，该参数只在 proxy_pass 或 fastcgi_pass 中有意义
$request_body_file      表示 HTTP 请求中的包体存储的临时文件名
$request_completion    当请求已经全部完成时，其值为 “ok”。若没有完成，就要返回客户端，则其值为空字 符串；或者在断点续传等情况下使用 HTTP range 访问的并不是文件的最后一块，那么其值也是空字符串。
$request_method        表示 HTTP 请求的方法名，如 GET、PUT、POST 等
$scheme    表示 HTTP scheme，如在请求 https://nginx.com/中表示 https
$server_addr    表示服务器地址
$server_name    表示服务器名称
$server_port    表示服务器端口
$server_protocol        表示服务器向客户端发送响应的协议，如 HTTP/1.1 或 HTTP/1.0
</code></pre><h1 id="nginx-日志配置"><a href="#nginx-日志配置" class="headerlink" title="nginx 日志配置"></a>nginx 日志配置</h1><p>日志对于统计排错来说非常有利的。 日志格式通过 log_format 命令来定义。ngx_http_log_module 是用来定义请求日志格式的。</p>
<ol>
<li>access_log<br>语法: access_log path [format [buffer=size [flush=time]]];<br>默认值: access_log logs/access.log combined;</li>
<li>log_format 指令<br>语法: log_format name string …;<br>默认值: log_format combined “…”<br>有一个默认的无需设置的 combined 日志格式，相当于 apache 的 combined 日志格式，如下所示：</li>
</ol>
<pre><code>log_format    combined    &apos;$remote_addr - $remote_user    [$time_local]    &apos;
&apos; &quot;$request&quot;    $status    $body_bytes_sent    &apos; &apos; &quot;$http_referer&quot;    &quot;$http_user_agent&quot; &apos;;


log_format    proxy    &apos;$http_x_forwarded_for - $remote_user    [$time_local]    &apos; &apos; &quot;$request&quot;    $status $body_bytes_sent &apos;
&apos; &quot;$http_referer&quot;    &quot;$http_user_agent&quot; &apos;; 
</code></pre><ol>
<li>日志格式变量</li>
</ol>
<pre><code>$remote_addr, $http_x_forwarded_for 记录客户端 IP 地址
$remote_user 记录客户端用户名称
$request 记录请求的 URL 和 HTTP 协议
$status 记录请求状态
$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与 Apache 模块 mod_log_config 里的 “%B”参数兼容。
$bytes_sent 发送给客户端的总字节数。
$connection 连接的序列号。
$connection_requests 当前通过一个连接获得的请求数量。
$msec 日志写入时间。单位为秒，精度是毫秒。
$pipe 如果请求是通过 HTTP 流水线(pipelined)发送，pipe 值为“p”，否则为“.”。
$http_referer 记录从哪个页面链接访问过来的
$http_user_agent 记录客户端浏览器相关信息
$request_length 请求的长度（包括请求行，请求头和请求正文）。
$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送 给客户端后进行日志写入为止。
$time_iso8601 ISO8601 标准格式下的本地时间。
$time_local 通用日志格式下的本地时间。
</code></pre><ol>
<li><p>open_log_file_cache 指令</p>
<p>语法: open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time]; open_log_file_cache off;<br>默认值: open_log_file_cache off;<br>配置段: http, server, location<br>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用 open_log_file_cache 来设置日志 文件缓存(默认是 off)，格式如下：<br>参数注释如下：<br>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用 LRU 算法将描述符关闭。 inactive:设置存活时间，默认是 10s<br>min_uses:设置在 inactive 时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是 1 次 valid:设置检查频率，默认 60s<br>off：禁用缓存 实例如下：</p>
<pre><code>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</code></pre></li>
<li><p>log_not_found 指令</p>
<p> 语法: log_not_found on | off;<br> 默认值: log_not_found on;<br> 配置段: http, server, location<br> 是否在 error_log 中记录不存在的错误。默认是。</p>
</li>
<li><p>log_subrequest 指令</p>
<p>语法: log_subrequest on | off;<br>默认值: log_subrequest off;<br>配置段: http, server, location<br>是否在 access_log 中记录子请求的访问日志。默认不记录。</p>
</li>
<li><p>rewrite_log 指令</p>
<p>由 ngx_http_rewrite_module 模块提供的。用来记录重写日志的。对于调试重写规则建议开启。    Nginx 重写规则 指南<br>语法: rewrite_log on | off; 默认值: rewrite_log off;<br>配置段: http, server, location, if<br>启用时将在 error log 中记录 notice 级别的重写日志。</p>
</li>
<li><p>error_log 指令</p>
<p>语法: error_log file | stderr | syslog:server=address[,parameter=value] [debug | info | notice | warn | error | crit | alert | emerg];<br>默认值: error_log logs/error.log error;<br>配置段: main, http, server,<br>location 配置错误日志。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是nginx的基本知识&quot;&gt;&lt;a href=&quot;#今天要分享的内容是nginx的基本知识&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是nginx的基本知识&quot;&gt;&lt;/a&gt;今天要分享的内容是nginx的基本知识&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中string的不可不知的编码知识</title>
    <link href="http://ghohankawk.github.io/2017/06/27/java-encode/"/>
    <id>http://ghohankawk.github.io/2017/06/27/java-encode/</id>
    <published>2017-06-27T12:00:21.421Z</published>
    <updated>2017-07-14T11:33:01.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java的string的字符串编码"><a href="#今天要分享的内容是java的string的字符串编码" class="headerlink" title="今天要分享的内容是java的string的字符串编码"></a>今天要分享的内容是java的string的字符串编码</h1><a id="more"></a> 
<h1 id="首先记住一句话，字符串在-java-内存中总是按-unicode-编码存储的"><a href="#首先记住一句话，字符串在-java-内存中总是按-unicode-编码存储的" class="headerlink" title="首先记住一句话，字符串在 java 内存中总是按 unicode 编码存储的"></a>首先记住一句话，字符串在 java 内存中总是按 unicode 编码存储的</h1><h1 id="先看一个测试用例"><a href="#先看一个测试用例" class="headerlink" title="先看一个测试用例"></a>先看一个测试用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-27 14:24</div><div class="line"> */</div><div class="line">public class unicode &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 字符串转换unicode</div><div class="line">     */</div><div class="line">    public static String string2Unicode(String string) &#123;</div><div class="line"></div><div class="line">        StringBuffer unicode = new StringBuffer();</div><div class="line">        for (int i = 0; i &lt; string.length(); i++) &#123;</div><div class="line"></div><div class="line">            // 取出每一个字符</div><div class="line">            char c = string.charAt(i);</div><div class="line"></div><div class="line">            // 转换为unicode</div><div class="line">            unicode.append(&quot;\\u&quot; + Integer.toHexString(c));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return unicode.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * unicode 转字符串</div><div class="line">     */</div><div class="line">    public static String unicode2String(String unicode) &#123;</div><div class="line"></div><div class="line">        StringBuffer string = new StringBuffer();</div><div class="line"></div><div class="line">        String[] hex = unicode.split(&quot;\\\\u&quot;);</div><div class="line"></div><div class="line">        for (int i = 1; i &lt; hex.length; i++) &#123;</div><div class="line"></div><div class="line">            // 转换出每一个代码点</div><div class="line">            int data = Integer.parseInt(hex[i], 16);</div><div class="line"></div><div class="line">            // 追加成string</div><div class="line">            string.append((char) data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return string.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 测试字符串长度</div><div class="line">     */</div><div class="line">    public static void stringLength(String string) &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;String is = &quot; + string+&quot; ,default length = &quot;+ string.length());</div><div class="line">        System.out.println(&quot;String is = &quot; + string+&quot; ,getBytes length = &quot;+ string.getBytes().length);</div><div class="line">        System.out.println(&quot;String 中包含 &quot; + (string.getBytes().length-string.length())+&quot; 个中文&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String test = &quot;中文ab&quot;;</div><div class="line"></div><div class="line">        String unicode = string2Unicode(test);</div><div class="line"></div><div class="line">        String string = unicode2String(unicode) ;</div><div class="line"></div><div class="line">        System.out.println(unicode);</div><div class="line"></div><div class="line">        System.out.println(string);</div><div class="line">        String test1 = &quot;中文&quot;;</div><div class="line">        String test2 = &quot;ab&quot;;</div><div class="line">        stringLength(test);</div><div class="line">        stringLength(test1);</div><div class="line">        stringLength(test2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子里面，还提供了一个，快速判断，字符串中，包含的中文个数方法</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>首先，Java中的一个char是2个字节。java采用unicode，2个字节来表示一个字符，这点与C语言中不同，c语言中采用ASCII，在大多数系统中，一个char通常占1个字节，但是在0~127整数之间的字符映射，unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节，但如果采用其他编码方式，一个字符占用的字节数则各不相同。</p>
<p>在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。</p>
<pre><code>我的系统的默认编码方式为GBK，因此对于字符串 “中文ab”，
 如果调用length（）方法返回其长度，得到的结果将为：4。该方法返回的是字符串的字符数，无论是中文字符还是英文字符，都被看做是一个字符。
 如果将其转换为byte数组，而后返回byte数组的长度，得到的结果将为：6。因为在GBK编码中，中文占2个字节，而英文字符占1个字节。
</code></pre><h1 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h1><p>  字符：人们使用的记号，抽象意义上的一个符号。比如：‘1’,‘中’,‘a’</p>
<p>  字节：计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间</p>
<p>  字符集：使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。</p>
<p>  编码：规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码” </p>
<p>  平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。</p>
<h1 id="iso8859－1"><a href="#iso8859－1" class="headerlink" title="iso8859－1"></a>iso8859－1</h1><p>属于单字节编码，最多能表示的字符范围是 0-255，应用于英文系列。比如，字母 ‘a’ 的编码为0x61=97。 很明显，iso8859-1 编码表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用 iso8859-1 编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在 iso8859-1 编码，以 gb2312 编码为例，应该是”d6d0 cec4” 两个字符，使用 iso8859-1 编码的时候则将它拆开为 4 个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是 UTF 编码，则是 6 个字节 “e4 b8 ad e6 96 87”。很明显，这种表示方法还需要以另一种编码为基础。（unicode）</p>
<h1 id="GB2312-GBK"><a href="#GB2312-GBK" class="headerlink" title="GB2312/GBK"></a>GB2312/GBK</h1><p>这是汉字的国标码，专门用来表示汉字，是双字节编码，而英文字母和 iso8859-1 一致（兼容iso8859-1 编码）。其中 gbk 编码能够用来同时表示繁体字和简体字，而 gb2312 只能表示简体字，gbk是兼容gb2312 编码的。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>这是最统一的编码，可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容 iso8859-1 编码的，也不兼容任何编码。不过，相对于iso8859-1 编码来说，unicode 编码只是在前面增加了一个 0 字节，比如字母 ‘a’ 为 “00 61”。 需要说明的是，定长编码便于计算机处理（注意 GB2312/GBK 不是定长编码），而 unicode 又可以用来表示所有字符，所以在很多软件内部是使用 unicode 编码来处理的，比如 java。</p>
<h1 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h1><p>考虑到 unicode 编码不兼容 iso8859-1 编码，而且容易占用更多的空间：因为对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便于传输和存储。因此而产生了 utf 编码，utf 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符，不过，utf 编码是不定长编码，每一个字符的长度从1-6个字节不等。另外，utf 编码自带简单的校验功能。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节。注意，虽然说utf是为了使用更少的空间而使用的，但那只是相对于 unicode编码来说，如果已经知道是汉字，则使用 GB2312/GBK 无疑是最节省的。不过另一方面，值得说明的是，虽然 utf 编码对汉字使用3个字节，但即使对于汉字网页，utf 编码也会比 unicode 编码节省，因为网页中包含了很多的英文字符。</p>
<h1 id="getBytes-charset"><a href="#getBytes-charset" class="headerlink" title="getBytes(charset)"></a>getBytes(charset)</h1><pre><code>这是 java 字符串处理的一个标准函数，其作用是将字符串所表示的字符按照 charset 编码，并以字节方式表示。
注意字符串在 java 内存中总是按 unicode 编码存储的。
当Java程序从输入流、文件或字符文字量等途径获得字符串时，均会做字符编码的转换，例如InputStreamReader 的构造函数中就需要指定编码方式，而对于从文件和字符文字量中获得字符串时，均采用系统默认的编码方式对字符数据进行解码。
</code></pre><p>考虑下面一段代码： </p>
<pre><code>String str=”中”;
① byte[] bytes = str.getBytes();
② bytes = str.getBytes(“ISO-8859-1”);
</code></pre><p> 语句①：将一个只含有一个字符“中”的字符串文字量赋给 String 类的一个对象 str，字符文字量“中”是按照操作系统默认编码方式进行编码，在中文 windows 系统中通常是“GBK”，“中”在GBK编码中是0xD6D0，在将该字符赋给str时，Java会对该字符串进行编码转换，即将GBK编码方式的“中”转换成Unicode编码方式的“中”，Unicode编码方式“中”的编码是0x4E2D，所以str在程序运行期间在内存中的二进制表示成16进制就是0x4E2D。</p>
<p> 语句②：获得str字符串的二进制形式。getBytes(String encoding)方法需要指定编码方式，表示获得该字符串在何种编码方式中的二进制形式。此语句中没有设置参数，表示采用操作系统默认的编码方式，即此处获得的bytes是“中”在GBK编码中的二进制形式，即bytes[0]=0xD6, bytes[1]=0xD0。</p>
<p> 语句③：该语句与语句②的区别就是指定了编码方式，此处指定的是ISO-8859-1，即通常所说的Latin-1，该编码采用8bit对字符编码，所以编码空间中只有256个字符。该编码中只包含了基本的ASCII码和一些扩展的其它西欧字符，所以该字符集中不可能包含中文的“中”字，也就是说Java虚拟机无法在ISO-8859-1编码集中找到“中”字对应的编码，针对这种情况，就只返回一个问号(?,0x3f)字符，所以此时bytes.length只有1，且bytes[0]=0x3f。</p>
<h1 id="new-String-byte-bytes-String-encoding"><a href="#new-String-byte-bytes-String-encoding" class="headerlink" title="new String(byte[] bytes, String encoding)"></a>new String(byte[] bytes, String encoding)</h1><pre><code>getBytes()方法从字符串获得二进制的字节数组。如果要从二进制的字节数组获得字符串，则就需要使用new String(byte[] bytes, String encoding)方法，该方法按照encoding编码方法对字节数组bytes中的二进制数组进行解析，生成一个新的字符串对象。

  byte[] bytes = {(byte)0xD6, (byte)0xD0, (byte)0x31};
  ① String str = new String(bytes);
  ② str = new String(bytes,”ISO-8859-1”);
</code></pre><p>语句①：定义一个字节数组。</p>
<p>语句②：将该字节数组中的二进制数据按照默认的编码方式（GBK）编码成字符串，我们知道GBK中0xD6 0xD0表示“中”，0x31表示字符“1”（GBK兼容ASCII，但不兼容ISO-8859-1除ASCII之外的部分），所以str得到的值是“中1”。</p>
<p>语句③：该句用ISO-8859-1编码方式对该字节数据进行编码，由于在ISO-8859-1编码方式中一个字节会被解析成一个字符，所以该字节数组会被解释成包含三个字符的字符串，但由于在ISO-8859-1编码方式中没有对应0xD6和0xD0的字符，所以前两个字符会产生两个问号，由于0x31在ISO-8859-1编码中对应字符“1”（ISO-8859-1也兼容ASCII），所以此语句得到str的值是“??1”。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我相信看了，上面这么些背景知识，是不是以前，不清楚的东西，都有写明白了？多看几次，就更能理解了 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java的string的字符串编码&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java的string的字符串编码&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java的string的字符串编码&quot;&gt;&lt;/a&gt;今天要分享的内容是java的string的字符串编码&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java中String的getBytes的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/26/java-getBytes/"/>
    <id>http://ghohankawk.github.io/2017/06/26/java-getBytes/</id>
    <published>2017-06-26T12:30:03.233Z</published>
    <updated>2017-07-14T11:33:01.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java的string方法getBytes"><a href="#今天要分享的内容是java的string方法getBytes" class="headerlink" title="今天要分享的内容是java的string方法getBytes"></a>今天要分享的内容是java的string方法getBytes</h1><a id="more"></a> 
<h1 id="先看一个测试用例"><a href="#先看一个测试用例" class="headerlink" title="先看一个测试用例"></a>先看一个测试用例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-26 20:28</div><div class="line"> */</div><div class="line">public class testGetBytes &#123;</div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * 1、Unicode是一种编码规范，是为解决全球字符通用编码而设计的，而rUTF-8,UTF-16等是这种规范的一种实现。</div><div class="line"></div><div class="line">     2、java内部采用Unicode编码规范，也就是支持多语言的，具体采用的UTF-16编码方式。</div><div class="line"></div><div class="line">     3、不管程序过程中用到了gbk,iso8859-1等格式，在存储与传递的过程中实际传递的都是Unicode编码的数据，要想接收到的值不出现乱码，就要保证传过去的时候用的是A编码，接收的时候也用A编码来转换接收。</div><div class="line"></div><div class="line">     4、如果双方的file.encoding确保都相同，那就省事了，都默认转了，但往往在不同项目交互时很多时候是不一致的，这个时候是必须要进行编码转换的。</div><div class="line"></div><div class="line">     5、无论如论转换，java程序的数据都是要先和Unicode做转换，这样也就是能处理多语言字符集的原因了。底层保持了一致，只要在传值和接值的时候也一致就肯定不会出现乱码了。</div><div class="line">     * */</div><div class="line"></div><div class="line">    public static void main(String[] args) throws UnsupportedEncodingException &#123;</div><div class="line"></div><div class="line"></div><div class="line">        String str = &quot;中文字符&quot;;</div><div class="line"></div><div class="line">        System.out.println(&quot;original string---&quot; + str);// 会正常输出原始串</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         * str.getBytes();  如果括号中不写charset，则采用的是Sytem.getProperty(&quot;file.encoding&quot;),即当前文件的编码方式，</div><div class="line">         *</div><div class="line">         * 很多人写的是系统的默认编码，通过代码测试并非如此，实际得到的是文件的编码方式*</div><div class="line">         *</div><div class="line">         * str.getBytes(&quot;charset&quot;);//指定charset，即将底层存储的Unicode码解析为charset编码格式的字节数组方式</div><div class="line">         *</div><div class="line">         * String new_str=new String(str.getBytes(&quot;utf-8&quot;),&quot;gbk&quot;));</div><div class="line">         *</div><div class="line">         * //将已经解析出来的字节数据转化为gbk编码格式的字符串，在内存中即为gbk格式的字节数组转为Unicode去交互传递</div><div class="line">         */</div><div class="line"></div><div class="line">        String new_str = new String(str.getBytes(&quot;utf-8&quot;), &quot;gbk&quot;);</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         * 此时的输出是乱码，在UTF-8的file.encoding下输出gbk格式的数据肯定是乱码,但是new_str的确是gbk编码式的</div><div class="line">         *</div><div class="line">         * 此时的乱码源于encoding不符，但gbk格式的new_str本身数据并没有问题,通过下面的转换也可以看得出来</div><div class="line">         */</div><div class="line"></div><div class="line">        System.out.println(&quot;new string----&quot; + new_str);</div><div class="line"></div><div class="line">        String final_str = new String(new_str.getBytes(&quot;gbk&quot;), &quot;utf-8&quot;);// 此处的含意与最上边的注释是一致的参数含意</div><div class="line"></div><div class="line">        /**</div><div class="line">         *</div><div class="line">         *输出是正常的，此时将gbk编码格式的new_str字符串，用gbk这个charset去解析它，然后用utf-8再转码一次，</div><div class="line">         *</div><div class="line">         * 因为new_str确实是gbk格式的，才能经过utf-8编码得到正常的数据显示。</div><div class="line">         */</div><div class="line"></div><div class="line">        System.out.println(&quot;final string---&quot; + final_str);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常说明，要干什么，再加一个链接按钮 <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">xxx</a>. </p>
<h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><pre><code>1. 首先，你要明白，什么是uinicode，她和utf-8，以及utf-16，是什么关系
2. 其实，你要知道，java中是用了，utf-16
3. 再深入一点，就是，你也必须知道byte这个类型，就是所谓的字节数组了
4. 他和int的区别，怎么转换
5. byte数组里面存储的内容，怎么转换成对应的中文字符的？什么编码映射关系，转过去的？
6. 还有就是，你会经常看到0xff，这种，还有&amp;，按位于的这种操作，具体是什么含义
7. 大小端的问题，是什么意思？在网络里面如何区分？
</code></pre><p>这个地方，之前其实就一直看过，每次看完一遍，以为真的懂了，但是，过后，还是不知道，啥原理</p>
<p>这次，写过了，可能过一段时间又忘记了，但是，如果真正的理解了原理的话，就难忘记了</p>
<p>这个地方，不管前后端，都必须掌握</p>
<p>去看ruan大神的，那片，unicode文章，绝对有收获。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java的string方法getBytes&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java的string方法getBytes&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java的string方法getBytes&quot;&gt;&lt;/a&gt;今天要分享的内容是java的string方法getBytes&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Java中的ThreadLocal用法</title>
    <link href="http://ghohankawk.github.io/2017/06/20/java-threadlocal/"/>
    <id>http://ghohankawk.github.io/2017/06/20/java-threadlocal/</id>
    <published>2017-06-20T12:24:34.673Z</published>
    <updated>2017-07-14T11:33:01.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是java中的ThreadLocal"><a href="#今天要分享的内容是java中的ThreadLocal" class="headerlink" title="今天要分享的内容是java中的ThreadLocal"></a>今天要分享的内容是java中的ThreadLocal</h1><p>并发编程中，一个重要的内容是数据共享。当你创建了实现Runnable接口的线程，然后开启使用相同Runnable实例的各种Thread对象，所有 的线程便共享定义在Runnable对象中的属性。也就是说，当你在一个线程中改变任意属性时，所有的线程都会因此受到影响，同时会看到第一个线程修改后的值。有时我们希望如此，比如：多个线程增大或减小同一个计数器变量；但是，有时我们希望确保每个线程，只能工作在它自己的线程实例的拷贝上，同时不会影 响其他线程的数据。<br><a id="more"></a> </p>
<h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>  ThreadLocal是一个关于创建线程局部变量的类。</p>
<p>  通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<p>Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。</p>
<ul>
<li>在当前线程中，任何一个点都可以访问到ThreadLocal的值。</li>
<li>该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。</li>
</ul>
<h1 id="如何创建ThreadLocal变量"><a href="#如何创建ThreadLocal变量" class="headerlink" title="如何创建ThreadLocal变量"></a>如何创建ThreadLocal变量</h1><pre><code>private ThreadLocal myThreadLocal = new ThreadLocal();
</code></pre><p>  通过这段代码实例化了一个ThreadLocal对象。我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。</p>
<h1 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h1><ol>
<li><p>创建，支持泛型</p>
<p>ThreadLocal<string> mStringThreadLocal = new ThreadLocal&lt;&gt;();</string></p>
</li>
<li><p>set方法</p>
<p>mStringThreadLocal.set(“hank”);</p>
</li>
<li><p>get方法</p>
<p>mStringThreadLocal.get();</p>
</li>
<li>initialValue()：返回当前线程赋予局部线程变量的初始值。<h1 id="具体用例"><a href="#具体用例" class="headerlink" title="具体用例"></a>具体用例</h1></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author hankun</div><div class="line"> * @create 2017-06-20 20:33</div><div class="line"> */</div><div class="line">public class threadlocal &#123;</div><div class="line">    public static class MyRunnable implements Runnable &#123;</div><div class="line"></div><div class="line">        private ThreadLocal threadLocal = new ThreadLocal();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            threadLocal.set((int) (Math.random() * 100D));</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;  ==  &quot; + threadLocal.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyRunnable my = new MyRunnable();</div><div class="line">        Thread thread1 = new Thread(my);</div><div class="line">        Thread thread2 = new Thread(my);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="关于InheritableThreadLocal"><a href="#关于InheritableThreadLocal" class="headerlink" title="关于InheritableThreadLocal"></a>关于InheritableThreadLocal</h1><p>InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。</p>
<p>【注：所有子线程都会继承父线程保存的ThreadLocal值】</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>局部线程通常使用在这样的情况下，当你有一些对象并不满足线程安全，但是你想避免在使用synchronized关键字、块时产生的同步访问，那么，让每个线程拥有它自己的对象实例。</p>
<p>注意：局部变量是同步或局部线程的一个好的替代，它总是能够保证线程安全。唯一可能限制你这样做的是你的应用设计约束。</p>
<p>这个地方，是因为看到项目中有些地方都有用到，所以自己也研究一下</p>
<p>单从用法而言，还是比较简单的，没啥难度，要是研究原理的问题的话，可以考虑深入看一下源代码</p>
<p>还有就是</p>
<p>思考一下这种方式，变量对象，是放在堆里面吗？还是堆里面？</p>
<p>答案是堆。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是java中的ThreadLocal&quot;&gt;&lt;a href=&quot;#今天要分享的内容是java中的ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是java中的ThreadLocal&quot;&gt;&lt;/a&gt;今天要分享的内容是java中的ThreadLocal&lt;/h1&gt;&lt;p&gt;并发编程中，一个重要的内容是数据共享。当你创建了实现Runnable接口的线程，然后开启使用相同Runnable实例的各种Thread对象，所有 的线程便共享定义在Runnable对象中的属性。也就是说，当你在一个线程中改变任意属性时，所有的线程都会因此受到影响，同时会看到第一个线程修改后的值。有时我们希望如此，比如：多个线程增大或减小同一个计数器变量；但是，有时我们希望确保每个线程，只能工作在它自己的线程实例的拷贝上，同时不会影 响其他线程的数据。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于requirejs的用法</title>
    <link href="http://ghohankawk.github.io/2017/06/19/requirejs/"/>
    <id>http://ghohankawk.github.io/2017/06/19/requirejs/</id>
    <published>2017-06-19T11:37:48.154Z</published>
    <updated>2017-07-14T11:33:01.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天要分享的内容是requirejs"><a href="#今天要分享的内容是requirejs" class="headerlink" title="今天要分享的内容是requirejs"></a>今天要分享的内容是requirejs</h1><a id="more"></a> 
<h1 id="AMD-简介"><a href="#AMD-简介" class="headerlink" title="AMD 简介"></a>AMD 简介</h1><p>  前端开发在近一两年发展的非常快，JavaScript 作为主流的开发语言得到了前所未有的热捧。大量的前端框架出现了，这些框架都在尝试着解决一些前端开发中的共性问题，但是实现又不尽相同。在这个背景下，CommonJS 社区诞生了，为了让前端框架发展的更加成熟，CommonJS 鼓励开发人员一起在社区里为一些完成特定功能的框架制定规范。AMD（Asynchronous Module Definition）就是其中的一个规范。</p>
<h1 id="RequireJS-简介"><a href="#RequireJS-简介" class="headerlink" title="RequireJS 简介"></a>RequireJS 简介</h1><p>  RequireJS 是一个非常小巧的 JavaScript 模块载入框架，是 AMD 规范最好的实现者之一。最新版本的 RequireJS 压缩后只有 14K，堪称非常轻量。它还同时可以和其他的框架协同工作，使用 RequireJS 必将使您的前端代码质量得以提升。 目前最新版本的 RequireJS 1.0.8 在 IE 6+、Firefox 2+、Safari 3.2+、Chrome 3+、Opera 10+ 上都工作的很好。</p>
<h1 id="案例一：-加载-JavaScript-文件"><a href="#案例一：-加载-JavaScript-文件" class="headerlink" title="案例一： 加载 JavaScript 文件"></a>案例一： 加载 JavaScript 文件</h1><pre><code>&lt;script src=&quot;./js/require.js&quot;&gt;&lt;/script&gt; 
     &lt;script&gt; 
    require([&quot;./js/a.js&quot;, &quot;./js/b.js&quot;], function() { 
             myFunctionA(); 
             myFunctionB(); 
        }); 
     &lt;/script&gt;

     这种方式，用来加载以前的js文件，就像本地引用一样，但是没有解决全局变量的问题
</code></pre><h1 id="案例二：-页面加载后执行-JavaScript"><a href="#案例二：-页面加载后执行-JavaScript" class="headerlink" title="案例二： 页面加载后执行 JavaScript"></a>案例二： 页面加载后执行 JavaScript</h1><p>   <script src="./js/require.js"></script><br>       <script><br>      require([“domReady!”, “./js/a.js”, “./js/b.js”], function() {<br>               myFunctionA();<br>               myFunctionB();<br>          });<br>       </script><br>       这个例子domReady!，解决了，有需要保证页面加载以后执行脚本时，RequireJS 提供了一个独立的 domReady 模块，需要去 RequireJS 官方网站下载这个模块</p>
<h1 id="AMD模块的写法"><a href="#AMD模块的写法" class="headerlink" title="AMD模块的写法"></a>AMD模块的写法</h1><p>  require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p>
<p>  具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p>
<p>  假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：</p>
<pre><code>// math.js
define(function (){
　　　　var add = function (x,y){
　　　　　　return x+y;
　　　　};
　　　　return {
　　　　　　add: add
　　　　};
});
</code></pre><p>  加载方法如下：</p>
<pre><code>// main.js
　　require([&apos;math&apos;], function (math){
　　　　alert(math.add(1,1));
　　});
</code></pre><h1 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h1><p>  理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p>
<p>  回答是可以的。</p>
<p>  这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>  举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<pre><code>require.config({
　　　　shim: {

　　　　　　&apos;underscore&apos;:{
　　　　　　　　exports: &apos;_&apos;
　　　　　　},
　　　　　　&apos;backbone&apos;: {
　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],
　　　　　　　　exports: &apos;Backbone&apos;
　　　　　　}
　　　　}
});
</code></pre><p>  require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</p>
<p>  比如，jQuery的插件可以这样定义：</p>
<pre><code>shim: {
　　　　&apos;jquery.scroll&apos;: {
　　　　　　deps: [&apos;jquery&apos;],
　　　　　　exports: &apos;jQuery.fn.scroll&apos;
　　　　}
}
</code></pre><h1 id="require-js插件"><a href="#require-js插件" class="headerlink" title="require.js插件"></a>require.js插件</h1><p>  require.js还提供一系列插件，实现一些特定的功能。</p>
<p>  domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<p>  require([‘domready!’], function (doc){<br>  　　　　// called once the DOM is ready<br>  　　});<br>  text和image插件，则是允许require.js加载文本和图片文件。</p>
<p>  define([<br>  　　　　‘text!review.txt’,<br>  　　　　‘image!cat.jpg’<br>  　　　　],</p>
<p>  　　　　function(review,cat){<br>  　　　　　　console.log(review);<br>  　　　　　　document.body.appendChild(cat);<br>  　　　　}<br>  　);<br>  类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>
<h1 id="在html中引入requirejs"><a href="#在html中引入requirejs" class="headerlink" title="在html中引入requirejs"></a>在html中引入requirejs</h1><p>  在HTML中，添加这样的 &lt; script&gt; 标签：</p>
<pre><code>&lt;script src=&quot;/path/to/require.js&quot; data-main=&quot;/path/to/app/config.js&quot;&gt;&lt;/script&gt;
</code></pre><p>  通常使用requirejs的话，我们只需要导入requirejs即可，不需要显式导入其它的js库，因为这个工作会交给requirejs来做。</p>
<p>  属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块。</p>
<h1 id="依赖一个不使用requirejs方式的库"><a href="#依赖一个不使用requirejs方式的库" class="headerlink" title="依赖一个不使用requirejs方式的库"></a>依赖一个不使用requirejs方式的库</h1><p>  前面的代码是理想的情况，即依赖的js文件，里面用了 define(…) 这样的方式来组织代码的。如果没用这种方式，会出现什么情况？</p>
<p>  比如这个 hello.js :</p>
<pre><code>function hello() {
alert(&quot;hello, world~&quot;);
}
</code></pre><p>  它就按最普通的方式定义了一个函数，我们能在requirejs里使用它吗？</p>
<p>  先看下面不能正确工作的代码：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  hello: &apos;hello&apos;
}
});

requirejs([&apos;hello&apos;], function(hello) {
hello();
});
</code></pre><p>  这段代码会报错，提示：</p>
<p>  Uncaught TypeError: undefined is not a function<br>  原因是最后调用 hello() 的时候，这个 hello 是个 undefined . 这说明，虽然我们依赖了一个js库（它会被载入），但requirejs无法从中拿到代表它的对象注入进来供我们使用。</p>
<p>  在这种情况下，我们要使用 shim ，将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  hello: &apos;hello&apos;
},
shim: {
  hello: { exports: &apos;hello&apos; }
}
});

requirejs([&apos;hello&apos;], function(hello) {
hello();
});
</code></pre><p>  再运行就正常了。</p>
<p>  上面代码 exports: ‘hello’ 中的 hello ，是我们在 hello.js 中定义的 hello 函数。当我们使用 function hello() {} 的方式定义一个函数的时候，它就是全局可用的。如果我们选择了把它 export 给requirejs，那当我们的代码依赖于 hello 模块的时候，就可以拿到这个 hello 函数的引用了。</p>
<p>  所以： exports 可以把某个非requirejs方式的代码中的某一个<strong>全局变量</strong>暴露出去，当作该模块以引用。</p>
<h1 id="无主的与有主的模块"><a href="#无主的与有主的模块" class="headerlink" title="无主的与有主的模块"></a>无主的与有主的模块</h1><p>  我遇到了一个折腾我不少时间的问题：为什么我只能使用 jquery 来依赖jquery, 而不能用其它的名字？</p>
<p>  比如下面这段代码：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  myjquery: &apos;lib/jquery/jquery&apos;
}
});

requirejs([&apos;myjquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  它会提示我：</p>
<p>  jq is undefined<br>  但我仅仅改个名字：</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  jquery: &apos;lib/jquery/jquery&apos;
}
});

requirejs([&apos;jquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  就一切正常了，能打印出 jq 相应的对象了。</p>
<p>  为什么？我始终没搞清楚问题在哪儿。</p>
<h1 id="有主的模块"><a href="#有主的模块" class="headerlink" title="有主的模块"></a>有主的模块</h1><p>  经常研究，发现原来在jquery中已经定义了：</p>
<pre><code>define(&apos;jquery&apos;, [], function() { ... });
</code></pre><p>  它这里的 define 跟我们前面看到的 app.js 不同，在于它多了第一个参数 ‘jquery’ ，表示给当前这个模块起了名字 jquery ，它已经是有主的了，只能属于 jquery .</p>
<p>  所以当我们使用另一个名字：</p>
<p>  myjquery: ‘lib/jquery/jquery’<br>  去引用这个库的时候，它会发现，在 jquery.js 里声明的模块名 jquery 与我自己使用的模块名 myjquery 冲突，便不会把它赋给 myjquery ，所以 myjquery 的值是 undefined 。</p>
<p>  所以我们在使用一个第三方的时候，一定要注意它是否声明了一个确定的模块名。</p>
<h1 id="无主的模块"><a href="#无主的模块" class="headerlink" title="无主的模块"></a>无主的模块</h1><p>  如果我们不指明模块名，就像这样：</p>
<pre><code>define([...], function() {
...
});
</code></pre><p>  那么它就是无主的模块。我们可以在 requirejs.config 里，使用任意一个模块名来引用它。这样的话，就让我们的命名非常自由，大部分的模块就是无主的。</p>
<h1 id="为什么有的有主，有的无主"><a href="#为什么有的有主，有的无主" class="headerlink" title="为什么有的有主，有的无主"></a>为什么有的有主，有的无主</h1><p>  可以看到，无主的模块使用起来非常自由，为什么某些库（jquery, underscore）要把自己声明为有主的呢？</p>
<p>  按某些说法，这么做是出于性能的考虑。因为像 jquery , underscore 这样的基础库，经常被其它的库依赖。如果声明为无主的，那么其它的库很可能起不同的模块名，这样当我们使用它们时，就可能会多次载入jquery/underscore。</p>
<p>  而把它们声明为有主的，那么所有的模块只能使用同一个名字引用它们，这样系统就只会载入它们一次。</p>
<h1 id="强行该名称的方法"><a href="#强行该名称的方法" class="headerlink" title="强行该名称的方法"></a>强行该名称的方法</h1><p>  对于有主的模块，我们还有一种方式可以挖墙角：不把它们当作满足requirejs规范的模块，而当作普通js库，然后在 shim 中导出它们定义的全局变量。</p>
<pre><code>requirejs.config({
baseUrl: &apos;/public/js&apos;,
paths: {
  myjquery: &apos;lib/jquery/jquery&apos;
},
shim: {
  myjquery: { exports: &apos;jQuery&apos; }
}
});

requirejs([&apos;myjquery&apos;], function(jq) {
alert(jq);
});
</code></pre><p>  这样通过暴露 jQuery 这个全局变量给 myjquery ，我们就能正常的使用它了。</p>
<p>  不过我们完全没有必要这么挖墙角，因为对于我们来说，似乎没有任何好处。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 关于这块部分，我是看项目里有用到这个前端的组件，而自己没有实际开发过，因此<br> 对这个部分，理解不深刻，也就是现在能看懂的阶段了，主要是参考了好几篇关于<br> requirejs的文章总结的</p>
<p> 还有就是，这个部分其实一直就有了解，因此也不是完全不懂的去学</p>
<p> 反正是先入手学一下是很有必要的，</p>
<p> 哎，最近发现那个requirejs的中文网，不知道怎么滴就访问不了，好像只能去看英文文档了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天要分享的内容是requirejs&quot;&gt;&lt;a href=&quot;#今天要分享的内容是requirejs&quot; class=&quot;headerlink&quot; title=&quot;今天要分享的内容是requirejs&quot;&gt;&lt;/a&gt;今天要分享的内容是requirejs&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
